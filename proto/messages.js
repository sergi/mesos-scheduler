/// <reference path="messages.d.ts" />
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const mesos = $root.mesos = (() => {

    /**
     * Namespace mesos.
     * @exports mesos
     * @namespace
     */
    const mesos = {};

    /**
     * Status is used to indicate the state of the scheduler and executor
     * driver after function calls.
     * @enum {string}
     * @property {number} DRIVER_NOT_STARTED=1 DRIVER_NOT_STARTED value
     * @property {number} DRIVER_RUNNING=2 DRIVER_RUNNING value
     * @property {number} DRIVER_ABORTED=3 DRIVER_ABORTED value
     * @property {number} DRIVER_STOPPED=4 DRIVER_STOPPED value
     */
    mesos.Status = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "DRIVER_NOT_STARTED"] = 1;
        values[valuesById[2] = "DRIVER_RUNNING"] = 2;
        values[valuesById[3] = "DRIVER_ABORTED"] = 3;
        values[valuesById[4] = "DRIVER_STOPPED"] = 4;
        return values;
    })();

    mesos.FrameworkID = (function() {

        /**
         * Properties of a FrameworkID.
         * @memberof mesos
         * @interface IFrameworkID
         * @property {string} value FrameworkID value
         */

        /**
         * Constructs a new FrameworkID.
         * @memberof mesos
         * @classdesc A unique ID assigned to a framework. A framework can reuse this ID
         * in order to do failover (see MesosSchedulerDriver).
         * @constructor
         * @param {mesos.IFrameworkID=} [properties] Properties to set
         */
        function FrameworkID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FrameworkID value.
         * @member {string}value
         * @memberof mesos.FrameworkID
         * @instance
         */
        FrameworkID.prototype.value = "";

        /**
         * Creates a new FrameworkID instance using the specified properties.
         * @function create
         * @memberof mesos.FrameworkID
         * @static
         * @param {mesos.IFrameworkID=} [properties] Properties to set
         * @returns {mesos.FrameworkID} FrameworkID instance
         */
        FrameworkID.create = function create(properties) {
            return new FrameworkID(properties);
        };

        /**
         * Encodes the specified FrameworkID message. Does not implicitly {@link mesos.FrameworkID.verify|verify} messages.
         * @function encode
         * @memberof mesos.FrameworkID
         * @static
         * @param {mesos.IFrameworkID} message FrameworkID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrameworkID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified FrameworkID message, length delimited. Does not implicitly {@link mesos.FrameworkID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.FrameworkID
         * @static
         * @param {mesos.IFrameworkID} message FrameworkID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrameworkID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FrameworkID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.FrameworkID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.FrameworkID} FrameworkID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrameworkID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.FrameworkID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a FrameworkID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.FrameworkID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.FrameworkID} FrameworkID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrameworkID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FrameworkID message.
         * @function verify
         * @memberof mesos.FrameworkID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FrameworkID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates a FrameworkID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.FrameworkID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.FrameworkID} FrameworkID
         */
        FrameworkID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.FrameworkID)
                return object;
            let message = new $root.mesos.FrameworkID();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a FrameworkID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.FrameworkID
         * @static
         * @param {mesos.FrameworkID} message FrameworkID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FrameworkID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this FrameworkID to JSON.
         * @function toJSON
         * @memberof mesos.FrameworkID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FrameworkID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FrameworkID;
    })();

    mesos.OfferID = (function() {

        /**
         * Properties of an OfferID.
         * @memberof mesos
         * @interface IOfferID
         * @property {string} value OfferID value
         */

        /**
         * Constructs a new OfferID.
         * @memberof mesos
         * @classdesc A unique ID assigned to an offer.
         * @constructor
         * @param {mesos.IOfferID=} [properties] Properties to set
         */
        function OfferID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OfferID value.
         * @member {string}value
         * @memberof mesos.OfferID
         * @instance
         */
        OfferID.prototype.value = "";

        /**
         * Creates a new OfferID instance using the specified properties.
         * @function create
         * @memberof mesos.OfferID
         * @static
         * @param {mesos.IOfferID=} [properties] Properties to set
         * @returns {mesos.OfferID} OfferID instance
         */
        OfferID.create = function create(properties) {
            return new OfferID(properties);
        };

        /**
         * Encodes the specified OfferID message. Does not implicitly {@link mesos.OfferID.verify|verify} messages.
         * @function encode
         * @memberof mesos.OfferID
         * @static
         * @param {mesos.IOfferID} message OfferID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OfferID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified OfferID message, length delimited. Does not implicitly {@link mesos.OfferID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.OfferID
         * @static
         * @param {mesos.IOfferID} message OfferID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OfferID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OfferID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.OfferID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.OfferID} OfferID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OfferID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.OfferID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an OfferID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.OfferID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.OfferID} OfferID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OfferID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OfferID message.
         * @function verify
         * @memberof mesos.OfferID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OfferID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates an OfferID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.OfferID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.OfferID} OfferID
         */
        OfferID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.OfferID)
                return object;
            let message = new $root.mesos.OfferID();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from an OfferID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.OfferID
         * @static
         * @param {mesos.OfferID} message OfferID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OfferID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this OfferID to JSON.
         * @function toJSON
         * @memberof mesos.OfferID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OfferID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OfferID;
    })();

    mesos.AgentID = (function() {

        /**
         * Properties of an AgentID.
         * @memberof mesos
         * @interface IAgentID
         * @property {string} value AgentID value
         */

        /**
         * Constructs a new AgentID.
         * @memberof mesos
         * @classdesc A unique ID assigned to an agent. Currently, an agent gets a new ID
         * whenever it (re)registers with Mesos. Framework writers shouldn't
         * assume any binding between an agent ID and and a hostname.
         * @constructor
         * @param {mesos.IAgentID=} [properties] Properties to set
         */
        function AgentID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AgentID value.
         * @member {string}value
         * @memberof mesos.AgentID
         * @instance
         */
        AgentID.prototype.value = "";

        /**
         * Creates a new AgentID instance using the specified properties.
         * @function create
         * @memberof mesos.AgentID
         * @static
         * @param {mesos.IAgentID=} [properties] Properties to set
         * @returns {mesos.AgentID} AgentID instance
         */
        AgentID.create = function create(properties) {
            return new AgentID(properties);
        };

        /**
         * Encodes the specified AgentID message. Does not implicitly {@link mesos.AgentID.verify|verify} messages.
         * @function encode
         * @memberof mesos.AgentID
         * @static
         * @param {mesos.IAgentID} message AgentID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AgentID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified AgentID message, length delimited. Does not implicitly {@link mesos.AgentID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.AgentID
         * @static
         * @param {mesos.IAgentID} message AgentID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AgentID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AgentID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.AgentID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.AgentID} AgentID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AgentID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.AgentID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an AgentID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.AgentID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.AgentID} AgentID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AgentID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AgentID message.
         * @function verify
         * @memberof mesos.AgentID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AgentID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates an AgentID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.AgentID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.AgentID} AgentID
         */
        AgentID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.AgentID)
                return object;
            let message = new $root.mesos.AgentID();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from an AgentID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.AgentID
         * @static
         * @param {mesos.AgentID} message AgentID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AgentID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this AgentID to JSON.
         * @function toJSON
         * @memberof mesos.AgentID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AgentID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AgentID;
    })();

    mesos.TaskID = (function() {

        /**
         * Properties of a TaskID.
         * @memberof mesos
         * @interface ITaskID
         * @property {string} value TaskID value
         */

        /**
         * Constructs a new TaskID.
         * @memberof mesos
         * @classdesc A framework-generated ID to distinguish a task. The ID must remain
         * unique while the task is active. A framework can reuse an ID _only_
         * if the previous task with the same ID has reached a terminal state
         * (e.g., TASK_FINISHED, TASK_LOST, TASK_KILLED, etc.). However,
         * reusing task IDs is strongly discouraged (MESOS-2198).
         * @constructor
         * @param {mesos.ITaskID=} [properties] Properties to set
         */
        function TaskID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskID value.
         * @member {string}value
         * @memberof mesos.TaskID
         * @instance
         */
        TaskID.prototype.value = "";

        /**
         * Creates a new TaskID instance using the specified properties.
         * @function create
         * @memberof mesos.TaskID
         * @static
         * @param {mesos.ITaskID=} [properties] Properties to set
         * @returns {mesos.TaskID} TaskID instance
         */
        TaskID.create = function create(properties) {
            return new TaskID(properties);
        };

        /**
         * Encodes the specified TaskID message. Does not implicitly {@link mesos.TaskID.verify|verify} messages.
         * @function encode
         * @memberof mesos.TaskID
         * @static
         * @param {mesos.ITaskID} message TaskID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified TaskID message, length delimited. Does not implicitly {@link mesos.TaskID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TaskID
         * @static
         * @param {mesos.ITaskID} message TaskID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TaskID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TaskID} TaskID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TaskID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a TaskID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TaskID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TaskID} TaskID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskID message.
         * @function verify
         * @memberof mesos.TaskID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates a TaskID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TaskID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TaskID} TaskID
         */
        TaskID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TaskID)
                return object;
            let message = new $root.mesos.TaskID();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a TaskID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TaskID
         * @static
         * @param {mesos.TaskID} message TaskID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this TaskID to JSON.
         * @function toJSON
         * @memberof mesos.TaskID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskID;
    })();

    mesos.ExecutorID = (function() {

        /**
         * Properties of an ExecutorID.
         * @memberof mesos
         * @interface IExecutorID
         * @property {string} value ExecutorID value
         */

        /**
         * Constructs a new ExecutorID.
         * @memberof mesos
         * @classdesc A framework-generated ID to distinguish an executor. Only one
         * executor with the same ID can be active on the same agent at a
         * time. However, reusing executor IDs is discouraged.
         * @constructor
         * @param {mesos.IExecutorID=} [properties] Properties to set
         */
        function ExecutorID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutorID value.
         * @member {string}value
         * @memberof mesos.ExecutorID
         * @instance
         */
        ExecutorID.prototype.value = "";

        /**
         * Creates a new ExecutorID instance using the specified properties.
         * @function create
         * @memberof mesos.ExecutorID
         * @static
         * @param {mesos.IExecutorID=} [properties] Properties to set
         * @returns {mesos.ExecutorID} ExecutorID instance
         */
        ExecutorID.create = function create(properties) {
            return new ExecutorID(properties);
        };

        /**
         * Encodes the specified ExecutorID message. Does not implicitly {@link mesos.ExecutorID.verify|verify} messages.
         * @function encode
         * @memberof mesos.ExecutorID
         * @static
         * @param {mesos.IExecutorID} message ExecutorID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutorID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified ExecutorID message, length delimited. Does not implicitly {@link mesos.ExecutorID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ExecutorID
         * @static
         * @param {mesos.IExecutorID} message ExecutorID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutorID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutorID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ExecutorID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ExecutorID} ExecutorID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutorID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ExecutorID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExecutorID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ExecutorID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ExecutorID} ExecutorID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutorID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutorID message.
         * @function verify
         * @memberof mesos.ExecutorID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutorID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates an ExecutorID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ExecutorID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ExecutorID} ExecutorID
         */
        ExecutorID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ExecutorID)
                return object;
            let message = new $root.mesos.ExecutorID();
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from an ExecutorID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ExecutorID
         * @static
         * @param {mesos.ExecutorID} message ExecutorID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutorID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.value = "";
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this ExecutorID to JSON.
         * @function toJSON
         * @memberof mesos.ExecutorID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutorID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutorID;
    })();

    mesos.ContainerID = (function() {

        /**
         * Properties of a ContainerID.
         * @memberof mesos
         * @interface IContainerID
         * @property {string} value ContainerID value
         * @property {mesos.IContainerID} [parent] ContainerID parent
         */

        /**
         * Constructs a new ContainerID.
         * @memberof mesos
         * @classdesc ID used to uniquely identify a container. If the `parent` is not
         * specified, the ID is a UUID generated by the agent to uniquely
         * identify the container of an executor run. If the `parent` field is
         * specified, it represents a nested container.
         * @constructor
         * @param {mesos.IContainerID=} [properties] Properties to set
         */
        function ContainerID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContainerID value.
         * @member {string}value
         * @memberof mesos.ContainerID
         * @instance
         */
        ContainerID.prototype.value = "";

        /**
         * ContainerID parent.
         * @member {(mesos.IContainerID|null|undefined)}parent
         * @memberof mesos.ContainerID
         * @instance
         */
        ContainerID.prototype.parent = null;

        /**
         * Creates a new ContainerID instance using the specified properties.
         * @function create
         * @memberof mesos.ContainerID
         * @static
         * @param {mesos.IContainerID=} [properties] Properties to set
         * @returns {mesos.ContainerID} ContainerID instance
         */
        ContainerID.create = function create(properties) {
            return new ContainerID(properties);
        };

        /**
         * Encodes the specified ContainerID message. Does not implicitly {@link mesos.ContainerID.verify|verify} messages.
         * @function encode
         * @memberof mesos.ContainerID
         * @static
         * @param {mesos.IContainerID} message ContainerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            if (message.parent != null && message.hasOwnProperty("parent"))
                $root.mesos.ContainerID.encode(message.parent, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContainerID message, length delimited. Does not implicitly {@link mesos.ContainerID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ContainerID
         * @static
         * @param {mesos.IContainerID} message ContainerID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContainerID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ContainerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ContainerID} ContainerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.parent = $root.mesos.ContainerID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a ContainerID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ContainerID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ContainerID} ContainerID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContainerID message.
         * @function verify
         * @memberof mesos.ContainerID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContainerID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            if (message.parent != null && message.hasOwnProperty("parent")) {
                let error = $root.mesos.ContainerID.verify(message.parent);
                if (error)
                    return "parent." + error;
            }
            return null;
        };

        /**
         * Creates a ContainerID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ContainerID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ContainerID} ContainerID
         */
        ContainerID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ContainerID)
                return object;
            let message = new $root.mesos.ContainerID();
            if (object.value != null)
                message.value = String(object.value);
            if (object.parent != null) {
                if (typeof object.parent !== "object")
                    throw TypeError(".mesos.ContainerID.parent: object expected");
                message.parent = $root.mesos.ContainerID.fromObject(object.parent);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContainerID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ContainerID
         * @static
         * @param {mesos.ContainerID} message ContainerID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContainerID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = "";
                object.parent = null;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.parent != null && message.hasOwnProperty("parent"))
                object.parent = $root.mesos.ContainerID.toObject(message.parent, options);
            return object;
        };

        /**
         * Converts this ContainerID to JSON.
         * @function toJSON
         * @memberof mesos.ContainerID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContainerID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContainerID;
    })();

    mesos.TimeInfo = (function() {

        /**
         * Properties of a TimeInfo.
         * @memberof mesos
         * @interface ITimeInfo
         * @property {number|Long} nanoseconds TimeInfo nanoseconds
         */

        /**
         * Constructs a new TimeInfo.
         * @memberof mesos
         * @classdesc Represents time since the epoch, in nanoseconds.
         * @constructor
         * @param {mesos.ITimeInfo=} [properties] Properties to set
         */
        function TimeInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimeInfo nanoseconds.
         * @member {number|Long}nanoseconds
         * @memberof mesos.TimeInfo
         * @instance
         */
        TimeInfo.prototype.nanoseconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TimeInfo instance using the specified properties.
         * @function create
         * @memberof mesos.TimeInfo
         * @static
         * @param {mesos.ITimeInfo=} [properties] Properties to set
         * @returns {mesos.TimeInfo} TimeInfo instance
         */
        TimeInfo.create = function create(properties) {
            return new TimeInfo(properties);
        };

        /**
         * Encodes the specified TimeInfo message. Does not implicitly {@link mesos.TimeInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.TimeInfo
         * @static
         * @param {mesos.ITimeInfo} message TimeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.nanoseconds);
            return writer;
        };

        /**
         * Encodes the specified TimeInfo message, length delimited. Does not implicitly {@link mesos.TimeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TimeInfo
         * @static
         * @param {mesos.ITimeInfo} message TimeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TimeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TimeInfo} TimeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TimeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nanoseconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("nanoseconds"))
                throw $util.ProtocolError("missing required 'nanoseconds'", { instance: message });
            return message;
        };

        /**
         * Decodes a TimeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TimeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TimeInfo} TimeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimeInfo message.
         * @function verify
         * @memberof mesos.TimeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.nanoseconds) && !(message.nanoseconds && $util.isInteger(message.nanoseconds.low) && $util.isInteger(message.nanoseconds.high)))
                return "nanoseconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a TimeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TimeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TimeInfo} TimeInfo
         */
        TimeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TimeInfo)
                return object;
            let message = new $root.mesos.TimeInfo();
            if (object.nanoseconds != null)
                if ($util.Long)
                    (message.nanoseconds = $util.Long.fromValue(object.nanoseconds)).unsigned = false;
                else if (typeof object.nanoseconds === "string")
                    message.nanoseconds = parseInt(object.nanoseconds, 10);
                else if (typeof object.nanoseconds === "number")
                    message.nanoseconds = object.nanoseconds;
                else if (typeof object.nanoseconds === "object")
                    message.nanoseconds = new $util.LongBits(object.nanoseconds.low >>> 0, object.nanoseconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TimeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TimeInfo
         * @static
         * @param {mesos.TimeInfo} message TimeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.nanoseconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nanoseconds = options.longs === String ? "0" : 0;
            if (message.nanoseconds != null && message.hasOwnProperty("nanoseconds"))
                if (typeof message.nanoseconds === "number")
                    object.nanoseconds = options.longs === String ? String(message.nanoseconds) : message.nanoseconds;
                else
                    object.nanoseconds = options.longs === String ? $util.Long.prototype.toString.call(message.nanoseconds) : options.longs === Number ? new $util.LongBits(message.nanoseconds.low >>> 0, message.nanoseconds.high >>> 0).toNumber() : message.nanoseconds;
            return object;
        };

        /**
         * Converts this TimeInfo to JSON.
         * @function toJSON
         * @memberof mesos.TimeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimeInfo;
    })();

    mesos.DurationInfo = (function() {

        /**
         * Properties of a DurationInfo.
         * @memberof mesos
         * @interface IDurationInfo
         * @property {number|Long} nanoseconds DurationInfo nanoseconds
         */

        /**
         * Constructs a new DurationInfo.
         * @memberof mesos
         * @classdesc Represents duration in nanoseconds.
         * @constructor
         * @param {mesos.IDurationInfo=} [properties] Properties to set
         */
        function DurationInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DurationInfo nanoseconds.
         * @member {number|Long}nanoseconds
         * @memberof mesos.DurationInfo
         * @instance
         */
        DurationInfo.prototype.nanoseconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DurationInfo instance using the specified properties.
         * @function create
         * @memberof mesos.DurationInfo
         * @static
         * @param {mesos.IDurationInfo=} [properties] Properties to set
         * @returns {mesos.DurationInfo} DurationInfo instance
         */
        DurationInfo.create = function create(properties) {
            return new DurationInfo(properties);
        };

        /**
         * Encodes the specified DurationInfo message. Does not implicitly {@link mesos.DurationInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.DurationInfo
         * @static
         * @param {mesos.IDurationInfo} message DurationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DurationInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.nanoseconds);
            return writer;
        };

        /**
         * Encodes the specified DurationInfo message, length delimited. Does not implicitly {@link mesos.DurationInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.DurationInfo
         * @static
         * @param {mesos.IDurationInfo} message DurationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DurationInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DurationInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.DurationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.DurationInfo} DurationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DurationInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.DurationInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nanoseconds = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("nanoseconds"))
                throw $util.ProtocolError("missing required 'nanoseconds'", { instance: message });
            return message;
        };

        /**
         * Decodes a DurationInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.DurationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.DurationInfo} DurationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DurationInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DurationInfo message.
         * @function verify
         * @memberof mesos.DurationInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DurationInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.nanoseconds) && !(message.nanoseconds && $util.isInteger(message.nanoseconds.low) && $util.isInteger(message.nanoseconds.high)))
                return "nanoseconds: integer|Long expected";
            return null;
        };

        /**
         * Creates a DurationInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.DurationInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.DurationInfo} DurationInfo
         */
        DurationInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.DurationInfo)
                return object;
            let message = new $root.mesos.DurationInfo();
            if (object.nanoseconds != null)
                if ($util.Long)
                    (message.nanoseconds = $util.Long.fromValue(object.nanoseconds)).unsigned = false;
                else if (typeof object.nanoseconds === "string")
                    message.nanoseconds = parseInt(object.nanoseconds, 10);
                else if (typeof object.nanoseconds === "number")
                    message.nanoseconds = object.nanoseconds;
                else if (typeof object.nanoseconds === "object")
                    message.nanoseconds = new $util.LongBits(object.nanoseconds.low >>> 0, object.nanoseconds.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DurationInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.DurationInfo
         * @static
         * @param {mesos.DurationInfo} message DurationInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DurationInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.nanoseconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nanoseconds = options.longs === String ? "0" : 0;
            if (message.nanoseconds != null && message.hasOwnProperty("nanoseconds"))
                if (typeof message.nanoseconds === "number")
                    object.nanoseconds = options.longs === String ? String(message.nanoseconds) : message.nanoseconds;
                else
                    object.nanoseconds = options.longs === String ? $util.Long.prototype.toString.call(message.nanoseconds) : options.longs === Number ? new $util.LongBits(message.nanoseconds.low >>> 0, message.nanoseconds.high >>> 0).toNumber() : message.nanoseconds;
            return object;
        };

        /**
         * Converts this DurationInfo to JSON.
         * @function toJSON
         * @memberof mesos.DurationInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DurationInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DurationInfo;
    })();

    mesos.Address = (function() {

        /**
         * Properties of an Address.
         * @memberof mesos
         * @interface IAddress
         * @property {string} [hostname] Address hostname
         * @property {string} [ip] Address ip
         * @property {number} port Address port
         */

        /**
         * Constructs a new Address.
         * @memberof mesos
         * @classdesc A network address.
         * 
         * TODO(bmahler): Use this more widely.
         * @constructor
         * @param {mesos.IAddress=} [properties] Properties to set
         */
        function Address(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Address hostname.
         * @member {string}hostname
         * @memberof mesos.Address
         * @instance
         */
        Address.prototype.hostname = "";

        /**
         * Address ip.
         * @member {string}ip
         * @memberof mesos.Address
         * @instance
         */
        Address.prototype.ip = "";

        /**
         * Address port.
         * @member {number}port
         * @memberof mesos.Address
         * @instance
         */
        Address.prototype.port = 0;

        /**
         * Creates a new Address instance using the specified properties.
         * @function create
         * @memberof mesos.Address
         * @static
         * @param {mesos.IAddress=} [properties] Properties to set
         * @returns {mesos.Address} Address instance
         */
        Address.create = function create(properties) {
            return new Address(properties);
        };

        /**
         * Encodes the specified Address message. Does not implicitly {@link mesos.Address.verify|verify} messages.
         * @function encode
         * @memberof mesos.Address
         * @static
         * @param {mesos.IAddress} message Address message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Address.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.ip != null && message.hasOwnProperty("ip"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ip);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);
            return writer;
        };

        /**
         * Encodes the specified Address message, length delimited. Does not implicitly {@link mesos.Address.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Address
         * @static
         * @param {mesos.IAddress} message Address message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Address.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Address message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Address
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Address} Address
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Address.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Address();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 2:
                    message.ip = reader.string();
                    break;
                case 3:
                    message.port = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("port"))
                throw $util.ProtocolError("missing required 'port'", { instance: message });
            return message;
        };

        /**
         * Decodes an Address message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Address
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Address} Address
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Address.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Address message.
         * @function verify
         * @memberof mesos.Address
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Address.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (!$util.isInteger(message.port))
                return "port: integer expected";
            return null;
        };

        /**
         * Creates an Address message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Address
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Address} Address
         */
        Address.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Address)
                return object;
            let message = new $root.mesos.Address();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.port != null)
                message.port = object.port | 0;
            return message;
        };

        /**
         * Creates a plain object from an Address message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Address
         * @static
         * @param {mesos.Address} message Address
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Address.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.hostname = "";
                object.ip = "";
                object.port = 0;
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this Address to JSON.
         * @function toJSON
         * @memberof mesos.Address
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Address.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Address;
    })();

    mesos.URL = (function() {

        /**
         * Properties of a URL.
         * @memberof mesos
         * @interface IURL
         * @property {string} scheme URL scheme
         * @property {mesos.IAddress} address URL address
         * @property {string} [path] URL path
         * @property {Array.<mesos.IParameter>} [query] URL query
         * @property {string} [fragment] URL fragment
         */

        /**
         * Constructs a new URL.
         * @memberof mesos
         * @classdesc Represents a URL.
         * @constructor
         * @param {mesos.IURL=} [properties] Properties to set
         */
        function URL(properties) {
            this.query = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * URL scheme.
         * @member {string}scheme
         * @memberof mesos.URL
         * @instance
         */
        URL.prototype.scheme = "";

        /**
         * URL address.
         * @member {mesos.IAddress}address
         * @memberof mesos.URL
         * @instance
         */
        URL.prototype.address = null;

        /**
         * URL path.
         * @member {string}path
         * @memberof mesos.URL
         * @instance
         */
        URL.prototype.path = "";

        /**
         * URL query.
         * @member {Array.<mesos.IParameter>}query
         * @memberof mesos.URL
         * @instance
         */
        URL.prototype.query = $util.emptyArray;

        /**
         * URL fragment.
         * @member {string}fragment
         * @memberof mesos.URL
         * @instance
         */
        URL.prototype.fragment = "";

        /**
         * Creates a new URL instance using the specified properties.
         * @function create
         * @memberof mesos.URL
         * @static
         * @param {mesos.IURL=} [properties] Properties to set
         * @returns {mesos.URL} URL instance
         */
        URL.create = function create(properties) {
            return new URL(properties);
        };

        /**
         * Encodes the specified URL message. Does not implicitly {@link mesos.URL.verify|verify} messages.
         * @function encode
         * @memberof mesos.URL
         * @static
         * @param {mesos.IURL} message URL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        URL.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.scheme);
            $root.mesos.Address.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.path != null && message.hasOwnProperty("path"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);
            if (message.query != null && message.query.length)
                for (let i = 0; i < message.query.length; ++i)
                    $root.mesos.Parameter.encode(message.query[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.fragment != null && message.hasOwnProperty("fragment"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.fragment);
            return writer;
        };

        /**
         * Encodes the specified URL message, length delimited. Does not implicitly {@link mesos.URL.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.URL
         * @static
         * @param {mesos.IURL} message URL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        URL.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a URL message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.URL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.URL} URL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        URL.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.URL();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.scheme = reader.string();
                    break;
                case 2:
                    message.address = $root.mesos.Address.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.path = reader.string();
                    break;
                case 4:
                    if (!(message.query && message.query.length))
                        message.query = [];
                    message.query.push($root.mesos.Parameter.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.fragment = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("scheme"))
                throw $util.ProtocolError("missing required 'scheme'", { instance: message });
            if (!message.hasOwnProperty("address"))
                throw $util.ProtocolError("missing required 'address'", { instance: message });
            return message;
        };

        /**
         * Decodes a URL message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.URL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.URL} URL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        URL.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a URL message.
         * @function verify
         * @memberof mesos.URL
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        URL.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.scheme))
                return "scheme: string expected";
            let error = $root.mesos.Address.verify(message.address);
            if (error)
                return "address." + error;
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.query != null && message.hasOwnProperty("query")) {
                if (!Array.isArray(message.query))
                    return "query: array expected";
                for (let i = 0; i < message.query.length; ++i) {
                    error = $root.mesos.Parameter.verify(message.query[i]);
                    if (error)
                        return "query." + error;
                }
            }
            if (message.fragment != null && message.hasOwnProperty("fragment"))
                if (!$util.isString(message.fragment))
                    return "fragment: string expected";
            return null;
        };

        /**
         * Creates a URL message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.URL
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.URL} URL
         */
        URL.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.URL)
                return object;
            let message = new $root.mesos.URL();
            if (object.scheme != null)
                message.scheme = String(object.scheme);
            if (object.address != null) {
                if (typeof object.address !== "object")
                    throw TypeError(".mesos.URL.address: object expected");
                message.address = $root.mesos.Address.fromObject(object.address);
            }
            if (object.path != null)
                message.path = String(object.path);
            if (object.query) {
                if (!Array.isArray(object.query))
                    throw TypeError(".mesos.URL.query: array expected");
                message.query = [];
                for (let i = 0; i < object.query.length; ++i) {
                    if (typeof object.query[i] !== "object")
                        throw TypeError(".mesos.URL.query: object expected");
                    message.query[i] = $root.mesos.Parameter.fromObject(object.query[i]);
                }
            }
            if (object.fragment != null)
                message.fragment = String(object.fragment);
            return message;
        };

        /**
         * Creates a plain object from a URL message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.URL
         * @static
         * @param {mesos.URL} message URL
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        URL.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.query = [];
            if (options.defaults) {
                object.scheme = "";
                object.address = null;
                object.path = "";
                object.fragment = "";
            }
            if (message.scheme != null && message.hasOwnProperty("scheme"))
                object.scheme = message.scheme;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = $root.mesos.Address.toObject(message.address, options);
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.query && message.query.length) {
                object.query = [];
                for (let j = 0; j < message.query.length; ++j)
                    object.query[j] = $root.mesos.Parameter.toObject(message.query[j], options);
            }
            if (message.fragment != null && message.hasOwnProperty("fragment"))
                object.fragment = message.fragment;
            return object;
        };

        /**
         * Converts this URL to JSON.
         * @function toJSON
         * @memberof mesos.URL
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        URL.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return URL;
    })();

    mesos.Unavailability = (function() {

        /**
         * Properties of an Unavailability.
         * @memberof mesos
         * @interface IUnavailability
         * @property {mesos.ITimeInfo} start Unavailability start
         * @property {mesos.IDurationInfo} [duration] Unavailability duration
         */

        /**
         * Constructs a new Unavailability.
         * @memberof mesos
         * @classdesc Represents an interval, from a given start time over a given duration.
         * This interval pertains to an unavailability event, such as maintenance,
         * and is not a generic interval.
         * @constructor
         * @param {mesos.IUnavailability=} [properties] Properties to set
         */
        function Unavailability(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unavailability start.
         * @member {mesos.ITimeInfo}start
         * @memberof mesos.Unavailability
         * @instance
         */
        Unavailability.prototype.start = null;

        /**
         * Unavailability duration.
         * @member {(mesos.IDurationInfo|null|undefined)}duration
         * @memberof mesos.Unavailability
         * @instance
         */
        Unavailability.prototype.duration = null;

        /**
         * Creates a new Unavailability instance using the specified properties.
         * @function create
         * @memberof mesos.Unavailability
         * @static
         * @param {mesos.IUnavailability=} [properties] Properties to set
         * @returns {mesos.Unavailability} Unavailability instance
         */
        Unavailability.create = function create(properties) {
            return new Unavailability(properties);
        };

        /**
         * Encodes the specified Unavailability message. Does not implicitly {@link mesos.Unavailability.verify|verify} messages.
         * @function encode
         * @memberof mesos.Unavailability
         * @static
         * @param {mesos.IUnavailability} message Unavailability message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unavailability.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.TimeInfo.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.duration != null && message.hasOwnProperty("duration"))
                $root.mesos.DurationInfo.encode(message.duration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Unavailability message, length delimited. Does not implicitly {@link mesos.Unavailability.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Unavailability
         * @static
         * @param {mesos.IUnavailability} message Unavailability message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Unavailability.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Unavailability message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Unavailability
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Unavailability} Unavailability
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unavailability.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Unavailability();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.start = $root.mesos.TimeInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.duration = $root.mesos.DurationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("start"))
                throw $util.ProtocolError("missing required 'start'", { instance: message });
            return message;
        };

        /**
         * Decodes an Unavailability message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Unavailability
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Unavailability} Unavailability
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Unavailability.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Unavailability message.
         * @function verify
         * @memberof mesos.Unavailability
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Unavailability.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let error = $root.mesos.TimeInfo.verify(message.start);
            if (error)
                return "start." + error;
            if (message.duration != null && message.hasOwnProperty("duration")) {
                error = $root.mesos.DurationInfo.verify(message.duration);
                if (error)
                    return "duration." + error;
            }
            return null;
        };

        /**
         * Creates an Unavailability message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Unavailability
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Unavailability} Unavailability
         */
        Unavailability.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Unavailability)
                return object;
            let message = new $root.mesos.Unavailability();
            if (object.start != null) {
                if (typeof object.start !== "object")
                    throw TypeError(".mesos.Unavailability.start: object expected");
                message.start = $root.mesos.TimeInfo.fromObject(object.start);
            }
            if (object.duration != null) {
                if (typeof object.duration !== "object")
                    throw TypeError(".mesos.Unavailability.duration: object expected");
                message.duration = $root.mesos.DurationInfo.fromObject(object.duration);
            }
            return message;
        };

        /**
         * Creates a plain object from an Unavailability message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Unavailability
         * @static
         * @param {mesos.Unavailability} message Unavailability
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Unavailability.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.start = null;
                object.duration = null;
            }
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.mesos.TimeInfo.toObject(message.start, options);
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = $root.mesos.DurationInfo.toObject(message.duration, options);
            return object;
        };

        /**
         * Converts this Unavailability to JSON.
         * @function toJSON
         * @memberof mesos.Unavailability
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Unavailability.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Unavailability;
    })();

    mesos.MachineID = (function() {

        /**
         * Properties of a MachineID.
         * @memberof mesos
         * @interface IMachineID
         * @property {string} [hostname] MachineID hostname
         * @property {string} [ip] MachineID ip
         */

        /**
         * Constructs a new MachineID.
         * @memberof mesos
         * @classdesc Represents a single machine, which may hold one or more agents.
         * 
         * NOTE: In order to match an agent to a machine, both the `hostname` and
         * `ip` must match the values advertised by the agent to the master.
         * Hostname is not case-sensitive.
         * @constructor
         * @param {mesos.IMachineID=} [properties] Properties to set
         */
        function MachineID(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MachineID hostname.
         * @member {string}hostname
         * @memberof mesos.MachineID
         * @instance
         */
        MachineID.prototype.hostname = "";

        /**
         * MachineID ip.
         * @member {string}ip
         * @memberof mesos.MachineID
         * @instance
         */
        MachineID.prototype.ip = "";

        /**
         * Creates a new MachineID instance using the specified properties.
         * @function create
         * @memberof mesos.MachineID
         * @static
         * @param {mesos.IMachineID=} [properties] Properties to set
         * @returns {mesos.MachineID} MachineID instance
         */
        MachineID.create = function create(properties) {
            return new MachineID(properties);
        };

        /**
         * Encodes the specified MachineID message. Does not implicitly {@link mesos.MachineID.verify|verify} messages.
         * @function encode
         * @memberof mesos.MachineID
         * @static
         * @param {mesos.IMachineID} message MachineID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.ip != null && message.hasOwnProperty("ip"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ip);
            return writer;
        };

        /**
         * Encodes the specified MachineID message, length delimited. Does not implicitly {@link mesos.MachineID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.MachineID
         * @static
         * @param {mesos.IMachineID} message MachineID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MachineID message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.MachineID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.MachineID} MachineID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.MachineID();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 2:
                    message.ip = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MachineID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.MachineID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.MachineID} MachineID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MachineID message.
         * @function verify
         * @memberof mesos.MachineID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MachineID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            return null;
        };

        /**
         * Creates a MachineID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.MachineID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.MachineID} MachineID
         */
        MachineID.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.MachineID)
                return object;
            let message = new $root.mesos.MachineID();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.ip != null)
                message.ip = String(object.ip);
            return message;
        };

        /**
         * Creates a plain object from a MachineID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.MachineID
         * @static
         * @param {mesos.MachineID} message MachineID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MachineID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.hostname = "";
                object.ip = "";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            return object;
        };

        /**
         * Converts this MachineID to JSON.
         * @function toJSON
         * @memberof mesos.MachineID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MachineID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MachineID;
    })();

    mesos.MachineInfo = (function() {

        /**
         * Properties of a MachineInfo.
         * @memberof mesos
         * @interface IMachineInfo
         * @property {mesos.IMachineID} id MachineInfo id
         * @property {mesos.MachineInfo.Mode} [mode] MachineInfo mode
         * @property {mesos.IUnavailability} [unavailability] MachineInfo unavailability
         */

        /**
         * Constructs a new MachineInfo.
         * @memberof mesos
         * @classdesc Holds information about a single machine, its `mode`, and any other
         * relevant information which may affect the behavior of the machine.
         * @constructor
         * @param {mesos.IMachineInfo=} [properties] Properties to set
         */
        function MachineInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MachineInfo id.
         * @member {mesos.IMachineID}id
         * @memberof mesos.MachineInfo
         * @instance
         */
        MachineInfo.prototype.id = null;

        /**
         * MachineInfo mode.
         * @member {mesos.MachineInfo.Mode}mode
         * @memberof mesos.MachineInfo
         * @instance
         */
        MachineInfo.prototype.mode = 1;

        /**
         * MachineInfo unavailability.
         * @member {(mesos.IUnavailability|null|undefined)}unavailability
         * @memberof mesos.MachineInfo
         * @instance
         */
        MachineInfo.prototype.unavailability = null;

        /**
         * Creates a new MachineInfo instance using the specified properties.
         * @function create
         * @memberof mesos.MachineInfo
         * @static
         * @param {mesos.IMachineInfo=} [properties] Properties to set
         * @returns {mesos.MachineInfo} MachineInfo instance
         */
        MachineInfo.create = function create(properties) {
            return new MachineInfo(properties);
        };

        /**
         * Encodes the specified MachineInfo message. Does not implicitly {@link mesos.MachineInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.MachineInfo
         * @static
         * @param {mesos.IMachineInfo} message MachineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.MachineID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mode != null && message.hasOwnProperty("mode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
            if (message.unavailability != null && message.hasOwnProperty("unavailability"))
                $root.mesos.Unavailability.encode(message.unavailability, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MachineInfo message, length delimited. Does not implicitly {@link mesos.MachineInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.MachineInfo
         * @static
         * @param {mesos.IMachineInfo} message MachineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MachineInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MachineInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.MachineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.MachineInfo} MachineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.MachineInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.mesos.MachineID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                case 3:
                    message.unavailability = $root.mesos.Unavailability.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a MachineInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.MachineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.MachineInfo} MachineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MachineInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MachineInfo message.
         * @function verify
         * @memberof mesos.MachineInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MachineInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let error = $root.mesos.MachineID.verify(message.id);
            if (error)
                return "id." + error;
            if (message.mode != null && message.hasOwnProperty("mode"))
                switch (message.mode) {
                default:
                    return "mode: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.unavailability != null && message.hasOwnProperty("unavailability")) {
                error = $root.mesos.Unavailability.verify(message.unavailability);
                if (error)
                    return "unavailability." + error;
            }
            return null;
        };

        /**
         * Creates a MachineInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.MachineInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.MachineInfo} MachineInfo
         */
        MachineInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.MachineInfo)
                return object;
            let message = new $root.mesos.MachineInfo();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".mesos.MachineInfo.id: object expected");
                message.id = $root.mesos.MachineID.fromObject(object.id);
            }
            switch (object.mode) {
            case "UP":
            case 1:
                message.mode = 1;
                break;
            case "DRAINING":
            case 2:
                message.mode = 2;
                break;
            case "DOWN":
            case 3:
                message.mode = 3;
                break;
            }
            if (object.unavailability != null) {
                if (typeof object.unavailability !== "object")
                    throw TypeError(".mesos.MachineInfo.unavailability: object expected");
                message.unavailability = $root.mesos.Unavailability.fromObject(object.unavailability);
            }
            return message;
        };

        /**
         * Creates a plain object from a MachineInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.MachineInfo
         * @static
         * @param {mesos.MachineInfo} message MachineInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MachineInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = null;
                object.mode = options.enums === String ? "UP" : 1;
                object.unavailability = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.mesos.MachineID.toObject(message.id, options);
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.mesos.MachineInfo.Mode[message.mode] : message.mode;
            if (message.unavailability != null && message.hasOwnProperty("unavailability"))
                object.unavailability = $root.mesos.Unavailability.toObject(message.unavailability, options);
            return object;
        };

        /**
         * Converts this MachineInfo to JSON.
         * @function toJSON
         * @memberof mesos.MachineInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MachineInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Mode enum.
         * @enum {string}
         * @property {number} UP=1 UP value
         * @property {number} DRAINING=2 DRAINING value
         * @property {number} DOWN=3 DOWN value
         */
        MachineInfo.Mode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "UP"] = 1;
            values[valuesById[2] = "DRAINING"] = 2;
            values[valuesById[3] = "DOWN"] = 3;
            return values;
        })();

        return MachineInfo;
    })();

    mesos.FrameworkInfo = (function() {

        /**
         * Properties of a FrameworkInfo.
         * @memberof mesos
         * @interface IFrameworkInfo
         * @property {string} user FrameworkInfo user
         * @property {string} name FrameworkInfo name
         * @property {mesos.IFrameworkID} [id] FrameworkInfo id
         * @property {number} [failoverTimeout] FrameworkInfo failoverTimeout
         * @property {boolean} [checkpoint] FrameworkInfo checkpoint
         * @property {string} [role] FrameworkInfo role
         * @property {Array.<string>} [roles] FrameworkInfo roles
         * @property {string} [hostname] FrameworkInfo hostname
         * @property {string} [principal] FrameworkInfo principal
         * @property {string} [webuiUrl] FrameworkInfo webuiUrl
         * @property {Array.<mesos.FrameworkInfo.ICapability>} [capabilities] FrameworkInfo capabilities
         * @property {mesos.ILabels} [labels] FrameworkInfo labels
         */

        /**
         * Constructs a new FrameworkInfo.
         * @memberof mesos
         * @classdesc Describes a framework.
         * @constructor
         * @param {mesos.IFrameworkInfo=} [properties] Properties to set
         */
        function FrameworkInfo(properties) {
            this.roles = [];
            this.capabilities = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FrameworkInfo user.
         * @member {string}user
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.user = "";

        /**
         * FrameworkInfo name.
         * @member {string}name
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.name = "";

        /**
         * FrameworkInfo id.
         * @member {(mesos.IFrameworkID|null|undefined)}id
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.id = null;

        /**
         * FrameworkInfo failoverTimeout.
         * @member {number}failoverTimeout
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.failoverTimeout = 0;

        /**
         * FrameworkInfo checkpoint.
         * @member {boolean}checkpoint
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.checkpoint = false;

        /**
         * FrameworkInfo role.
         * @member {string}role
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.role = "*";

        /**
         * FrameworkInfo roles.
         * @member {Array.<string>}roles
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.roles = $util.emptyArray;

        /**
         * FrameworkInfo hostname.
         * @member {string}hostname
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.hostname = "";

        /**
         * FrameworkInfo principal.
         * @member {string}principal
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.principal = "";

        /**
         * FrameworkInfo webuiUrl.
         * @member {string}webuiUrl
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.webuiUrl = "";

        /**
         * FrameworkInfo capabilities.
         * @member {Array.<mesos.FrameworkInfo.ICapability>}capabilities
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.capabilities = $util.emptyArray;

        /**
         * FrameworkInfo labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.FrameworkInfo
         * @instance
         */
        FrameworkInfo.prototype.labels = null;

        /**
         * Creates a new FrameworkInfo instance using the specified properties.
         * @function create
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {mesos.IFrameworkInfo=} [properties] Properties to set
         * @returns {mesos.FrameworkInfo} FrameworkInfo instance
         */
        FrameworkInfo.create = function create(properties) {
            return new FrameworkInfo(properties);
        };

        /**
         * Encodes the specified FrameworkInfo message. Does not implicitly {@link mesos.FrameworkInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {mesos.IFrameworkInfo} message FrameworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrameworkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.id != null && message.hasOwnProperty("id"))
                $root.mesos.FrameworkID.encode(message.id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.failoverTimeout != null && message.hasOwnProperty("failoverTimeout"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.failoverTimeout);
            if (message.checkpoint != null && message.hasOwnProperty("checkpoint"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.checkpoint);
            if (message.role != null && message.hasOwnProperty("role"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.role);
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.hostname);
            if (message.principal != null && message.hasOwnProperty("principal"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.principal);
            if (message.webuiUrl != null && message.hasOwnProperty("webuiUrl"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.webuiUrl);
            if (message.capabilities != null && message.capabilities.length)
                for (let i = 0; i < message.capabilities.length; ++i)
                    $root.mesos.FrameworkInfo.Capability.encode(message.capabilities[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.roles != null && message.roles.length)
                for (let i = 0; i < message.roles.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.roles[i]);
            return writer;
        };

        /**
         * Encodes the specified FrameworkInfo message, length delimited. Does not implicitly {@link mesos.FrameworkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {mesos.IFrameworkInfo} message FrameworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FrameworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FrameworkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.FrameworkInfo} FrameworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrameworkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.FrameworkInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.id = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.failoverTimeout = reader.double();
                    break;
                case 5:
                    message.checkpoint = reader.bool();
                    break;
                case 6:
                    message.role = reader.string();
                    break;
                case 12:
                    if (!(message.roles && message.roles.length))
                        message.roles = [];
                    message.roles.push(reader.string());
                    break;
                case 7:
                    message.hostname = reader.string();
                    break;
                case 8:
                    message.principal = reader.string();
                    break;
                case 9:
                    message.webuiUrl = reader.string();
                    break;
                case 10:
                    if (!(message.capabilities && message.capabilities.length))
                        message.capabilities = [];
                    message.capabilities.push($root.mesos.FrameworkInfo.Capability.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("user"))
                throw $util.ProtocolError("missing required 'user'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a FrameworkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.FrameworkInfo} FrameworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FrameworkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FrameworkInfo message.
         * @function verify
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FrameworkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.user))
                return "user: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.mesos.FrameworkID.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.failoverTimeout != null && message.hasOwnProperty("failoverTimeout"))
                if (typeof message.failoverTimeout !== "number")
                    return "failoverTimeout: number expected";
            if (message.checkpoint != null && message.hasOwnProperty("checkpoint"))
                if (typeof message.checkpoint !== "boolean")
                    return "checkpoint: boolean expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (let i = 0; i < message.roles.length; ++i)
                    if (!$util.isString(message.roles[i]))
                        return "roles: string[] expected";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.principal != null && message.hasOwnProperty("principal"))
                if (!$util.isString(message.principal))
                    return "principal: string expected";
            if (message.webuiUrl != null && message.hasOwnProperty("webuiUrl"))
                if (!$util.isString(message.webuiUrl))
                    return "webuiUrl: string expected";
            if (message.capabilities != null && message.hasOwnProperty("capabilities")) {
                if (!Array.isArray(message.capabilities))
                    return "capabilities: array expected";
                for (let i = 0; i < message.capabilities.length; ++i) {
                    error = $root.mesos.FrameworkInfo.Capability.verify(message.capabilities[i]);
                    if (error)
                        return "capabilities." + error;
                }
            }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            return null;
        };

        /**
         * Creates a FrameworkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.FrameworkInfo} FrameworkInfo
         */
        FrameworkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.FrameworkInfo)
                return object;
            let message = new $root.mesos.FrameworkInfo();
            if (object.user != null)
                message.user = String(object.user);
            if (object.name != null)
                message.name = String(object.name);
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".mesos.FrameworkInfo.id: object expected");
                message.id = $root.mesos.FrameworkID.fromObject(object.id);
            }
            if (object.failoverTimeout != null)
                message.failoverTimeout = Number(object.failoverTimeout);
            if (object.checkpoint != null)
                message.checkpoint = Boolean(object.checkpoint);
            if (object.role != null)
                message.role = String(object.role);
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".mesos.FrameworkInfo.roles: array expected");
                message.roles = [];
                for (let i = 0; i < object.roles.length; ++i)
                    message.roles[i] = String(object.roles[i]);
            }
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.principal != null)
                message.principal = String(object.principal);
            if (object.webuiUrl != null)
                message.webuiUrl = String(object.webuiUrl);
            if (object.capabilities) {
                if (!Array.isArray(object.capabilities))
                    throw TypeError(".mesos.FrameworkInfo.capabilities: array expected");
                message.capabilities = [];
                for (let i = 0; i < object.capabilities.length; ++i) {
                    if (typeof object.capabilities[i] !== "object")
                        throw TypeError(".mesos.FrameworkInfo.capabilities: object expected");
                    message.capabilities[i] = $root.mesos.FrameworkInfo.Capability.fromObject(object.capabilities[i]);
                }
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.FrameworkInfo.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            return message;
        };

        /**
         * Creates a plain object from a FrameworkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.FrameworkInfo
         * @static
         * @param {mesos.FrameworkInfo} message FrameworkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FrameworkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.capabilities = [];
                object.roles = [];
            }
            if (options.defaults) {
                object.user = "";
                object.name = "";
                object.id = null;
                object.failoverTimeout = 0;
                object.checkpoint = false;
                object.role = "*";
                object.hostname = "";
                object.principal = "";
                object.webuiUrl = "";
                object.labels = null;
            }
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.mesos.FrameworkID.toObject(message.id, options);
            if (message.failoverTimeout != null && message.hasOwnProperty("failoverTimeout"))
                object.failoverTimeout = options.json && !isFinite(message.failoverTimeout) ? String(message.failoverTimeout) : message.failoverTimeout;
            if (message.checkpoint != null && message.hasOwnProperty("checkpoint"))
                object.checkpoint = message.checkpoint;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.principal != null && message.hasOwnProperty("principal"))
                object.principal = message.principal;
            if (message.webuiUrl != null && message.hasOwnProperty("webuiUrl"))
                object.webuiUrl = message.webuiUrl;
            if (message.capabilities && message.capabilities.length) {
                object.capabilities = [];
                for (let j = 0; j < message.capabilities.length; ++j)
                    object.capabilities[j] = $root.mesos.FrameworkInfo.Capability.toObject(message.capabilities[j], options);
            }
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (let j = 0; j < message.roles.length; ++j)
                    object.roles[j] = message.roles[j];
            }
            return object;
        };

        /**
         * Converts this FrameworkInfo to JSON.
         * @function toJSON
         * @memberof mesos.FrameworkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FrameworkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        FrameworkInfo.Capability = (function() {

            /**
             * Properties of a Capability.
             * @memberof mesos.FrameworkInfo
             * @interface ICapability
             * @property {mesos.FrameworkInfo.Capability.Type} [type] Capability type
             */

            /**
             * Constructs a new Capability.
             * @memberof mesos.FrameworkInfo
             * @classdesc Represents a Capability.
             * @constructor
             * @param {mesos.FrameworkInfo.ICapability=} [properties] Properties to set
             */
            function Capability(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Capability type.
             * @member {mesos.FrameworkInfo.Capability.Type}type
             * @memberof mesos.FrameworkInfo.Capability
             * @instance
             */
            Capability.prototype.type = 0;

            /**
             * Creates a new Capability instance using the specified properties.
             * @function create
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {mesos.FrameworkInfo.ICapability=} [properties] Properties to set
             * @returns {mesos.FrameworkInfo.Capability} Capability instance
             */
            Capability.create = function create(properties) {
                return new Capability(properties);
            };

            /**
             * Encodes the specified Capability message. Does not implicitly {@link mesos.FrameworkInfo.Capability.verify|verify} messages.
             * @function encode
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {mesos.FrameworkInfo.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified Capability message, length delimited. Does not implicitly {@link mesos.FrameworkInfo.Capability.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {mesos.FrameworkInfo.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Capability message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.FrameworkInfo.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.FrameworkInfo.Capability();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Capability message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.FrameworkInfo.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Capability message.
             * @function verify
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capability.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Capability message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.FrameworkInfo.Capability} Capability
             */
            Capability.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.FrameworkInfo.Capability)
                    return object;
                let message = new $root.mesos.FrameworkInfo.Capability();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "REVOCABLE_RESOURCES":
                case 1:
                    message.type = 1;
                    break;
                case "TASK_KILLING_STATE":
                case 2:
                    message.type = 2;
                    break;
                case "GPU_RESOURCES":
                case 3:
                    message.type = 3;
                    break;
                case "SHARED_RESOURCES":
                case 4:
                    message.type = 4;
                    break;
                case "PARTITION_AWARE":
                case 5:
                    message.type = 5;
                    break;
                case "MULTI_ROLE":
                case 6:
                    message.type = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Capability message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.FrameworkInfo.Capability
             * @static
             * @param {mesos.FrameworkInfo.Capability} message Capability
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capability.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.FrameworkInfo.Capability.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Capability to JSON.
             * @function toJSON
             * @memberof mesos.FrameworkInfo.Capability
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capability.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} REVOCABLE_RESOURCES=1 REVOCABLE_RESOURCES value
             * @property {number} TASK_KILLING_STATE=2 TASK_KILLING_STATE value
             * @property {number} GPU_RESOURCES=3 GPU_RESOURCES value
             * @property {number} SHARED_RESOURCES=4 SHARED_RESOURCES value
             * @property {number} PARTITION_AWARE=5 PARTITION_AWARE value
             * @property {number} MULTI_ROLE=6 MULTI_ROLE value
             */
            Capability.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "REVOCABLE_RESOURCES"] = 1;
                values[valuesById[2] = "TASK_KILLING_STATE"] = 2;
                values[valuesById[3] = "GPU_RESOURCES"] = 3;
                values[valuesById[4] = "SHARED_RESOURCES"] = 4;
                values[valuesById[5] = "PARTITION_AWARE"] = 5;
                values[valuesById[6] = "MULTI_ROLE"] = 6;
                return values;
            })();

            return Capability;
        })();

        return FrameworkInfo;
    })();

    mesos.CheckInfo = (function() {

        /**
         * Properties of a CheckInfo.
         * @memberof mesos
         * @interface ICheckInfo
         * @property {mesos.CheckInfo.Type} [type] CheckInfo type
         * @property {mesos.CheckInfo.ICommand} [command] CheckInfo command
         * @property {mesos.CheckInfo.IHttp} [http] CheckInfo http
         * @property {number} [delaySeconds] CheckInfo delaySeconds
         * @property {number} [intervalSeconds] CheckInfo intervalSeconds
         * @property {number} [timeoutSeconds] CheckInfo timeoutSeconds
         */

        /**
         * Constructs a new CheckInfo.
         * @memberof mesos
         * @classdesc Describes a general non-interpreting non-killing check for a task or
         * executor (or any arbitrary process/command). A type is picked by
         * specifying one of the optional fields. Specifying more than one type
         * is an error.
         * 
         * NOTE: This API is unstable and the related feature is experimental.
         * @constructor
         * @param {mesos.ICheckInfo=} [properties] Properties to set
         */
        function CheckInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckInfo type.
         * @member {mesos.CheckInfo.Type}type
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.type = 0;

        /**
         * CheckInfo command.
         * @member {(mesos.CheckInfo.ICommand|null|undefined)}command
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.command = null;

        /**
         * CheckInfo http.
         * @member {(mesos.CheckInfo.IHttp|null|undefined)}http
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.http = null;

        /**
         * CheckInfo delaySeconds.
         * @member {number}delaySeconds
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.delaySeconds = 15;

        /**
         * CheckInfo intervalSeconds.
         * @member {number}intervalSeconds
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.intervalSeconds = 10;

        /**
         * CheckInfo timeoutSeconds.
         * @member {number}timeoutSeconds
         * @memberof mesos.CheckInfo
         * @instance
         */
        CheckInfo.prototype.timeoutSeconds = 20;

        /**
         * Creates a new CheckInfo instance using the specified properties.
         * @function create
         * @memberof mesos.CheckInfo
         * @static
         * @param {mesos.ICheckInfo=} [properties] Properties to set
         * @returns {mesos.CheckInfo} CheckInfo instance
         */
        CheckInfo.create = function create(properties) {
            return new CheckInfo(properties);
        };

        /**
         * Encodes the specified CheckInfo message. Does not implicitly {@link mesos.CheckInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.CheckInfo
         * @static
         * @param {mesos.ICheckInfo} message CheckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.command != null && message.hasOwnProperty("command"))
                $root.mesos.CheckInfo.Command.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.http != null && message.hasOwnProperty("http"))
                $root.mesos.CheckInfo.Http.encode(message.http, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.delaySeconds);
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.intervalSeconds);
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.timeoutSeconds);
            return writer;
        };

        /**
         * Encodes the specified CheckInfo message, length delimited. Does not implicitly {@link mesos.CheckInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.CheckInfo
         * @static
         * @param {mesos.ICheckInfo} message CheckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.CheckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.CheckInfo} CheckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.command = $root.mesos.CheckInfo.Command.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.http = $root.mesos.CheckInfo.Http.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.delaySeconds = reader.double();
                    break;
                case 5:
                    message.intervalSeconds = reader.double();
                    break;
                case 6:
                    message.timeoutSeconds = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.CheckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.CheckInfo} CheckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckInfo message.
         * @function verify
         * @memberof mesos.CheckInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.command != null && message.hasOwnProperty("command")) {
                let error = $root.mesos.CheckInfo.Command.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.http != null && message.hasOwnProperty("http")) {
                error = $root.mesos.CheckInfo.Http.verify(message.http);
                if (error)
                    return "http." + error;
            }
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                if (typeof message.delaySeconds !== "number")
                    return "delaySeconds: number expected";
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                if (typeof message.intervalSeconds !== "number")
                    return "intervalSeconds: number expected";
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                if (typeof message.timeoutSeconds !== "number")
                    return "timeoutSeconds: number expected";
            return null;
        };

        /**
         * Creates a CheckInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.CheckInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.CheckInfo} CheckInfo
         */
        CheckInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.CheckInfo)
                return object;
            let message = new $root.mesos.CheckInfo();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "COMMAND":
            case 1:
                message.type = 1;
                break;
            case "HTTP":
            case 2:
                message.type = 2;
                break;
            }
            if (object.command != null) {
                if (typeof object.command !== "object")
                    throw TypeError(".mesos.CheckInfo.command: object expected");
                message.command = $root.mesos.CheckInfo.Command.fromObject(object.command);
            }
            if (object.http != null) {
                if (typeof object.http !== "object")
                    throw TypeError(".mesos.CheckInfo.http: object expected");
                message.http = $root.mesos.CheckInfo.Http.fromObject(object.http);
            }
            if (object.delaySeconds != null)
                message.delaySeconds = Number(object.delaySeconds);
            if (object.intervalSeconds != null)
                message.intervalSeconds = Number(object.intervalSeconds);
            if (object.timeoutSeconds != null)
                message.timeoutSeconds = Number(object.timeoutSeconds);
            return message;
        };

        /**
         * Creates a plain object from a CheckInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.CheckInfo
         * @static
         * @param {mesos.CheckInfo} message CheckInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.command = null;
                object.http = null;
                object.delaySeconds = 15;
                object.intervalSeconds = 10;
                object.timeoutSeconds = 20;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.CheckInfo.Type[message.type] : message.type;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = $root.mesos.CheckInfo.Command.toObject(message.command, options);
            if (message.http != null && message.hasOwnProperty("http"))
                object.http = $root.mesos.CheckInfo.Http.toObject(message.http, options);
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                object.delaySeconds = options.json && !isFinite(message.delaySeconds) ? String(message.delaySeconds) : message.delaySeconds;
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                object.intervalSeconds = options.json && !isFinite(message.intervalSeconds) ? String(message.intervalSeconds) : message.intervalSeconds;
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                object.timeoutSeconds = options.json && !isFinite(message.timeoutSeconds) ? String(message.timeoutSeconds) : message.timeoutSeconds;
            return object;
        };

        /**
         * Converts this CheckInfo to JSON.
         * @function toJSON
         * @memberof mesos.CheckInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} COMMAND=1 COMMAND value
         * @property {number} HTTP=2 HTTP value
         */
        CheckInfo.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "COMMAND"] = 1;
            values[valuesById[2] = "HTTP"] = 2;
            return values;
        })();

        CheckInfo.Command = (function() {

            /**
             * Properties of a Command.
             * @memberof mesos.CheckInfo
             * @interface ICommand
             * @property {mesos.ICommandInfo} command Command command
             */

            /**
             * Constructs a new Command.
             * @memberof mesos.CheckInfo
             * @classdesc Represents a Command.
             * @constructor
             * @param {mesos.CheckInfo.ICommand=} [properties] Properties to set
             */
            function Command(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Command command.
             * @member {mesos.ICommandInfo}command
             * @memberof mesos.CheckInfo.Command
             * @instance
             */
            Command.prototype.command = null;

            /**
             * Creates a new Command instance using the specified properties.
             * @function create
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {mesos.CheckInfo.ICommand=} [properties] Properties to set
             * @returns {mesos.CheckInfo.Command} Command instance
             */
            Command.create = function create(properties) {
                return new Command(properties);
            };

            /**
             * Encodes the specified Command message. Does not implicitly {@link mesos.CheckInfo.Command.verify|verify} messages.
             * @function encode
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {mesos.CheckInfo.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.mesos.CommandInfo.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Command message, length delimited. Does not implicitly {@link mesos.CheckInfo.Command.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {mesos.CheckInfo.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Command message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CheckInfo.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckInfo.Command();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.mesos.CommandInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("command"))
                    throw $util.ProtocolError("missing required 'command'", { instance: message });
                return message;
            };

            /**
             * Decodes a Command message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CheckInfo.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Command message.
             * @function verify
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Command.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let error = $root.mesos.CommandInfo.verify(message.command);
                if (error)
                    return "command." + error;
                return null;
            };

            /**
             * Creates a Command message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CheckInfo.Command} Command
             */
            Command.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CheckInfo.Command)
                    return object;
                let message = new $root.mesos.CheckInfo.Command();
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".mesos.CheckInfo.Command.command: object expected");
                    message.command = $root.mesos.CommandInfo.fromObject(object.command);
                }
                return message;
            };

            /**
             * Creates a plain object from a Command message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CheckInfo.Command
             * @static
             * @param {mesos.CheckInfo.Command} message Command
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Command.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.command = null;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.mesos.CommandInfo.toObject(message.command, options);
                return object;
            };

            /**
             * Converts this Command to JSON.
             * @function toJSON
             * @memberof mesos.CheckInfo.Command
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Command.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Command;
        })();

        CheckInfo.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof mesos.CheckInfo
             * @interface IHttp
             * @property {number} port Http port
             * @property {string} [path] Http path
             */

            /**
             * Constructs a new Http.
             * @memberof mesos.CheckInfo
             * @classdesc Represents a Http.
             * @constructor
             * @param {mesos.CheckInfo.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http port.
             * @member {number}port
             * @memberof mesos.CheckInfo.Http
             * @instance
             */
            Http.prototype.port = 0;

            /**
             * Http path.
             * @member {string}path
             * @memberof mesos.CheckInfo.Http
             * @instance
             */
            Http.prototype.path = "";

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {mesos.CheckInfo.IHttp=} [properties] Properties to set
             * @returns {mesos.CheckInfo.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link mesos.CheckInfo.Http.verify|verify} messages.
             * @function encode
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {mesos.CheckInfo.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.port);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link mesos.CheckInfo.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {mesos.CheckInfo.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CheckInfo.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckInfo.Http();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.port = reader.uint32();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("port"))
                    throw $util.ProtocolError("missing required 'port'", { instance: message });
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CheckInfo.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CheckInfo.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CheckInfo.Http)
                    return object;
                let message = new $root.mesos.CheckInfo.Http();
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CheckInfo.Http
             * @static
             * @param {mesos.CheckInfo.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.port = 0;
                    object.path = "";
                }
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof mesos.CheckInfo.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        return CheckInfo;
    })();

    mesos.HealthCheck = (function() {

        /**
         * Properties of a HealthCheck.
         * @memberof mesos
         * @interface IHealthCheck
         * @property {number} [delaySeconds] HealthCheck delaySeconds
         * @property {number} [intervalSeconds] HealthCheck intervalSeconds
         * @property {number} [timeoutSeconds] HealthCheck timeoutSeconds
         * @property {number} [consecutiveFailures] HealthCheck consecutiveFailures
         * @property {number} [gracePeriodSeconds] HealthCheck gracePeriodSeconds
         * @property {mesos.HealthCheck.Type} [type] HealthCheck type
         * @property {mesos.ICommandInfo} [command] HealthCheck command
         * @property {mesos.HealthCheck.IHTTPCheckInfo} [http] HealthCheck http
         * @property {mesos.HealthCheck.ITCPCheckInfo} [tcp] HealthCheck tcp
         */

        /**
         * Constructs a new HealthCheck.
         * @memberof mesos
         * @classdesc Describes a health check for a task or executor (or any arbitrary
         * process/command). A type is picked by specifying one of the
         * optional fields. Specifying more than one type is an error.
         * @constructor
         * @param {mesos.IHealthCheck=} [properties] Properties to set
         */
        function HealthCheck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HealthCheck delaySeconds.
         * @member {number}delaySeconds
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.delaySeconds = 15;

        /**
         * HealthCheck intervalSeconds.
         * @member {number}intervalSeconds
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.intervalSeconds = 10;

        /**
         * HealthCheck timeoutSeconds.
         * @member {number}timeoutSeconds
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.timeoutSeconds = 20;

        /**
         * HealthCheck consecutiveFailures.
         * @member {number}consecutiveFailures
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.consecutiveFailures = 3;

        /**
         * HealthCheck gracePeriodSeconds.
         * @member {number}gracePeriodSeconds
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.gracePeriodSeconds = 10;

        /**
         * HealthCheck type.
         * @member {mesos.HealthCheck.Type}type
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.type = 0;

        /**
         * HealthCheck command.
         * @member {(mesos.ICommandInfo|null|undefined)}command
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.command = null;

        /**
         * HealthCheck http.
         * @member {(mesos.HealthCheck.IHTTPCheckInfo|null|undefined)}http
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.http = null;

        /**
         * HealthCheck tcp.
         * @member {(mesos.HealthCheck.ITCPCheckInfo|null|undefined)}tcp
         * @memberof mesos.HealthCheck
         * @instance
         */
        HealthCheck.prototype.tcp = null;

        /**
         * Creates a new HealthCheck instance using the specified properties.
         * @function create
         * @memberof mesos.HealthCheck
         * @static
         * @param {mesos.IHealthCheck=} [properties] Properties to set
         * @returns {mesos.HealthCheck} HealthCheck instance
         */
        HealthCheck.create = function create(properties) {
            return new HealthCheck(properties);
        };

        /**
         * Encodes the specified HealthCheck message. Does not implicitly {@link mesos.HealthCheck.verify|verify} messages.
         * @function encode
         * @memberof mesos.HealthCheck
         * @static
         * @param {mesos.IHealthCheck} message HealthCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HealthCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.http != null && message.hasOwnProperty("http"))
                $root.mesos.HealthCheck.HTTPCheckInfo.encode(message.http, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.delaySeconds);
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.intervalSeconds);
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.timeoutSeconds);
            if (message.consecutiveFailures != null && message.hasOwnProperty("consecutiveFailures"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.consecutiveFailures);
            if (message.gracePeriodSeconds != null && message.hasOwnProperty("gracePeriodSeconds"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.gracePeriodSeconds);
            if (message.command != null && message.hasOwnProperty("command"))
                $root.mesos.CommandInfo.encode(message.command, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            if (message.tcp != null && message.hasOwnProperty("tcp"))
                $root.mesos.HealthCheck.TCPCheckInfo.encode(message.tcp, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HealthCheck message, length delimited. Does not implicitly {@link mesos.HealthCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.HealthCheck
         * @static
         * @param {mesos.IHealthCheck} message HealthCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HealthCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HealthCheck message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.HealthCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.HealthCheck} HealthCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HealthCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.HealthCheck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.delaySeconds = reader.double();
                    break;
                case 3:
                    message.intervalSeconds = reader.double();
                    break;
                case 4:
                    message.timeoutSeconds = reader.double();
                    break;
                case 5:
                    message.consecutiveFailures = reader.uint32();
                    break;
                case 6:
                    message.gracePeriodSeconds = reader.double();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.command = $root.mesos.CommandInfo.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.http = $root.mesos.HealthCheck.HTTPCheckInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.tcp = $root.mesos.HealthCheck.TCPCheckInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HealthCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.HealthCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.HealthCheck} HealthCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HealthCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HealthCheck message.
         * @function verify
         * @memberof mesos.HealthCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HealthCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                if (typeof message.delaySeconds !== "number")
                    return "delaySeconds: number expected";
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                if (typeof message.intervalSeconds !== "number")
                    return "intervalSeconds: number expected";
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                if (typeof message.timeoutSeconds !== "number")
                    return "timeoutSeconds: number expected";
            if (message.consecutiveFailures != null && message.hasOwnProperty("consecutiveFailures"))
                if (!$util.isInteger(message.consecutiveFailures))
                    return "consecutiveFailures: integer expected";
            if (message.gracePeriodSeconds != null && message.hasOwnProperty("gracePeriodSeconds"))
                if (typeof message.gracePeriodSeconds !== "number")
                    return "gracePeriodSeconds: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.command != null && message.hasOwnProperty("command")) {
                let error = $root.mesos.CommandInfo.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.http != null && message.hasOwnProperty("http")) {
                error = $root.mesos.HealthCheck.HTTPCheckInfo.verify(message.http);
                if (error)
                    return "http." + error;
            }
            if (message.tcp != null && message.hasOwnProperty("tcp")) {
                error = $root.mesos.HealthCheck.TCPCheckInfo.verify(message.tcp);
                if (error)
                    return "tcp." + error;
            }
            return null;
        };

        /**
         * Creates a HealthCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.HealthCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.HealthCheck} HealthCheck
         */
        HealthCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.HealthCheck)
                return object;
            let message = new $root.mesos.HealthCheck();
            if (object.delaySeconds != null)
                message.delaySeconds = Number(object.delaySeconds);
            if (object.intervalSeconds != null)
                message.intervalSeconds = Number(object.intervalSeconds);
            if (object.timeoutSeconds != null)
                message.timeoutSeconds = Number(object.timeoutSeconds);
            if (object.consecutiveFailures != null)
                message.consecutiveFailures = object.consecutiveFailures >>> 0;
            if (object.gracePeriodSeconds != null)
                message.gracePeriodSeconds = Number(object.gracePeriodSeconds);
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "COMMAND":
            case 1:
                message.type = 1;
                break;
            case "HTTP":
            case 2:
                message.type = 2;
                break;
            case "TCP":
            case 3:
                message.type = 3;
                break;
            }
            if (object.command != null) {
                if (typeof object.command !== "object")
                    throw TypeError(".mesos.HealthCheck.command: object expected");
                message.command = $root.mesos.CommandInfo.fromObject(object.command);
            }
            if (object.http != null) {
                if (typeof object.http !== "object")
                    throw TypeError(".mesos.HealthCheck.http: object expected");
                message.http = $root.mesos.HealthCheck.HTTPCheckInfo.fromObject(object.http);
            }
            if (object.tcp != null) {
                if (typeof object.tcp !== "object")
                    throw TypeError(".mesos.HealthCheck.tcp: object expected");
                message.tcp = $root.mesos.HealthCheck.TCPCheckInfo.fromObject(object.tcp);
            }
            return message;
        };

        /**
         * Creates a plain object from a HealthCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.HealthCheck
         * @static
         * @param {mesos.HealthCheck} message HealthCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HealthCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.http = null;
                object.delaySeconds = 15;
                object.intervalSeconds = 10;
                object.timeoutSeconds = 20;
                object.consecutiveFailures = 3;
                object.gracePeriodSeconds = 10;
                object.command = null;
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.tcp = null;
            }
            if (message.http != null && message.hasOwnProperty("http"))
                object.http = $root.mesos.HealthCheck.HTTPCheckInfo.toObject(message.http, options);
            if (message.delaySeconds != null && message.hasOwnProperty("delaySeconds"))
                object.delaySeconds = options.json && !isFinite(message.delaySeconds) ? String(message.delaySeconds) : message.delaySeconds;
            if (message.intervalSeconds != null && message.hasOwnProperty("intervalSeconds"))
                object.intervalSeconds = options.json && !isFinite(message.intervalSeconds) ? String(message.intervalSeconds) : message.intervalSeconds;
            if (message.timeoutSeconds != null && message.hasOwnProperty("timeoutSeconds"))
                object.timeoutSeconds = options.json && !isFinite(message.timeoutSeconds) ? String(message.timeoutSeconds) : message.timeoutSeconds;
            if (message.consecutiveFailures != null && message.hasOwnProperty("consecutiveFailures"))
                object.consecutiveFailures = message.consecutiveFailures;
            if (message.gracePeriodSeconds != null && message.hasOwnProperty("gracePeriodSeconds"))
                object.gracePeriodSeconds = options.json && !isFinite(message.gracePeriodSeconds) ? String(message.gracePeriodSeconds) : message.gracePeriodSeconds;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = $root.mesos.CommandInfo.toObject(message.command, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.HealthCheck.Type[message.type] : message.type;
            if (message.tcp != null && message.hasOwnProperty("tcp"))
                object.tcp = $root.mesos.HealthCheck.TCPCheckInfo.toObject(message.tcp, options);
            return object;
        };

        /**
         * Converts this HealthCheck to JSON.
         * @function toJSON
         * @memberof mesos.HealthCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HealthCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} COMMAND=1 COMMAND value
         * @property {number} HTTP=2 HTTP value
         * @property {number} TCP=3 TCP value
         */
        HealthCheck.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "COMMAND"] = 1;
            values[valuesById[2] = "HTTP"] = 2;
            values[valuesById[3] = "TCP"] = 3;
            return values;
        })();

        HealthCheck.HTTPCheckInfo = (function() {

            /**
             * Properties of a HTTPCheckInfo.
             * @memberof mesos.HealthCheck
             * @interface IHTTPCheckInfo
             * @property {string} [scheme] HTTPCheckInfo scheme
             * @property {number} port HTTPCheckInfo port
             * @property {string} [path] HTTPCheckInfo path
             * @property {Array.<number>} [statuses] HTTPCheckInfo statuses
             */

            /**
             * Constructs a new HTTPCheckInfo.
             * @memberof mesos.HealthCheck
             * @classdesc Represents a HTTPCheckInfo.
             * @constructor
             * @param {mesos.HealthCheck.IHTTPCheckInfo=} [properties] Properties to set
             */
            function HTTPCheckInfo(properties) {
                this.statuses = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HTTPCheckInfo scheme.
             * @member {string}scheme
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @instance
             */
            HTTPCheckInfo.prototype.scheme = "";

            /**
             * HTTPCheckInfo port.
             * @member {number}port
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @instance
             */
            HTTPCheckInfo.prototype.port = 0;

            /**
             * HTTPCheckInfo path.
             * @member {string}path
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @instance
             */
            HTTPCheckInfo.prototype.path = "";

            /**
             * HTTPCheckInfo statuses.
             * @member {Array.<number>}statuses
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @instance
             */
            HTTPCheckInfo.prototype.statuses = $util.emptyArray;

            /**
             * Creates a new HTTPCheckInfo instance using the specified properties.
             * @function create
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {mesos.HealthCheck.IHTTPCheckInfo=} [properties] Properties to set
             * @returns {mesos.HealthCheck.HTTPCheckInfo} HTTPCheckInfo instance
             */
            HTTPCheckInfo.create = function create(properties) {
                return new HTTPCheckInfo(properties);
            };

            /**
             * Encodes the specified HTTPCheckInfo message. Does not implicitly {@link mesos.HealthCheck.HTTPCheckInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {mesos.HealthCheck.IHTTPCheckInfo} message HTTPCheckInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPCheckInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.port);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.scheme);
                if (message.statuses != null && message.statuses.length)
                    for (let i = 0; i < message.statuses.length; ++i)
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.statuses[i]);
                return writer;
            };

            /**
             * Encodes the specified HTTPCheckInfo message, length delimited. Does not implicitly {@link mesos.HealthCheck.HTTPCheckInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {mesos.HealthCheck.IHTTPCheckInfo} message HTTPCheckInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HTTPCheckInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HTTPCheckInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.HealthCheck.HTTPCheckInfo} HTTPCheckInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPCheckInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.HealthCheck.HTTPCheckInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        message.scheme = reader.string();
                        break;
                    case 1:
                        message.port = reader.uint32();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 4:
                        if (!(message.statuses && message.statuses.length))
                            message.statuses = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.statuses.push(reader.uint32());
                        } else
                            message.statuses.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("port"))
                    throw $util.ProtocolError("missing required 'port'", { instance: message });
                return message;
            };

            /**
             * Decodes a HTTPCheckInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.HealthCheck.HTTPCheckInfo} HTTPCheckInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HTTPCheckInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HTTPCheckInfo message.
             * @function verify
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HTTPCheckInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    if (!$util.isString(message.scheme))
                        return "scheme: string expected";
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.statuses != null && message.hasOwnProperty("statuses")) {
                    if (!Array.isArray(message.statuses))
                        return "statuses: array expected";
                    for (let i = 0; i < message.statuses.length; ++i)
                        if (!$util.isInteger(message.statuses[i]))
                            return "statuses: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a HTTPCheckInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.HealthCheck.HTTPCheckInfo} HTTPCheckInfo
             */
            HTTPCheckInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.HealthCheck.HTTPCheckInfo)
                    return object;
                let message = new $root.mesos.HealthCheck.HTTPCheckInfo();
                if (object.scheme != null)
                    message.scheme = String(object.scheme);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.path != null)
                    message.path = String(object.path);
                if (object.statuses) {
                    if (!Array.isArray(object.statuses))
                        throw TypeError(".mesos.HealthCheck.HTTPCheckInfo.statuses: array expected");
                    message.statuses = [];
                    for (let i = 0; i < object.statuses.length; ++i)
                        message.statuses[i] = object.statuses[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a HTTPCheckInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @static
             * @param {mesos.HealthCheck.HTTPCheckInfo} message HTTPCheckInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HTTPCheckInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.statuses = [];
                if (options.defaults) {
                    object.port = 0;
                    object.path = "";
                    object.scheme = "";
                }
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.scheme != null && message.hasOwnProperty("scheme"))
                    object.scheme = message.scheme;
                if (message.statuses && message.statuses.length) {
                    object.statuses = [];
                    for (let j = 0; j < message.statuses.length; ++j)
                        object.statuses[j] = message.statuses[j];
                }
                return object;
            };

            /**
             * Converts this HTTPCheckInfo to JSON.
             * @function toJSON
             * @memberof mesos.HealthCheck.HTTPCheckInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HTTPCheckInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HTTPCheckInfo;
        })();

        HealthCheck.TCPCheckInfo = (function() {

            /**
             * Properties of a TCPCheckInfo.
             * @memberof mesos.HealthCheck
             * @interface ITCPCheckInfo
             * @property {number} port TCPCheckInfo port
             */

            /**
             * Constructs a new TCPCheckInfo.
             * @memberof mesos.HealthCheck
             * @classdesc Represents a TCPCheckInfo.
             * @constructor
             * @param {mesos.HealthCheck.ITCPCheckInfo=} [properties] Properties to set
             */
            function TCPCheckInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TCPCheckInfo port.
             * @member {number}port
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @instance
             */
            TCPCheckInfo.prototype.port = 0;

            /**
             * Creates a new TCPCheckInfo instance using the specified properties.
             * @function create
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {mesos.HealthCheck.ITCPCheckInfo=} [properties] Properties to set
             * @returns {mesos.HealthCheck.TCPCheckInfo} TCPCheckInfo instance
             */
            TCPCheckInfo.create = function create(properties) {
                return new TCPCheckInfo(properties);
            };

            /**
             * Encodes the specified TCPCheckInfo message. Does not implicitly {@link mesos.HealthCheck.TCPCheckInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {mesos.HealthCheck.ITCPCheckInfo} message TCPCheckInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TCPCheckInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.port);
                return writer;
            };

            /**
             * Encodes the specified TCPCheckInfo message, length delimited. Does not implicitly {@link mesos.HealthCheck.TCPCheckInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {mesos.HealthCheck.ITCPCheckInfo} message TCPCheckInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TCPCheckInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TCPCheckInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.HealthCheck.TCPCheckInfo} TCPCheckInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TCPCheckInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.HealthCheck.TCPCheckInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.port = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("port"))
                    throw $util.ProtocolError("missing required 'port'", { instance: message });
                return message;
            };

            /**
             * Decodes a TCPCheckInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.HealthCheck.TCPCheckInfo} TCPCheckInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TCPCheckInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TCPCheckInfo message.
             * @function verify
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TCPCheckInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
                return null;
            };

            /**
             * Creates a TCPCheckInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.HealthCheck.TCPCheckInfo} TCPCheckInfo
             */
            TCPCheckInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.HealthCheck.TCPCheckInfo)
                    return object;
                let message = new $root.mesos.HealthCheck.TCPCheckInfo();
                if (object.port != null)
                    message.port = object.port >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TCPCheckInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @static
             * @param {mesos.HealthCheck.TCPCheckInfo} message TCPCheckInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TCPCheckInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.port = 0;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };

            /**
             * Converts this TCPCheckInfo to JSON.
             * @function toJSON
             * @memberof mesos.HealthCheck.TCPCheckInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TCPCheckInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TCPCheckInfo;
        })();

        return HealthCheck;
    })();

    mesos.KillPolicy = (function() {

        /**
         * Properties of a KillPolicy.
         * @memberof mesos
         * @interface IKillPolicy
         * @property {mesos.IDurationInfo} [gracePeriod] KillPolicy gracePeriod
         */

        /**
         * Constructs a new KillPolicy.
         * @memberof mesos
         * @classdesc Describes a kill policy for a task. Currently does not express
         * different policies (e.g. hitting HTTP endpoints), only controls
         * how long to wait between graceful and forcible task kill:
         * 
         * graceful kill --------------> forcible kill
         * grace_period
         * 
         * Kill policies are best-effort, because machine failures / forcible
         * terminations may occur.
         * 
         * NOTE: For executor-less command-based tasks, the kill is performed
         * via sending a signal to the task process: SIGTERM for the graceful
         * kill and SIGKILL for the forcible kill. For the docker executor-less
         * tasks the grace period is passed to 'docker stop --time'.
         * @constructor
         * @param {mesos.IKillPolicy=} [properties] Properties to set
         */
        function KillPolicy(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KillPolicy gracePeriod.
         * @member {(mesos.IDurationInfo|null|undefined)}gracePeriod
         * @memberof mesos.KillPolicy
         * @instance
         */
        KillPolicy.prototype.gracePeriod = null;

        /**
         * Creates a new KillPolicy instance using the specified properties.
         * @function create
         * @memberof mesos.KillPolicy
         * @static
         * @param {mesos.IKillPolicy=} [properties] Properties to set
         * @returns {mesos.KillPolicy} KillPolicy instance
         */
        KillPolicy.create = function create(properties) {
            return new KillPolicy(properties);
        };

        /**
         * Encodes the specified KillPolicy message. Does not implicitly {@link mesos.KillPolicy.verify|verify} messages.
         * @function encode
         * @memberof mesos.KillPolicy
         * @static
         * @param {mesos.IKillPolicy} message KillPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KillPolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gracePeriod != null && message.hasOwnProperty("gracePeriod"))
                $root.mesos.DurationInfo.encode(message.gracePeriod, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified KillPolicy message, length delimited. Does not implicitly {@link mesos.KillPolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.KillPolicy
         * @static
         * @param {mesos.IKillPolicy} message KillPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KillPolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KillPolicy message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.KillPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.KillPolicy} KillPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KillPolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.KillPolicy();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.gracePeriod = $root.mesos.DurationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KillPolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.KillPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.KillPolicy} KillPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KillPolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KillPolicy message.
         * @function verify
         * @memberof mesos.KillPolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KillPolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gracePeriod != null && message.hasOwnProperty("gracePeriod")) {
                let error = $root.mesos.DurationInfo.verify(message.gracePeriod);
                if (error)
                    return "gracePeriod." + error;
            }
            return null;
        };

        /**
         * Creates a KillPolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.KillPolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.KillPolicy} KillPolicy
         */
        KillPolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.KillPolicy)
                return object;
            let message = new $root.mesos.KillPolicy();
            if (object.gracePeriod != null) {
                if (typeof object.gracePeriod !== "object")
                    throw TypeError(".mesos.KillPolicy.gracePeriod: object expected");
                message.gracePeriod = $root.mesos.DurationInfo.fromObject(object.gracePeriod);
            }
            return message;
        };

        /**
         * Creates a plain object from a KillPolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.KillPolicy
         * @static
         * @param {mesos.KillPolicy} message KillPolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KillPolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gracePeriod = null;
            if (message.gracePeriod != null && message.hasOwnProperty("gracePeriod"))
                object.gracePeriod = $root.mesos.DurationInfo.toObject(message.gracePeriod, options);
            return object;
        };

        /**
         * Converts this KillPolicy to JSON.
         * @function toJSON
         * @memberof mesos.KillPolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KillPolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KillPolicy;
    })();

    mesos.CommandInfo = (function() {

        /**
         * Properties of a CommandInfo.
         * @memberof mesos
         * @interface ICommandInfo
         * @property {Array.<mesos.CommandInfo.IURI>} [uris] CommandInfo uris
         * @property {mesos.IEnvironment} [environment] CommandInfo environment
         * @property {boolean} [shell] CommandInfo shell
         * @property {string} [value] CommandInfo value
         * @property {Array.<string>} ["arguments"] CommandInfo arguments
         * @property {string} [user] CommandInfo user
         */

        /**
         * Constructs a new CommandInfo.
         * @memberof mesos
         * @classdesc Describes a command, executed via: '/bin/sh -c value'. Any URIs specified
         * are fetched before executing the command.  If the executable field for an
         * uri is set, executable file permission is set on the downloaded file.
         * Otherwise, if the downloaded file has a recognized archive extension
         * (currently [compressed] tar and zip) it is extracted into the executor's
         * working directory. This extraction can be disabled by setting `extract` to
         * false. In addition, any environment variables are set before executing
         * the command (so they can be used to "parameterize" your command).
         * @constructor
         * @param {mesos.ICommandInfo=} [properties] Properties to set
         */
        function CommandInfo(properties) {
            this.uris = [];
            this["arguments"] = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandInfo uris.
         * @member {Array.<mesos.CommandInfo.IURI>}uris
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype.uris = $util.emptyArray;

        /**
         * CommandInfo environment.
         * @member {(mesos.IEnvironment|null|undefined)}environment
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype.environment = null;

        /**
         * CommandInfo shell.
         * @member {boolean}shell
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype.shell = true;

        /**
         * CommandInfo value.
         * @member {string}value
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype.value = "";

        /**
         * CommandInfo arguments.
         * @member {Array.<string>}arguments_
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype["arguments"] = $util.emptyArray;

        /**
         * CommandInfo user.
         * @member {string}user
         * @memberof mesos.CommandInfo
         * @instance
         */
        CommandInfo.prototype.user = "";

        /**
         * Creates a new CommandInfo instance using the specified properties.
         * @function create
         * @memberof mesos.CommandInfo
         * @static
         * @param {mesos.ICommandInfo=} [properties] Properties to set
         * @returns {mesos.CommandInfo} CommandInfo instance
         */
        CommandInfo.create = function create(properties) {
            return new CommandInfo(properties);
        };

        /**
         * Encodes the specified CommandInfo message. Does not implicitly {@link mesos.CommandInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.CommandInfo
         * @static
         * @param {mesos.ICommandInfo} message CommandInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uris != null && message.uris.length)
                for (let i = 0; i < message.uris.length; ++i)
                    $root.mesos.CommandInfo.URI.encode(message.uris[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.environment != null && message.hasOwnProperty("environment"))
                $root.mesos.Environment.encode(message.environment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.user);
            if (message.shell != null && message.hasOwnProperty("shell"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.shell);
            if (message["arguments"] != null && message["arguments"].length)
                for (let i = 0; i < message["arguments"].length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message["arguments"][i]);
            return writer;
        };

        /**
         * Encodes the specified CommandInfo message, length delimited. Does not implicitly {@link mesos.CommandInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.CommandInfo
         * @static
         * @param {mesos.ICommandInfo} message CommandInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.CommandInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.CommandInfo} CommandInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CommandInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.uris && message.uris.length))
                        message.uris = [];
                    message.uris.push($root.mesos.CommandInfo.URI.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.environment = $root.mesos.Environment.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.shell = reader.bool();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                case 7:
                    if (!(message["arguments"] && message["arguments"].length))
                        message["arguments"] = [];
                    message["arguments"].push(reader.string());
                    break;
                case 5:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.CommandInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.CommandInfo} CommandInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandInfo message.
         * @function verify
         * @memberof mesos.CommandInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uris != null && message.hasOwnProperty("uris")) {
                if (!Array.isArray(message.uris))
                    return "uris: array expected";
                for (let i = 0; i < message.uris.length; ++i) {
                    let error = $root.mesos.CommandInfo.URI.verify(message.uris[i]);
                    if (error)
                        return "uris." + error;
                }
            }
            if (message.environment != null && message.hasOwnProperty("environment")) {
                error = $root.mesos.Environment.verify(message.environment);
                if (error)
                    return "environment." + error;
            }
            if (message.shell != null && message.hasOwnProperty("shell"))
                if (typeof message.shell !== "boolean")
                    return "shell: boolean expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
                if (!Array.isArray(message["arguments"]))
                    return "arguments: array expected";
                for (let i = 0; i < message["arguments"].length; ++i)
                    if (!$util.isString(message["arguments"][i]))
                        return "arguments: string[] expected";
            }
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            return null;
        };

        /**
         * Creates a CommandInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.CommandInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.CommandInfo} CommandInfo
         */
        CommandInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.CommandInfo)
                return object;
            let message = new $root.mesos.CommandInfo();
            if (object.uris) {
                if (!Array.isArray(object.uris))
                    throw TypeError(".mesos.CommandInfo.uris: array expected");
                message.uris = [];
                for (let i = 0; i < object.uris.length; ++i) {
                    if (typeof object.uris[i] !== "object")
                        throw TypeError(".mesos.CommandInfo.uris: object expected");
                    message.uris[i] = $root.mesos.CommandInfo.URI.fromObject(object.uris[i]);
                }
            }
            if (object.environment != null) {
                if (typeof object.environment !== "object")
                    throw TypeError(".mesos.CommandInfo.environment: object expected");
                message.environment = $root.mesos.Environment.fromObject(object.environment);
            }
            if (object.shell != null)
                message.shell = Boolean(object.shell);
            if (object.value != null)
                message.value = String(object.value);
            if (object["arguments"]) {
                if (!Array.isArray(object["arguments"]))
                    throw TypeError(".mesos.CommandInfo.arguments: array expected");
                message["arguments"] = [];
                for (let i = 0; i < object["arguments"].length; ++i)
                    message["arguments"][i] = String(object["arguments"][i]);
            }
            if (object.user != null)
                message.user = String(object.user);
            return message;
        };

        /**
         * Creates a plain object from a CommandInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.CommandInfo
         * @static
         * @param {mesos.CommandInfo} message CommandInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.uris = [];
                object["arguments"] = [];
            }
            if (options.defaults) {
                object.environment = null;
                object.value = "";
                object.user = "";
                object.shell = true;
            }
            if (message.uris && message.uris.length) {
                object.uris = [];
                for (let j = 0; j < message.uris.length; ++j)
                    object.uris[j] = $root.mesos.CommandInfo.URI.toObject(message.uris[j], options);
            }
            if (message.environment != null && message.hasOwnProperty("environment"))
                object.environment = $root.mesos.Environment.toObject(message.environment, options);
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.shell != null && message.hasOwnProperty("shell"))
                object.shell = message.shell;
            if (message["arguments"] && message["arguments"].length) {
                object["arguments"] = [];
                for (let j = 0; j < message["arguments"].length; ++j)
                    object["arguments"][j] = message["arguments"][j];
            }
            return object;
        };

        /**
         * Converts this CommandInfo to JSON.
         * @function toJSON
         * @memberof mesos.CommandInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CommandInfo.URI = (function() {

            /**
             * Properties of a URI.
             * @memberof mesos.CommandInfo
             * @interface IURI
             * @property {string} value URI value
             * @property {boolean} [executable] URI executable
             * @property {boolean} [extract] URI extract
             * @property {boolean} [cache] URI cache
             * @property {string} [outputFile] URI outputFile
             */

            /**
             * Constructs a new URI.
             * @memberof mesos.CommandInfo
             * @classdesc Represents a URI.
             * @constructor
             * @param {mesos.CommandInfo.IURI=} [properties] Properties to set
             */
            function URI(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * URI value.
             * @member {string}value
             * @memberof mesos.CommandInfo.URI
             * @instance
             */
            URI.prototype.value = "";

            /**
             * URI executable.
             * @member {boolean}executable
             * @memberof mesos.CommandInfo.URI
             * @instance
             */
            URI.prototype.executable = false;

            /**
             * URI extract.
             * @member {boolean}extract
             * @memberof mesos.CommandInfo.URI
             * @instance
             */
            URI.prototype.extract = true;

            /**
             * URI cache.
             * @member {boolean}cache
             * @memberof mesos.CommandInfo.URI
             * @instance
             */
            URI.prototype.cache = false;

            /**
             * URI outputFile.
             * @member {string}outputFile
             * @memberof mesos.CommandInfo.URI
             * @instance
             */
            URI.prototype.outputFile = "";

            /**
             * Creates a new URI instance using the specified properties.
             * @function create
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {mesos.CommandInfo.IURI=} [properties] Properties to set
             * @returns {mesos.CommandInfo.URI} URI instance
             */
            URI.create = function create(properties) {
                return new URI(properties);
            };

            /**
             * Encodes the specified URI message. Does not implicitly {@link mesos.CommandInfo.URI.verify|verify} messages.
             * @function encode
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {mesos.CommandInfo.IURI} message URI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URI.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                if (message.executable != null && message.hasOwnProperty("executable"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.executable);
                if (message.extract != null && message.hasOwnProperty("extract"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.extract);
                if (message.cache != null && message.hasOwnProperty("cache"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.cache);
                if (message.outputFile != null && message.hasOwnProperty("outputFile"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.outputFile);
                return writer;
            };

            /**
             * Encodes the specified URI message, length delimited. Does not implicitly {@link mesos.CommandInfo.URI.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {mesos.CommandInfo.IURI} message URI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            URI.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a URI message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CommandInfo.URI} URI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URI.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CommandInfo.URI();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    case 2:
                        message.executable = reader.bool();
                        break;
                    case 3:
                        message.extract = reader.bool();
                        break;
                    case 4:
                        message.cache = reader.bool();
                        break;
                    case 5:
                        message.outputFile = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };

            /**
             * Decodes a URI message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CommandInfo.URI} URI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            URI.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a URI message.
             * @function verify
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            URI.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                if (message.executable != null && message.hasOwnProperty("executable"))
                    if (typeof message.executable !== "boolean")
                        return "executable: boolean expected";
                if (message.extract != null && message.hasOwnProperty("extract"))
                    if (typeof message.extract !== "boolean")
                        return "extract: boolean expected";
                if (message.cache != null && message.hasOwnProperty("cache"))
                    if (typeof message.cache !== "boolean")
                        return "cache: boolean expected";
                if (message.outputFile != null && message.hasOwnProperty("outputFile"))
                    if (!$util.isString(message.outputFile))
                        return "outputFile: string expected";
                return null;
            };

            /**
             * Creates a URI message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CommandInfo.URI} URI
             */
            URI.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CommandInfo.URI)
                    return object;
                let message = new $root.mesos.CommandInfo.URI();
                if (object.value != null)
                    message.value = String(object.value);
                if (object.executable != null)
                    message.executable = Boolean(object.executable);
                if (object.extract != null)
                    message.extract = Boolean(object.extract);
                if (object.cache != null)
                    message.cache = Boolean(object.cache);
                if (object.outputFile != null)
                    message.outputFile = String(object.outputFile);
                return message;
            };

            /**
             * Creates a plain object from a URI message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CommandInfo.URI
             * @static
             * @param {mesos.CommandInfo.URI} message URI
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            URI.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.value = "";
                    object.executable = false;
                    object.extract = true;
                    object.cache = false;
                    object.outputFile = "";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.executable != null && message.hasOwnProperty("executable"))
                    object.executable = message.executable;
                if (message.extract != null && message.hasOwnProperty("extract"))
                    object.extract = message.extract;
                if (message.cache != null && message.hasOwnProperty("cache"))
                    object.cache = message.cache;
                if (message.outputFile != null && message.hasOwnProperty("outputFile"))
                    object.outputFile = message.outputFile;
                return object;
            };

            /**
             * Converts this URI to JSON.
             * @function toJSON
             * @memberof mesos.CommandInfo.URI
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            URI.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return URI;
        })();

        return CommandInfo;
    })();

    mesos.ExecutorInfo = (function() {

        /**
         * Properties of an ExecutorInfo.
         * @memberof mesos
         * @interface IExecutorInfo
         * @property {mesos.ExecutorInfo.Type} [type] ExecutorInfo type
         * @property {mesos.IExecutorID} executorId ExecutorInfo executorId
         * @property {mesos.IFrameworkID} [frameworkId] ExecutorInfo frameworkId
         * @property {mesos.ICommandInfo} [command] ExecutorInfo command
         * @property {mesos.IContainerInfo} [container] ExecutorInfo container
         * @property {Array.<mesos.IResource>} [resources] ExecutorInfo resources
         * @property {string} [name] ExecutorInfo name
         * @property {string} [source] ExecutorInfo source
         * @property {Uint8Array} [data] ExecutorInfo data
         * @property {mesos.IDiscoveryInfo} [discovery] ExecutorInfo discovery
         * @property {mesos.IDurationInfo} [shutdownGracePeriod] ExecutorInfo shutdownGracePeriod
         * @property {mesos.ILabels} [labels] ExecutorInfo labels
         */

        /**
         * Constructs a new ExecutorInfo.
         * @memberof mesos
         * @classdesc Describes information about an executor.
         * @constructor
         * @param {mesos.IExecutorInfo=} [properties] Properties to set
         */
        function ExecutorInfo(properties) {
            this.resources = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutorInfo type.
         * @member {mesos.ExecutorInfo.Type}type
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.type = 0;

        /**
         * ExecutorInfo executorId.
         * @member {mesos.IExecutorID}executorId
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.executorId = null;

        /**
         * ExecutorInfo frameworkId.
         * @member {(mesos.IFrameworkID|null|undefined)}frameworkId
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.frameworkId = null;

        /**
         * ExecutorInfo command.
         * @member {(mesos.ICommandInfo|null|undefined)}command
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.command = null;

        /**
         * ExecutorInfo container.
         * @member {(mesos.IContainerInfo|null|undefined)}container
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.container = null;

        /**
         * ExecutorInfo resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.resources = $util.emptyArray;

        /**
         * ExecutorInfo name.
         * @member {string}name
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.name = "";

        /**
         * ExecutorInfo source.
         * @member {string}source
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.source = "";

        /**
         * ExecutorInfo data.
         * @member {Uint8Array}data
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.data = $util.newBuffer([]);

        /**
         * ExecutorInfo discovery.
         * @member {(mesos.IDiscoveryInfo|null|undefined)}discovery
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.discovery = null;

        /**
         * ExecutorInfo shutdownGracePeriod.
         * @member {(mesos.IDurationInfo|null|undefined)}shutdownGracePeriod
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.shutdownGracePeriod = null;

        /**
         * ExecutorInfo labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.ExecutorInfo
         * @instance
         */
        ExecutorInfo.prototype.labels = null;

        /**
         * Creates a new ExecutorInfo instance using the specified properties.
         * @function create
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {mesos.IExecutorInfo=} [properties] Properties to set
         * @returns {mesos.ExecutorInfo} ExecutorInfo instance
         */
        ExecutorInfo.create = function create(properties) {
            return new ExecutorInfo(properties);
        };

        /**
         * Encodes the specified ExecutorInfo message. Does not implicitly {@link mesos.ExecutorInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {mesos.IExecutorInfo} message ExecutorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.command != null && message.hasOwnProperty("command"))
                $root.mesos.CommandInfo.encode(message.command, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.name);
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.source);
            if (message.container != null && message.hasOwnProperty("container"))
                $root.mesos.ContainerInfo.encode(message.container, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                $root.mesos.DiscoveryInfo.encode(message.discovery, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.shutdownGracePeriod != null && message.hasOwnProperty("shutdownGracePeriod"))
                $root.mesos.DurationInfo.encode(message.shutdownGracePeriod, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ExecutorInfo message, length delimited. Does not implicitly {@link mesos.ExecutorInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {mesos.IExecutorInfo} message ExecutorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutorInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ExecutorInfo} ExecutorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ExecutorInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 15:
                    message.type = reader.int32();
                    break;
                case 1:
                    message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.command = $root.mesos.CommandInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.container = $root.mesos.ContainerInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.name = reader.string();
                    break;
                case 10:
                    message.source = reader.string();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 12:
                    message.discovery = $root.mesos.DiscoveryInfo.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.shutdownGracePeriod = $root.mesos.DurationInfo.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("executorId"))
                throw $util.ProtocolError("missing required 'executorId'", { instance: message });
            return message;
        };

        /**
         * Decodes an ExecutorInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ExecutorInfo} ExecutorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutorInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutorInfo message.
         * @function verify
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutorInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            let error = $root.mesos.ExecutorID.verify(message.executorId);
            if (error)
                return "executorId." + error;
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId")) {
                error = $root.mesos.FrameworkID.verify(message.frameworkId);
                if (error)
                    return "frameworkId." + error;
            }
            if (message.command != null && message.hasOwnProperty("command")) {
                error = $root.mesos.CommandInfo.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.container != null && message.hasOwnProperty("container")) {
                error = $root.mesos.ContainerInfo.verify(message.container);
                if (error)
                    return "container." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.discovery != null && message.hasOwnProperty("discovery")) {
                error = $root.mesos.DiscoveryInfo.verify(message.discovery);
                if (error)
                    return "discovery." + error;
            }
            if (message.shutdownGracePeriod != null && message.hasOwnProperty("shutdownGracePeriod")) {
                error = $root.mesos.DurationInfo.verify(message.shutdownGracePeriod);
                if (error)
                    return "shutdownGracePeriod." + error;
            }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutorInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ExecutorInfo} ExecutorInfo
         */
        ExecutorInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ExecutorInfo)
                return object;
            let message = new $root.mesos.ExecutorInfo();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "DEFAULT":
            case 1:
                message.type = 1;
                break;
            case "CUSTOM":
            case 2:
                message.type = 2;
                break;
            }
            if (object.executorId != null) {
                if (typeof object.executorId !== "object")
                    throw TypeError(".mesos.ExecutorInfo.executorId: object expected");
                message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
            }
            if (object.frameworkId != null) {
                if (typeof object.frameworkId !== "object")
                    throw TypeError(".mesos.ExecutorInfo.frameworkId: object expected");
                message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
            }
            if (object.command != null) {
                if (typeof object.command !== "object")
                    throw TypeError(".mesos.ExecutorInfo.command: object expected");
                message.command = $root.mesos.CommandInfo.fromObject(object.command);
            }
            if (object.container != null) {
                if (typeof object.container !== "object")
                    throw TypeError(".mesos.ExecutorInfo.container: object expected");
                message.container = $root.mesos.ContainerInfo.fromObject(object.container);
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.ExecutorInfo.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.ExecutorInfo.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.source != null)
                message.source = String(object.source);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.discovery != null) {
                if (typeof object.discovery !== "object")
                    throw TypeError(".mesos.ExecutorInfo.discovery: object expected");
                message.discovery = $root.mesos.DiscoveryInfo.fromObject(object.discovery);
            }
            if (object.shutdownGracePeriod != null) {
                if (typeof object.shutdownGracePeriod !== "object")
                    throw TypeError(".mesos.ExecutorInfo.shutdownGracePeriod: object expected");
                message.shutdownGracePeriod = $root.mesos.DurationInfo.fromObject(object.shutdownGracePeriod);
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.ExecutorInfo.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutorInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ExecutorInfo
         * @static
         * @param {mesos.ExecutorInfo} message ExecutorInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutorInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (options.defaults) {
                object.executorId = null;
                object.data = options.bytes === String ? "" : [];
                object.command = null;
                object.frameworkId = null;
                object.name = "";
                object.source = "";
                object.container = null;
                object.discovery = null;
                object.shutdownGracePeriod = null;
                object.labels = null;
                object.type = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.executorId != null && message.hasOwnProperty("executorId"))
                object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = $root.mesos.CommandInfo.toObject(message.command, options);
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            if (message.container != null && message.hasOwnProperty("container"))
                object.container = $root.mesos.ContainerInfo.toObject(message.container, options);
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                object.discovery = $root.mesos.DiscoveryInfo.toObject(message.discovery, options);
            if (message.shutdownGracePeriod != null && message.hasOwnProperty("shutdownGracePeriod"))
                object.shutdownGracePeriod = $root.mesos.DurationInfo.toObject(message.shutdownGracePeriod, options);
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.ExecutorInfo.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ExecutorInfo to JSON.
         * @function toJSON
         * @memberof mesos.ExecutorInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutorInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} DEFAULT=1 DEFAULT value
         * @property {number} CUSTOM=2 CUSTOM value
         */
        ExecutorInfo.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "DEFAULT"] = 1;
            values[valuesById[2] = "CUSTOM"] = 2;
            return values;
        })();

        return ExecutorInfo;
    })();

    mesos.MasterInfo = (function() {

        /**
         * Properties of a MasterInfo.
         * @memberof mesos
         * @interface IMasterInfo
         * @property {string} id MasterInfo id
         * @property {number} ip MasterInfo ip
         * @property {number} port MasterInfo port
         * @property {string} [pid] MasterInfo pid
         * @property {string} [hostname] MasterInfo hostname
         * @property {string} [version] MasterInfo version
         * @property {mesos.IAddress} [address] MasterInfo address
         */

        /**
         * Constructs a new MasterInfo.
         * @memberof mesos
         * @classdesc Describes a master. This will probably have more fields in the
         * future which might be used, for example, to link a framework webui
         * to a master webui.
         * @constructor
         * @param {mesos.IMasterInfo=} [properties] Properties to set
         */
        function MasterInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MasterInfo id.
         * @member {string}id
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.id = "";

        /**
         * MasterInfo ip.
         * @member {number}ip
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.ip = 0;

        /**
         * MasterInfo port.
         * @member {number}port
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.port = 5050;

        /**
         * MasterInfo pid.
         * @member {string}pid
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.pid = "";

        /**
         * MasterInfo hostname.
         * @member {string}hostname
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.hostname = "";

        /**
         * MasterInfo version.
         * @member {string}version
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.version = "";

        /**
         * MasterInfo address.
         * @member {(mesos.IAddress|null|undefined)}address
         * @memberof mesos.MasterInfo
         * @instance
         */
        MasterInfo.prototype.address = null;

        /**
         * Creates a new MasterInfo instance using the specified properties.
         * @function create
         * @memberof mesos.MasterInfo
         * @static
         * @param {mesos.IMasterInfo=} [properties] Properties to set
         * @returns {mesos.MasterInfo} MasterInfo instance
         */
        MasterInfo.create = function create(properties) {
            return new MasterInfo(properties);
        };

        /**
         * Encodes the specified MasterInfo message. Does not implicitly {@link mesos.MasterInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.MasterInfo
         * @static
         * @param {mesos.IMasterInfo} message MasterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ip);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.port);
            if (message.pid != null && message.hasOwnProperty("pid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.pid);
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.hostname);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.version);
            if (message.address != null && message.hasOwnProperty("address"))
                $root.mesos.Address.encode(message.address, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MasterInfo message, length delimited. Does not implicitly {@link mesos.MasterInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.MasterInfo
         * @static
         * @param {mesos.IMasterInfo} message MasterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.MasterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.MasterInfo} MasterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.MasterInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.ip = reader.uint32();
                    break;
                case 3:
                    message.port = reader.uint32();
                    break;
                case 4:
                    message.pid = reader.string();
                    break;
                case 5:
                    message.hostname = reader.string();
                    break;
                case 6:
                    message.version = reader.string();
                    break;
                case 7:
                    message.address = $root.mesos.Address.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("ip"))
                throw $util.ProtocolError("missing required 'ip'", { instance: message });
            if (!message.hasOwnProperty("port"))
                throw $util.ProtocolError("missing required 'port'", { instance: message });
            return message;
        };

        /**
         * Decodes a MasterInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.MasterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.MasterInfo} MasterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterInfo message.
         * @function verify
         * @memberof mesos.MasterInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (!$util.isInteger(message.ip))
                return "ip: integer expected";
            if (!$util.isInteger(message.port))
                return "port: integer expected";
            if (message.pid != null && message.hasOwnProperty("pid"))
                if (!$util.isString(message.pid))
                    return "pid: string expected";
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.address != null && message.hasOwnProperty("address")) {
                let error = $root.mesos.Address.verify(message.address);
                if (error)
                    return "address." + error;
            }
            return null;
        };

        /**
         * Creates a MasterInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.MasterInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.MasterInfo} MasterInfo
         */
        MasterInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.MasterInfo)
                return object;
            let message = new $root.mesos.MasterInfo();
            if (object.id != null)
                message.id = String(object.id);
            if (object.ip != null)
                message.ip = object.ip >>> 0;
            if (object.port != null)
                message.port = object.port >>> 0;
            if (object.pid != null)
                message.pid = String(object.pid);
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.version != null)
                message.version = String(object.version);
            if (object.address != null) {
                if (typeof object.address !== "object")
                    throw TypeError(".mesos.MasterInfo.address: object expected");
                message.address = $root.mesos.Address.fromObject(object.address);
            }
            return message;
        };

        /**
         * Creates a plain object from a MasterInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.MasterInfo
         * @static
         * @param {mesos.MasterInfo} message MasterInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.ip = 0;
                object.port = 5050;
                object.pid = "";
                object.hostname = "";
                object.version = "";
                object.address = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.pid != null && message.hasOwnProperty("pid"))
                object.pid = message.pid;
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = $root.mesos.Address.toObject(message.address, options);
            return object;
        };

        /**
         * Converts this MasterInfo to JSON.
         * @function toJSON
         * @memberof mesos.MasterInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterInfo;
    })();

    mesos.AgentInfo = (function() {

        /**
         * Properties of an AgentInfo.
         * @memberof mesos
         * @interface IAgentInfo
         * @property {string} hostname AgentInfo hostname
         * @property {number} [port] AgentInfo port
         * @property {Array.<mesos.IResource>} [resources] AgentInfo resources
         * @property {Array.<mesos.IAttribute>} [attributes] AgentInfo attributes
         * @property {mesos.IAgentID} [id] AgentInfo id
         */

        /**
         * Constructs a new AgentInfo.
         * @memberof mesos
         * @classdesc Describes an agent. Note that the 'id' field is only available
         * after an agent is registered with the master, and is made available
         * here to facilitate re-registration.
         * @constructor
         * @param {mesos.IAgentInfo=} [properties] Properties to set
         */
        function AgentInfo(properties) {
            this.resources = [];
            this.attributes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AgentInfo hostname.
         * @member {string}hostname
         * @memberof mesos.AgentInfo
         * @instance
         */
        AgentInfo.prototype.hostname = "";

        /**
         * AgentInfo port.
         * @member {number}port
         * @memberof mesos.AgentInfo
         * @instance
         */
        AgentInfo.prototype.port = 5051;

        /**
         * AgentInfo resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.AgentInfo
         * @instance
         */
        AgentInfo.prototype.resources = $util.emptyArray;

        /**
         * AgentInfo attributes.
         * @member {Array.<mesos.IAttribute>}attributes
         * @memberof mesos.AgentInfo
         * @instance
         */
        AgentInfo.prototype.attributes = $util.emptyArray;

        /**
         * AgentInfo id.
         * @member {(mesos.IAgentID|null|undefined)}id
         * @memberof mesos.AgentInfo
         * @instance
         */
        AgentInfo.prototype.id = null;

        /**
         * Creates a new AgentInfo instance using the specified properties.
         * @function create
         * @memberof mesos.AgentInfo
         * @static
         * @param {mesos.IAgentInfo=} [properties] Properties to set
         * @returns {mesos.AgentInfo} AgentInfo instance
         */
        AgentInfo.create = function create(properties) {
            return new AgentInfo(properties);
        };

        /**
         * Encodes the specified AgentInfo message. Does not implicitly {@link mesos.AgentInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.AgentInfo
         * @static
         * @param {mesos.IAgentInfo} message AgentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AgentInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.hostname);
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.attributes != null && message.attributes.length)
                for (let i = 0; i < message.attributes.length; ++i)
                    $root.mesos.Attribute.encode(message.attributes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                $root.mesos.AgentID.encode(message.id, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.port);
            return writer;
        };

        /**
         * Encodes the specified AgentInfo message, length delimited. Does not implicitly {@link mesos.AgentInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.AgentInfo
         * @static
         * @param {mesos.IAgentInfo} message AgentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AgentInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AgentInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.AgentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.AgentInfo} AgentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AgentInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.AgentInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hostname = reader.string();
                    break;
                case 8:
                    message.port = reader.int32();
                    break;
                case 3:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                    message.attributes.push($root.mesos.Attribute.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.id = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("hostname"))
                throw $util.ProtocolError("missing required 'hostname'", { instance: message });
            return message;
        };

        /**
         * Decodes an AgentInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.AgentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.AgentInfo} AgentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AgentInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AgentInfo message.
         * @function verify
         * @memberof mesos.AgentInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AgentInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.hostname))
                return "hostname: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    let error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                for (let i = 0; i < message.attributes.length; ++i) {
                    error = $root.mesos.Attribute.verify(message.attributes[i]);
                    if (error)
                        return "attributes." + error;
                }
            }
            if (message.id != null && message.hasOwnProperty("id")) {
                error = $root.mesos.AgentID.verify(message.id);
                if (error)
                    return "id." + error;
            }
            return null;
        };

        /**
         * Creates an AgentInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.AgentInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.AgentInfo} AgentInfo
         */
        AgentInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.AgentInfo)
                return object;
            let message = new $root.mesos.AgentInfo();
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.AgentInfo.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.AgentInfo.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            if (object.attributes) {
                if (!Array.isArray(object.attributes))
                    throw TypeError(".mesos.AgentInfo.attributes: array expected");
                message.attributes = [];
                for (let i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] !== "object")
                        throw TypeError(".mesos.AgentInfo.attributes: object expected");
                    message.attributes[i] = $root.mesos.Attribute.fromObject(object.attributes[i]);
                }
            }
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".mesos.AgentInfo.id: object expected");
                message.id = $root.mesos.AgentID.fromObject(object.id);
            }
            return message;
        };

        /**
         * Creates a plain object from an AgentInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.AgentInfo
         * @static
         * @param {mesos.AgentInfo} message AgentInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AgentInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.resources = [];
                object.attributes = [];
            }
            if (options.defaults) {
                object.hostname = "";
                object.id = null;
                object.port = 5051;
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (let j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.mesos.Attribute.toObject(message.attributes[j], options);
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.mesos.AgentID.toObject(message.id, options);
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            return object;
        };

        /**
         * Converts this AgentInfo to JSON.
         * @function toJSON
         * @memberof mesos.AgentInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AgentInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        AgentInfo.Capability = (function() {

            /**
             * Properties of a Capability.
             * @memberof mesos.AgentInfo
             * @interface ICapability
             * @property {mesos.AgentInfo.Capability.Type} [type] Capability type
             */

            /**
             * Constructs a new Capability.
             * @memberof mesos.AgentInfo
             * @classdesc Represents a Capability.
             * @constructor
             * @param {mesos.AgentInfo.ICapability=} [properties] Properties to set
             */
            function Capability(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Capability type.
             * @member {mesos.AgentInfo.Capability.Type}type
             * @memberof mesos.AgentInfo.Capability
             * @instance
             */
            Capability.prototype.type = 0;

            /**
             * Creates a new Capability instance using the specified properties.
             * @function create
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {mesos.AgentInfo.ICapability=} [properties] Properties to set
             * @returns {mesos.AgentInfo.Capability} Capability instance
             */
            Capability.create = function create(properties) {
                return new Capability(properties);
            };

            /**
             * Encodes the specified Capability message. Does not implicitly {@link mesos.AgentInfo.Capability.verify|verify} messages.
             * @function encode
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {mesos.AgentInfo.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified Capability message, length delimited. Does not implicitly {@link mesos.AgentInfo.Capability.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {mesos.AgentInfo.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Capability message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.AgentInfo.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.AgentInfo.Capability();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Capability message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.AgentInfo.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Capability message.
             * @function verify
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capability.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Capability message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.AgentInfo.Capability} Capability
             */
            Capability.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.AgentInfo.Capability)
                    return object;
                let message = new $root.mesos.AgentInfo.Capability();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "MULTI_ROLE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Capability message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.AgentInfo.Capability
             * @static
             * @param {mesos.AgentInfo.Capability} message Capability
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capability.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.AgentInfo.Capability.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this Capability to JSON.
             * @function toJSON
             * @memberof mesos.AgentInfo.Capability
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capability.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} MULTI_ROLE=1 MULTI_ROLE value
             */
            Capability.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "MULTI_ROLE"] = 1;
                return values;
            })();

            return Capability;
        })();

        return AgentInfo;
    })();

    mesos.Value = (function() {

        /**
         * Properties of a Value.
         * @memberof mesos
         * @interface IValue
         * @property {mesos.Value.Type} type Value type
         * @property {mesos.Value.IScalar} [scalar] Value scalar
         * @property {mesos.Value.IRanges} [ranges] Value ranges
         * @property {mesos.Value.ISet} [set] Value set
         * @property {mesos.Value.IText} [text] Value text
         */

        /**
         * Constructs a new Value.
         * @memberof mesos
         * @classdesc Describes an Attribute or Resource "value". A value is described
         * using the standard protocol buffer "union" trick.
         * @constructor
         * @param {mesos.IValue=} [properties] Properties to set
         */
        function Value(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Value type.
         * @member {mesos.Value.Type}type
         * @memberof mesos.Value
         * @instance
         */
        Value.prototype.type = 0;

        /**
         * Value scalar.
         * @member {(mesos.Value.IScalar|null|undefined)}scalar
         * @memberof mesos.Value
         * @instance
         */
        Value.prototype.scalar = null;

        /**
         * Value ranges.
         * @member {(mesos.Value.IRanges|null|undefined)}ranges
         * @memberof mesos.Value
         * @instance
         */
        Value.prototype.ranges = null;

        /**
         * Value set.
         * @member {(mesos.Value.ISet|null|undefined)}set
         * @memberof mesos.Value
         * @instance
         */
        Value.prototype.set = null;

        /**
         * Value text.
         * @member {(mesos.Value.IText|null|undefined)}text
         * @memberof mesos.Value
         * @instance
         */
        Value.prototype.text = null;

        /**
         * Creates a new Value instance using the specified properties.
         * @function create
         * @memberof mesos.Value
         * @static
         * @param {mesos.IValue=} [properties] Properties to set
         * @returns {mesos.Value} Value instance
         */
        Value.create = function create(properties) {
            return new Value(properties);
        };

        /**
         * Encodes the specified Value message. Does not implicitly {@link mesos.Value.verify|verify} messages.
         * @function encode
         * @memberof mesos.Value
         * @static
         * @param {mesos.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                $root.mesos.Value.Scalar.encode(message.scalar, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                $root.mesos.Value.Ranges.encode(message.ranges, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.set != null && message.hasOwnProperty("set"))
                $root.mesos.Value.Set.encode(message.set, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.text != null && message.hasOwnProperty("text"))
                $root.mesos.Value.Text.encode(message.text, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Value message, length delimited. Does not implicitly {@link mesos.Value.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Value
         * @static
         * @param {mesos.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Value message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.scalar = $root.mesos.Value.Scalar.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.ranges = $root.mesos.Value.Ranges.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.set = $root.mesos.Value.Set.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.text = $root.mesos.Value.Text.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a Value message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Value message.
         * @function verify
         * @memberof mesos.Value
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Value.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            if (message.scalar != null && message.hasOwnProperty("scalar")) {
                let error = $root.mesos.Value.Scalar.verify(message.scalar);
                if (error)
                    return "scalar." + error;
            }
            if (message.ranges != null && message.hasOwnProperty("ranges")) {
                error = $root.mesos.Value.Ranges.verify(message.ranges);
                if (error)
                    return "ranges." + error;
            }
            if (message.set != null && message.hasOwnProperty("set")) {
                error = $root.mesos.Value.Set.verify(message.set);
                if (error)
                    return "set." + error;
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                error = $root.mesos.Value.Text.verify(message.text);
                if (error)
                    return "text." + error;
            }
            return null;
        };

        /**
         * Creates a Value message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Value
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Value} Value
         */
        Value.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Value)
                return object;
            let message = new $root.mesos.Value();
            switch (object.type) {
            case "SCALAR":
            case 0:
                message.type = 0;
                break;
            case "RANGES":
            case 1:
                message.type = 1;
                break;
            case "SET":
            case 2:
                message.type = 2;
                break;
            case "TEXT":
            case 3:
                message.type = 3;
                break;
            }
            if (object.scalar != null) {
                if (typeof object.scalar !== "object")
                    throw TypeError(".mesos.Value.scalar: object expected");
                message.scalar = $root.mesos.Value.Scalar.fromObject(object.scalar);
            }
            if (object.ranges != null) {
                if (typeof object.ranges !== "object")
                    throw TypeError(".mesos.Value.ranges: object expected");
                message.ranges = $root.mesos.Value.Ranges.fromObject(object.ranges);
            }
            if (object.set != null) {
                if (typeof object.set !== "object")
                    throw TypeError(".mesos.Value.set: object expected");
                message.set = $root.mesos.Value.Set.fromObject(object.set);
            }
            if (object.text != null) {
                if (typeof object.text !== "object")
                    throw TypeError(".mesos.Value.text: object expected");
                message.text = $root.mesos.Value.Text.fromObject(object.text);
            }
            return message;
        };

        /**
         * Creates a plain object from a Value message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Value
         * @static
         * @param {mesos.Value} message Value
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Value.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "SCALAR" : 0;
                object.scalar = null;
                object.ranges = null;
                object.set = null;
                object.text = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.Value.Type[message.type] : message.type;
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                object.scalar = $root.mesos.Value.Scalar.toObject(message.scalar, options);
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                object.ranges = $root.mesos.Value.Ranges.toObject(message.ranges, options);
            if (message.set != null && message.hasOwnProperty("set"))
                object.set = $root.mesos.Value.Set.toObject(message.set, options);
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = $root.mesos.Value.Text.toObject(message.text, options);
            return object;
        };

        /**
         * Converts this Value to JSON.
         * @function toJSON
         * @memberof mesos.Value
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Value.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} SCALAR=0 SCALAR value
         * @property {number} RANGES=1 RANGES value
         * @property {number} SET=2 SET value
         * @property {number} TEXT=3 TEXT value
         */
        Value.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SCALAR"] = 0;
            values[valuesById[1] = "RANGES"] = 1;
            values[valuesById[2] = "SET"] = 2;
            values[valuesById[3] = "TEXT"] = 3;
            return values;
        })();

        Value.Scalar = (function() {

            /**
             * Properties of a Scalar.
             * @memberof mesos.Value
             * @interface IScalar
             * @property {number} value Scalar value
             */

            /**
             * Constructs a new Scalar.
             * @memberof mesos.Value
             * @classdesc Represents a Scalar.
             * @constructor
             * @param {mesos.Value.IScalar=} [properties] Properties to set
             */
            function Scalar(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Scalar value.
             * @member {number}value
             * @memberof mesos.Value.Scalar
             * @instance
             */
            Scalar.prototype.value = 0;

            /**
             * Creates a new Scalar instance using the specified properties.
             * @function create
             * @memberof mesos.Value.Scalar
             * @static
             * @param {mesos.Value.IScalar=} [properties] Properties to set
             * @returns {mesos.Value.Scalar} Scalar instance
             */
            Scalar.create = function create(properties) {
                return new Scalar(properties);
            };

            /**
             * Encodes the specified Scalar message. Does not implicitly {@link mesos.Value.Scalar.verify|verify} messages.
             * @function encode
             * @memberof mesos.Value.Scalar
             * @static
             * @param {mesos.Value.IScalar} message Scalar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scalar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified Scalar message, length delimited. Does not implicitly {@link mesos.Value.Scalar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Value.Scalar
             * @static
             * @param {mesos.Value.IScalar} message Scalar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Scalar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Scalar message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Value.Scalar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Value.Scalar} Scalar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scalar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value.Scalar();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };

            /**
             * Decodes a Scalar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Value.Scalar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Value.Scalar} Scalar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Scalar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Scalar message.
             * @function verify
             * @memberof mesos.Value.Scalar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Scalar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.value !== "number")
                    return "value: number expected";
                return null;
            };

            /**
             * Creates a Scalar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Value.Scalar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Value.Scalar} Scalar
             */
            Scalar.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Value.Scalar)
                    return object;
                let message = new $root.mesos.Value.Scalar();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Scalar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Value.Scalar
             * @static
             * @param {mesos.Value.Scalar} message Scalar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Scalar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Scalar to JSON.
             * @function toJSON
             * @memberof mesos.Value.Scalar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Scalar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Scalar;
        })();

        Value.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof mesos.Value
             * @interface IRange
             * @property {number} begin Range begin
             * @property {number} end Range end
             */

            /**
             * Constructs a new Range.
             * @memberof mesos.Value
             * @classdesc Represents a Range.
             * @constructor
             * @param {mesos.Value.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range begin.
             * @member {number}begin
             * @memberof mesos.Value.Range
             * @instance
             */
            Range.prototype.begin = 0;

            /**
             * Range end.
             * @member {number}end
             * @memberof mesos.Value.Range
             * @instance
             */
            Range.prototype.end = 0;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof mesos.Value.Range
             * @static
             * @param {mesos.Value.IRange=} [properties] Properties to set
             * @returns {mesos.Value.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link mesos.Value.Range.verify|verify} messages.
             * @function encode
             * @memberof mesos.Value.Range
             * @static
             * @param {mesos.Value.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.begin);
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.end);
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link mesos.Value.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Value.Range
             * @static
             * @param {mesos.Value.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Value.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Value.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value.Range();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.begin = reader.uint32();
                        break;
                    case 2:
                        message.end = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("begin"))
                    throw $util.ProtocolError("missing required 'begin'", { instance: message });
                if (!message.hasOwnProperty("end"))
                    throw $util.ProtocolError("missing required 'end'", { instance: message });
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Value.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Value.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof mesos.Value.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.begin))
                    return "begin: integer expected";
                if (!$util.isInteger(message.end))
                    return "end: integer expected";
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Value.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Value.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Value.Range)
                    return object;
                let message = new $root.mesos.Value.Range();
                if (object.begin != null)
                    message.begin = object.begin >>> 0;
                if (object.end != null)
                    message.end = object.end >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Value.Range
             * @static
             * @param {mesos.Value.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.begin = 0;
                    object.end = 0;
                }
                if (message.begin != null && message.hasOwnProperty("begin"))
                    object.begin = message.begin;
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = message.end;
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof mesos.Value.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        Value.Ranges = (function() {

            /**
             * Properties of a Ranges.
             * @memberof mesos.Value
             * @interface IRanges
             * @property {Array.<mesos.Value.IRange>} [range] Ranges range
             */

            /**
             * Constructs a new Ranges.
             * @memberof mesos.Value
             * @classdesc Represents a Ranges.
             * @constructor
             * @param {mesos.Value.IRanges=} [properties] Properties to set
             */
            function Ranges(properties) {
                this.range = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ranges range.
             * @member {Array.<mesos.Value.IRange>}range
             * @memberof mesos.Value.Ranges
             * @instance
             */
            Ranges.prototype.range = $util.emptyArray;

            /**
             * Creates a new Ranges instance using the specified properties.
             * @function create
             * @memberof mesos.Value.Ranges
             * @static
             * @param {mesos.Value.IRanges=} [properties] Properties to set
             * @returns {mesos.Value.Ranges} Ranges instance
             */
            Ranges.create = function create(properties) {
                return new Ranges(properties);
            };

            /**
             * Encodes the specified Ranges message. Does not implicitly {@link mesos.Value.Ranges.verify|verify} messages.
             * @function encode
             * @memberof mesos.Value.Ranges
             * @static
             * @param {mesos.Value.IRanges} message Ranges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ranges.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range != null && message.range.length)
                    for (let i = 0; i < message.range.length; ++i)
                        $root.mesos.Value.Range.encode(message.range[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Ranges message, length delimited. Does not implicitly {@link mesos.Value.Ranges.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Value.Ranges
             * @static
             * @param {mesos.Value.IRanges} message Ranges message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ranges.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ranges message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Value.Ranges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Value.Ranges} Ranges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ranges.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value.Ranges();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.range && message.range.length))
                            message.range = [];
                        message.range.push($root.mesos.Value.Range.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ranges message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Value.Ranges
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Value.Ranges} Ranges
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ranges.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ranges message.
             * @function verify
             * @memberof mesos.Value.Ranges
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ranges.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range != null && message.hasOwnProperty("range")) {
                    if (!Array.isArray(message.range))
                        return "range: array expected";
                    for (let i = 0; i < message.range.length; ++i) {
                        let error = $root.mesos.Value.Range.verify(message.range[i]);
                        if (error)
                            return "range." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Ranges message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Value.Ranges
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Value.Ranges} Ranges
             */
            Ranges.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Value.Ranges)
                    return object;
                let message = new $root.mesos.Value.Ranges();
                if (object.range) {
                    if (!Array.isArray(object.range))
                        throw TypeError(".mesos.Value.Ranges.range: array expected");
                    message.range = [];
                    for (let i = 0; i < object.range.length; ++i) {
                        if (typeof object.range[i] !== "object")
                            throw TypeError(".mesos.Value.Ranges.range: object expected");
                        message.range[i] = $root.mesos.Value.Range.fromObject(object.range[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Ranges message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Value.Ranges
             * @static
             * @param {mesos.Value.Ranges} message Ranges
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ranges.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.range = [];
                if (message.range && message.range.length) {
                    object.range = [];
                    for (let j = 0; j < message.range.length; ++j)
                        object.range[j] = $root.mesos.Value.Range.toObject(message.range[j], options);
                }
                return object;
            };

            /**
             * Converts this Ranges to JSON.
             * @function toJSON
             * @memberof mesos.Value.Ranges
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ranges.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Ranges;
        })();

        Value.Set = (function() {

            /**
             * Properties of a Set.
             * @memberof mesos.Value
             * @interface ISet
             * @property {Array.<string>} [item] Set item
             */

            /**
             * Constructs a new Set.
             * @memberof mesos.Value
             * @classdesc Represents a Set.
             * @constructor
             * @param {mesos.Value.ISet=} [properties] Properties to set
             */
            function Set(properties) {
                this.item = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Set item.
             * @member {Array.<string>}item
             * @memberof mesos.Value.Set
             * @instance
             */
            Set.prototype.item = $util.emptyArray;

            /**
             * Creates a new Set instance using the specified properties.
             * @function create
             * @memberof mesos.Value.Set
             * @static
             * @param {mesos.Value.ISet=} [properties] Properties to set
             * @returns {mesos.Value.Set} Set instance
             */
            Set.create = function create(properties) {
                return new Set(properties);
            };

            /**
             * Encodes the specified Set message. Does not implicitly {@link mesos.Value.Set.verify|verify} messages.
             * @function encode
             * @memberof mesos.Value.Set
             * @static
             * @param {mesos.Value.ISet} message Set message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Set.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.item != null && message.item.length)
                    for (let i = 0; i < message.item.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.item[i]);
                return writer;
            };

            /**
             * Encodes the specified Set message, length delimited. Does not implicitly {@link mesos.Value.Set.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Value.Set
             * @static
             * @param {mesos.Value.ISet} message Set message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Set.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Set message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Value.Set
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Value.Set} Set
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Set.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value.Set();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.item && message.item.length))
                            message.item = [];
                        message.item.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Set message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Value.Set
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Value.Set} Set
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Set.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Set message.
             * @function verify
             * @memberof mesos.Value.Set
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Set.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.item != null && message.hasOwnProperty("item")) {
                    if (!Array.isArray(message.item))
                        return "item: array expected";
                    for (let i = 0; i < message.item.length; ++i)
                        if (!$util.isString(message.item[i]))
                            return "item: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Set message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Value.Set
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Value.Set} Set
             */
            Set.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Value.Set)
                    return object;
                let message = new $root.mesos.Value.Set();
                if (object.item) {
                    if (!Array.isArray(object.item))
                        throw TypeError(".mesos.Value.Set.item: array expected");
                    message.item = [];
                    for (let i = 0; i < object.item.length; ++i)
                        message.item[i] = String(object.item[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Set message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Value.Set
             * @static
             * @param {mesos.Value.Set} message Set
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Set.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.item = [];
                if (message.item && message.item.length) {
                    object.item = [];
                    for (let j = 0; j < message.item.length; ++j)
                        object.item[j] = message.item[j];
                }
                return object;
            };

            /**
             * Converts this Set to JSON.
             * @function toJSON
             * @memberof mesos.Value.Set
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Set.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Set;
        })();

        Value.Text = (function() {

            /**
             * Properties of a Text.
             * @memberof mesos.Value
             * @interface IText
             * @property {string} value Text value
             */

            /**
             * Constructs a new Text.
             * @memberof mesos.Value
             * @classdesc Represents a Text.
             * @constructor
             * @param {mesos.Value.IText=} [properties] Properties to set
             */
            function Text(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Text value.
             * @member {string}value
             * @memberof mesos.Value.Text
             * @instance
             */
            Text.prototype.value = "";

            /**
             * Creates a new Text instance using the specified properties.
             * @function create
             * @memberof mesos.Value.Text
             * @static
             * @param {mesos.Value.IText=} [properties] Properties to set
             * @returns {mesos.Value.Text} Text instance
             */
            Text.create = function create(properties) {
                return new Text(properties);
            };

            /**
             * Encodes the specified Text message. Does not implicitly {@link mesos.Value.Text.verify|verify} messages.
             * @function encode
             * @memberof mesos.Value.Text
             * @static
             * @param {mesos.Value.IText} message Text message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Text.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Text message, length delimited. Does not implicitly {@link mesos.Value.Text.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Value.Text
             * @static
             * @param {mesos.Value.IText} message Text message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Text.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Text message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Value.Text
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Value.Text} Text
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Text.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Value.Text();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("value"))
                    throw $util.ProtocolError("missing required 'value'", { instance: message });
                return message;
            };

            /**
             * Decodes a Text message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Value.Text
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Value.Text} Text
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Text.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Text message.
             * @function verify
             * @memberof mesos.Value.Text
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Text.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.value))
                    return "value: string expected";
                return null;
            };

            /**
             * Creates a Text message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Value.Text
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Value.Text} Text
             */
            Text.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Value.Text)
                    return object;
                let message = new $root.mesos.Value.Text();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Text message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Value.Text
             * @static
             * @param {mesos.Value.Text} message Text
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Text.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Text to JSON.
             * @function toJSON
             * @memberof mesos.Value.Text
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Text.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Text;
        })();

        return Value;
    })();

    mesos.Attribute = (function() {

        /**
         * Properties of an Attribute.
         * @memberof mesos
         * @interface IAttribute
         * @property {string} name Attribute name
         * @property {mesos.Value.Type} type Attribute type
         * @property {mesos.Value.IScalar} [scalar] Attribute scalar
         * @property {mesos.Value.IRanges} [ranges] Attribute ranges
         * @property {mesos.Value.ISet} [set] Attribute set
         * @property {mesos.Value.IText} [text] Attribute text
         */

        /**
         * Constructs a new Attribute.
         * @memberof mesos
         * @classdesc Describes an attribute that can be set on a machine. For now,
         * attributes and resources share the same "value" type, but this may
         * change in the future and attributes may only be string based.
         * @constructor
         * @param {mesos.IAttribute=} [properties] Properties to set
         */
        function Attribute(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Attribute name.
         * @member {string}name
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.name = "";

        /**
         * Attribute type.
         * @member {mesos.Value.Type}type
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.type = 0;

        /**
         * Attribute scalar.
         * @member {(mesos.Value.IScalar|null|undefined)}scalar
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.scalar = null;

        /**
         * Attribute ranges.
         * @member {(mesos.Value.IRanges|null|undefined)}ranges
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.ranges = null;

        /**
         * Attribute set.
         * @member {(mesos.Value.ISet|null|undefined)}set
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.set = null;

        /**
         * Attribute text.
         * @member {(mesos.Value.IText|null|undefined)}text
         * @memberof mesos.Attribute
         * @instance
         */
        Attribute.prototype.text = null;

        /**
         * Creates a new Attribute instance using the specified properties.
         * @function create
         * @memberof mesos.Attribute
         * @static
         * @param {mesos.IAttribute=} [properties] Properties to set
         * @returns {mesos.Attribute} Attribute instance
         */
        Attribute.create = function create(properties) {
            return new Attribute(properties);
        };

        /**
         * Encodes the specified Attribute message. Does not implicitly {@link mesos.Attribute.verify|verify} messages.
         * @function encode
         * @memberof mesos.Attribute
         * @static
         * @param {mesos.IAttribute} message Attribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Attribute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                $root.mesos.Value.Scalar.encode(message.scalar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                $root.mesos.Value.Ranges.encode(message.ranges, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.text != null && message.hasOwnProperty("text"))
                $root.mesos.Value.Text.encode(message.text, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.set != null && message.hasOwnProperty("set"))
                $root.mesos.Value.Set.encode(message.set, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Attribute message, length delimited. Does not implicitly {@link mesos.Attribute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Attribute
         * @static
         * @param {mesos.IAttribute} message Attribute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Attribute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Attribute message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Attribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Attribute} Attribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Attribute.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Attribute();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.scalar = $root.mesos.Value.Scalar.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.ranges = $root.mesos.Value.Ranges.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.set = $root.mesos.Value.Set.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.text = $root.mesos.Value.Text.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes an Attribute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Attribute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Attribute} Attribute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Attribute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Attribute message.
         * @function verify
         * @memberof mesos.Attribute
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Attribute.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            if (message.scalar != null && message.hasOwnProperty("scalar")) {
                let error = $root.mesos.Value.Scalar.verify(message.scalar);
                if (error)
                    return "scalar." + error;
            }
            if (message.ranges != null && message.hasOwnProperty("ranges")) {
                error = $root.mesos.Value.Ranges.verify(message.ranges);
                if (error)
                    return "ranges." + error;
            }
            if (message.set != null && message.hasOwnProperty("set")) {
                error = $root.mesos.Value.Set.verify(message.set);
                if (error)
                    return "set." + error;
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                error = $root.mesos.Value.Text.verify(message.text);
                if (error)
                    return "text." + error;
            }
            return null;
        };

        /**
         * Creates an Attribute message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Attribute
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Attribute} Attribute
         */
        Attribute.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Attribute)
                return object;
            let message = new $root.mesos.Attribute();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "SCALAR":
            case 0:
                message.type = 0;
                break;
            case "RANGES":
            case 1:
                message.type = 1;
                break;
            case "SET":
            case 2:
                message.type = 2;
                break;
            case "TEXT":
            case 3:
                message.type = 3;
                break;
            }
            if (object.scalar != null) {
                if (typeof object.scalar !== "object")
                    throw TypeError(".mesos.Attribute.scalar: object expected");
                message.scalar = $root.mesos.Value.Scalar.fromObject(object.scalar);
            }
            if (object.ranges != null) {
                if (typeof object.ranges !== "object")
                    throw TypeError(".mesos.Attribute.ranges: object expected");
                message.ranges = $root.mesos.Value.Ranges.fromObject(object.ranges);
            }
            if (object.set != null) {
                if (typeof object.set !== "object")
                    throw TypeError(".mesos.Attribute.set: object expected");
                message.set = $root.mesos.Value.Set.fromObject(object.set);
            }
            if (object.text != null) {
                if (typeof object.text !== "object")
                    throw TypeError(".mesos.Attribute.text: object expected");
                message.text = $root.mesos.Value.Text.fromObject(object.text);
            }
            return message;
        };

        /**
         * Creates a plain object from an Attribute message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Attribute
         * @static
         * @param {mesos.Attribute} message Attribute
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Attribute.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "SCALAR" : 0;
                object.scalar = null;
                object.ranges = null;
                object.text = null;
                object.set = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.Value.Type[message.type] : message.type;
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                object.scalar = $root.mesos.Value.Scalar.toObject(message.scalar, options);
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                object.ranges = $root.mesos.Value.Ranges.toObject(message.ranges, options);
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = $root.mesos.Value.Text.toObject(message.text, options);
            if (message.set != null && message.hasOwnProperty("set"))
                object.set = $root.mesos.Value.Set.toObject(message.set, options);
            return object;
        };

        /**
         * Converts this Attribute to JSON.
         * @function toJSON
         * @memberof mesos.Attribute
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Attribute.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Attribute;
    })();

    mesos.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof mesos
         * @interface IResource
         * @property {string} name Resource name
         * @property {mesos.Value.Type} type Resource type
         * @property {mesos.Value.IScalar} [scalar] Resource scalar
         * @property {mesos.Value.IRanges} [ranges] Resource ranges
         * @property {mesos.Value.ISet} [set] Resource set
         * @property {string} [role] Resource role
         * @property {mesos.Resource.IAllocationInfo} [allocationInfo] Resource allocationInfo
         * @property {mesos.Resource.IReservationInfo} [reservation] Resource reservation
         * @property {mesos.Resource.IDiskInfo} [disk] Resource disk
         * @property {mesos.Resource.IRevocableInfo} [revocable] Resource revocable
         * @property {mesos.Resource.ISharedInfo} [shared] Resource shared
         */

        /**
         * Constructs a new Resource.
         * @memberof mesos
         * @classdesc Describes a resource on a machine. The `name` field is a string
         * like "cpus" or "mem" that indicates which kind of resource this is;
         * the rest of the fields describe the properties of the resource. A
         * resource can take on one of three types: scalar (double), a list of
         * finite and discrete ranges (e.g., [1-10, 20-30]), or a set of
         * items. A resource is described using the standard protocol buffer
         * "union" trick.
         * 
         * Note that "disk" and "mem" resources are scalar values expressed in
         * megabytes. Fractional "cpus" values are allowed (e.g., "0.5"),
         * which correspond to partial shares of a CPU.
         * @constructor
         * @param {mesos.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource name.
         * @member {string}name
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.name = "";

        /**
         * Resource type.
         * @member {mesos.Value.Type}type
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.type = 0;

        /**
         * Resource scalar.
         * @member {(mesos.Value.IScalar|null|undefined)}scalar
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.scalar = null;

        /**
         * Resource ranges.
         * @member {(mesos.Value.IRanges|null|undefined)}ranges
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.ranges = null;

        /**
         * Resource set.
         * @member {(mesos.Value.ISet|null|undefined)}set
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.set = null;

        /**
         * Resource role.
         * @member {string}role
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.role = "*";

        /**
         * Resource allocationInfo.
         * @member {(mesos.Resource.IAllocationInfo|null|undefined)}allocationInfo
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.allocationInfo = null;

        /**
         * Resource reservation.
         * @member {(mesos.Resource.IReservationInfo|null|undefined)}reservation
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.reservation = null;

        /**
         * Resource disk.
         * @member {(mesos.Resource.IDiskInfo|null|undefined)}disk
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.disk = null;

        /**
         * Resource revocable.
         * @member {(mesos.Resource.IRevocableInfo|null|undefined)}revocable
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.revocable = null;

        /**
         * Resource shared.
         * @member {(mesos.Resource.ISharedInfo|null|undefined)}shared
         * @memberof mesos.Resource
         * @instance
         */
        Resource.prototype.shared = null;

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof mesos.Resource
         * @static
         * @param {mesos.IResource=} [properties] Properties to set
         * @returns {mesos.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link mesos.Resource.verify|verify} messages.
         * @function encode
         * @memberof mesos.Resource
         * @static
         * @param {mesos.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                $root.mesos.Value.Scalar.encode(message.scalar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                $root.mesos.Value.Ranges.encode(message.ranges, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.set != null && message.hasOwnProperty("set"))
                $root.mesos.Value.Set.encode(message.set, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.role != null && message.hasOwnProperty("role"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.role);
            if (message.disk != null && message.hasOwnProperty("disk"))
                $root.mesos.Resource.DiskInfo.encode(message.disk, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.reservation != null && message.hasOwnProperty("reservation"))
                $root.mesos.Resource.ReservationInfo.encode(message.reservation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.revocable != null && message.hasOwnProperty("revocable"))
                $root.mesos.Resource.RevocableInfo.encode(message.revocable, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.shared != null && message.hasOwnProperty("shared"))
                $root.mesos.Resource.SharedInfo.encode(message.shared, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo"))
                $root.mesos.Resource.AllocationInfo.encode(message.allocationInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link mesos.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Resource
         * @static
         * @param {mesos.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.scalar = $root.mesos.Value.Scalar.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.ranges = $root.mesos.Value.Ranges.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.set = $root.mesos.Value.Set.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.role = reader.string();
                    break;
                case 11:
                    message.allocationInfo = $root.mesos.Resource.AllocationInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.reservation = $root.mesos.Resource.ReservationInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.disk = $root.mesos.Resource.DiskInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.revocable = $root.mesos.Resource.RevocableInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.shared = $root.mesos.Resource.SharedInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof mesos.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            if (message.scalar != null && message.hasOwnProperty("scalar")) {
                let error = $root.mesos.Value.Scalar.verify(message.scalar);
                if (error)
                    return "scalar." + error;
            }
            if (message.ranges != null && message.hasOwnProperty("ranges")) {
                error = $root.mesos.Value.Ranges.verify(message.ranges);
                if (error)
                    return "ranges." + error;
            }
            if (message.set != null && message.hasOwnProperty("set")) {
                error = $root.mesos.Value.Set.verify(message.set);
                if (error)
                    return "set." + error;
            }
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo")) {
                error = $root.mesos.Resource.AllocationInfo.verify(message.allocationInfo);
                if (error)
                    return "allocationInfo." + error;
            }
            if (message.reservation != null && message.hasOwnProperty("reservation")) {
                error = $root.mesos.Resource.ReservationInfo.verify(message.reservation);
                if (error)
                    return "reservation." + error;
            }
            if (message.disk != null && message.hasOwnProperty("disk")) {
                error = $root.mesos.Resource.DiskInfo.verify(message.disk);
                if (error)
                    return "disk." + error;
            }
            if (message.revocable != null && message.hasOwnProperty("revocable")) {
                error = $root.mesos.Resource.RevocableInfo.verify(message.revocable);
                if (error)
                    return "revocable." + error;
            }
            if (message.shared != null && message.hasOwnProperty("shared")) {
                error = $root.mesos.Resource.SharedInfo.verify(message.shared);
                if (error)
                    return "shared." + error;
            }
            return null;
        };

        /**
         * Creates a Resource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Resource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Resource} Resource
         */
        Resource.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Resource)
                return object;
            let message = new $root.mesos.Resource();
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            case "SCALAR":
            case 0:
                message.type = 0;
                break;
            case "RANGES":
            case 1:
                message.type = 1;
                break;
            case "SET":
            case 2:
                message.type = 2;
                break;
            case "TEXT":
            case 3:
                message.type = 3;
                break;
            }
            if (object.scalar != null) {
                if (typeof object.scalar !== "object")
                    throw TypeError(".mesos.Resource.scalar: object expected");
                message.scalar = $root.mesos.Value.Scalar.fromObject(object.scalar);
            }
            if (object.ranges != null) {
                if (typeof object.ranges !== "object")
                    throw TypeError(".mesos.Resource.ranges: object expected");
                message.ranges = $root.mesos.Value.Ranges.fromObject(object.ranges);
            }
            if (object.set != null) {
                if (typeof object.set !== "object")
                    throw TypeError(".mesos.Resource.set: object expected");
                message.set = $root.mesos.Value.Set.fromObject(object.set);
            }
            if (object.role != null)
                message.role = String(object.role);
            if (object.allocationInfo != null) {
                if (typeof object.allocationInfo !== "object")
                    throw TypeError(".mesos.Resource.allocationInfo: object expected");
                message.allocationInfo = $root.mesos.Resource.AllocationInfo.fromObject(object.allocationInfo);
            }
            if (object.reservation != null) {
                if (typeof object.reservation !== "object")
                    throw TypeError(".mesos.Resource.reservation: object expected");
                message.reservation = $root.mesos.Resource.ReservationInfo.fromObject(object.reservation);
            }
            if (object.disk != null) {
                if (typeof object.disk !== "object")
                    throw TypeError(".mesos.Resource.disk: object expected");
                message.disk = $root.mesos.Resource.DiskInfo.fromObject(object.disk);
            }
            if (object.revocable != null) {
                if (typeof object.revocable !== "object")
                    throw TypeError(".mesos.Resource.revocable: object expected");
                message.revocable = $root.mesos.Resource.RevocableInfo.fromObject(object.revocable);
            }
            if (object.shared != null) {
                if (typeof object.shared !== "object")
                    throw TypeError(".mesos.Resource.shared: object expected");
                message.shared = $root.mesos.Resource.SharedInfo.fromObject(object.shared);
            }
            return message;
        };

        /**
         * Creates a plain object from a Resource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Resource
         * @static
         * @param {mesos.Resource} message Resource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.type = options.enums === String ? "SCALAR" : 0;
                object.scalar = null;
                object.ranges = null;
                object.set = null;
                object.role = "*";
                object.disk = null;
                object.reservation = null;
                object.revocable = null;
                object.shared = null;
                object.allocationInfo = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.Value.Type[message.type] : message.type;
            if (message.scalar != null && message.hasOwnProperty("scalar"))
                object.scalar = $root.mesos.Value.Scalar.toObject(message.scalar, options);
            if (message.ranges != null && message.hasOwnProperty("ranges"))
                object.ranges = $root.mesos.Value.Ranges.toObject(message.ranges, options);
            if (message.set != null && message.hasOwnProperty("set"))
                object.set = $root.mesos.Value.Set.toObject(message.set, options);
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.disk != null && message.hasOwnProperty("disk"))
                object.disk = $root.mesos.Resource.DiskInfo.toObject(message.disk, options);
            if (message.reservation != null && message.hasOwnProperty("reservation"))
                object.reservation = $root.mesos.Resource.ReservationInfo.toObject(message.reservation, options);
            if (message.revocable != null && message.hasOwnProperty("revocable"))
                object.revocable = $root.mesos.Resource.RevocableInfo.toObject(message.revocable, options);
            if (message.shared != null && message.hasOwnProperty("shared"))
                object.shared = $root.mesos.Resource.SharedInfo.toObject(message.shared, options);
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo"))
                object.allocationInfo = $root.mesos.Resource.AllocationInfo.toObject(message.allocationInfo, options);
            return object;
        };

        /**
         * Converts this Resource to JSON.
         * @function toJSON
         * @memberof mesos.Resource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Resource.AllocationInfo = (function() {

            /**
             * Properties of an AllocationInfo.
             * @memberof mesos.Resource
             * @interface IAllocationInfo
             * @property {string} [role] AllocationInfo role
             */

            /**
             * Constructs a new AllocationInfo.
             * @memberof mesos.Resource
             * @classdesc Represents an AllocationInfo.
             * @constructor
             * @param {mesos.Resource.IAllocationInfo=} [properties] Properties to set
             */
            function AllocationInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AllocationInfo role.
             * @member {string}role
             * @memberof mesos.Resource.AllocationInfo
             * @instance
             */
            AllocationInfo.prototype.role = "";

            /**
             * Creates a new AllocationInfo instance using the specified properties.
             * @function create
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {mesos.Resource.IAllocationInfo=} [properties] Properties to set
             * @returns {mesos.Resource.AllocationInfo} AllocationInfo instance
             */
            AllocationInfo.create = function create(properties) {
                return new AllocationInfo(properties);
            };

            /**
             * Encodes the specified AllocationInfo message. Does not implicitly {@link mesos.Resource.AllocationInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {mesos.Resource.IAllocationInfo} message AllocationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllocationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.role != null && message.hasOwnProperty("role"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.role);
                return writer;
            };

            /**
             * Encodes the specified AllocationInfo message, length delimited. Does not implicitly {@link mesos.Resource.AllocationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {mesos.Resource.IAllocationInfo} message AllocationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AllocationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AllocationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Resource.AllocationInfo} AllocationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllocationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.AllocationInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.role = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AllocationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Resource.AllocationInfo} AllocationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AllocationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AllocationInfo message.
             * @function verify
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AllocationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!$util.isString(message.role))
                        return "role: string expected";
                return null;
            };

            /**
             * Creates an AllocationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Resource.AllocationInfo} AllocationInfo
             */
            AllocationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Resource.AllocationInfo)
                    return object;
                let message = new $root.mesos.Resource.AllocationInfo();
                if (object.role != null)
                    message.role = String(object.role);
                return message;
            };

            /**
             * Creates a plain object from an AllocationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Resource.AllocationInfo
             * @static
             * @param {mesos.Resource.AllocationInfo} message AllocationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AllocationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.role = "";
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = message.role;
                return object;
            };

            /**
             * Converts this AllocationInfo to JSON.
             * @function toJSON
             * @memberof mesos.Resource.AllocationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AllocationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AllocationInfo;
        })();

        Resource.ReservationInfo = (function() {

            /**
             * Properties of a ReservationInfo.
             * @memberof mesos.Resource
             * @interface IReservationInfo
             * @property {string} [principal] ReservationInfo principal
             * @property {mesos.ILabels} [labels] ReservationInfo labels
             */

            /**
             * Constructs a new ReservationInfo.
             * @memberof mesos.Resource
             * @classdesc Represents a ReservationInfo.
             * @constructor
             * @param {mesos.Resource.IReservationInfo=} [properties] Properties to set
             */
            function ReservationInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReservationInfo principal.
             * @member {string}principal
             * @memberof mesos.Resource.ReservationInfo
             * @instance
             */
            ReservationInfo.prototype.principal = "";

            /**
             * ReservationInfo labels.
             * @member {(mesos.ILabels|null|undefined)}labels
             * @memberof mesos.Resource.ReservationInfo
             * @instance
             */
            ReservationInfo.prototype.labels = null;

            /**
             * Creates a new ReservationInfo instance using the specified properties.
             * @function create
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {mesos.Resource.IReservationInfo=} [properties] Properties to set
             * @returns {mesos.Resource.ReservationInfo} ReservationInfo instance
             */
            ReservationInfo.create = function create(properties) {
                return new ReservationInfo(properties);
            };

            /**
             * Encodes the specified ReservationInfo message. Does not implicitly {@link mesos.Resource.ReservationInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {mesos.Resource.IReservationInfo} message ReservationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.principal != null && message.hasOwnProperty("principal"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.principal);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReservationInfo message, length delimited. Does not implicitly {@link mesos.Resource.ReservationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {mesos.Resource.IReservationInfo} message ReservationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReservationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReservationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Resource.ReservationInfo} ReservationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.ReservationInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.principal = reader.string();
                        break;
                    case 2:
                        message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReservationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Resource.ReservationInfo} ReservationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReservationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReservationInfo message.
             * @function verify
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReservationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.principal != null && message.hasOwnProperty("principal"))
                    if (!$util.isString(message.principal))
                        return "principal: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    let error = $root.mesos.Labels.verify(message.labels);
                    if (error)
                        return "labels." + error;
                }
                return null;
            };

            /**
             * Creates a ReservationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Resource.ReservationInfo} ReservationInfo
             */
            ReservationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Resource.ReservationInfo)
                    return object;
                let message = new $root.mesos.Resource.ReservationInfo();
                if (object.principal != null)
                    message.principal = String(object.principal);
                if (object.labels != null) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".mesos.Resource.ReservationInfo.labels: object expected");
                    message.labels = $root.mesos.Labels.fromObject(object.labels);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReservationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Resource.ReservationInfo
             * @static
             * @param {mesos.Resource.ReservationInfo} message ReservationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReservationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.principal = "";
                    object.labels = null;
                }
                if (message.principal != null && message.hasOwnProperty("principal"))
                    object.principal = message.principal;
                if (message.labels != null && message.hasOwnProperty("labels"))
                    object.labels = $root.mesos.Labels.toObject(message.labels, options);
                return object;
            };

            /**
             * Converts this ReservationInfo to JSON.
             * @function toJSON
             * @memberof mesos.Resource.ReservationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReservationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReservationInfo;
        })();

        Resource.DiskInfo = (function() {

            /**
             * Properties of a DiskInfo.
             * @memberof mesos.Resource
             * @interface IDiskInfo
             * @property {mesos.Resource.DiskInfo.IPersistence} [persistence] DiskInfo persistence
             * @property {mesos.IVolume} [volume] DiskInfo volume
             * @property {mesos.Resource.DiskInfo.ISource} [source] DiskInfo source
             */

            /**
             * Constructs a new DiskInfo.
             * @memberof mesos.Resource
             * @classdesc Represents a DiskInfo.
             * @constructor
             * @param {mesos.Resource.IDiskInfo=} [properties] Properties to set
             */
            function DiskInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiskInfo persistence.
             * @member {(mesos.Resource.DiskInfo.IPersistence|null|undefined)}persistence
             * @memberof mesos.Resource.DiskInfo
             * @instance
             */
            DiskInfo.prototype.persistence = null;

            /**
             * DiskInfo volume.
             * @member {(mesos.IVolume|null|undefined)}volume
             * @memberof mesos.Resource.DiskInfo
             * @instance
             */
            DiskInfo.prototype.volume = null;

            /**
             * DiskInfo source.
             * @member {(mesos.Resource.DiskInfo.ISource|null|undefined)}source
             * @memberof mesos.Resource.DiskInfo
             * @instance
             */
            DiskInfo.prototype.source = null;

            /**
             * Creates a new DiskInfo instance using the specified properties.
             * @function create
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {mesos.Resource.IDiskInfo=} [properties] Properties to set
             * @returns {mesos.Resource.DiskInfo} DiskInfo instance
             */
            DiskInfo.create = function create(properties) {
                return new DiskInfo(properties);
            };

            /**
             * Encodes the specified DiskInfo message. Does not implicitly {@link mesos.Resource.DiskInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {mesos.Resource.IDiskInfo} message DiskInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiskInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.persistence != null && message.hasOwnProperty("persistence"))
                    $root.mesos.Resource.DiskInfo.Persistence.encode(message.persistence, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.volume != null && message.hasOwnProperty("volume"))
                    $root.mesos.Volume.encode(message.volume, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.source != null && message.hasOwnProperty("source"))
                    $root.mesos.Resource.DiskInfo.Source.encode(message.source, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DiskInfo message, length delimited. Does not implicitly {@link mesos.Resource.DiskInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {mesos.Resource.IDiskInfo} message DiskInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiskInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiskInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Resource.DiskInfo} DiskInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiskInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.DiskInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.persistence = $root.mesos.Resource.DiskInfo.Persistence.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.volume = $root.mesos.Volume.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.source = $root.mesos.Resource.DiskInfo.Source.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiskInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Resource.DiskInfo} DiskInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiskInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiskInfo message.
             * @function verify
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiskInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.persistence != null && message.hasOwnProperty("persistence")) {
                    let error = $root.mesos.Resource.DiskInfo.Persistence.verify(message.persistence);
                    if (error)
                        return "persistence." + error;
                }
                if (message.volume != null && message.hasOwnProperty("volume")) {
                    error = $root.mesos.Volume.verify(message.volume);
                    if (error)
                        return "volume." + error;
                }
                if (message.source != null && message.hasOwnProperty("source")) {
                    error = $root.mesos.Resource.DiskInfo.Source.verify(message.source);
                    if (error)
                        return "source." + error;
                }
                return null;
            };

            /**
             * Creates a DiskInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Resource.DiskInfo} DiskInfo
             */
            DiskInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Resource.DiskInfo)
                    return object;
                let message = new $root.mesos.Resource.DiskInfo();
                if (object.persistence != null) {
                    if (typeof object.persistence !== "object")
                        throw TypeError(".mesos.Resource.DiskInfo.persistence: object expected");
                    message.persistence = $root.mesos.Resource.DiskInfo.Persistence.fromObject(object.persistence);
                }
                if (object.volume != null) {
                    if (typeof object.volume !== "object")
                        throw TypeError(".mesos.Resource.DiskInfo.volume: object expected");
                    message.volume = $root.mesos.Volume.fromObject(object.volume);
                }
                if (object.source != null) {
                    if (typeof object.source !== "object")
                        throw TypeError(".mesos.Resource.DiskInfo.source: object expected");
                    message.source = $root.mesos.Resource.DiskInfo.Source.fromObject(object.source);
                }
                return message;
            };

            /**
             * Creates a plain object from a DiskInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Resource.DiskInfo
             * @static
             * @param {mesos.Resource.DiskInfo} message DiskInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiskInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.persistence = null;
                    object.volume = null;
                    object.source = null;
                }
                if (message.persistence != null && message.hasOwnProperty("persistence"))
                    object.persistence = $root.mesos.Resource.DiskInfo.Persistence.toObject(message.persistence, options);
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = $root.mesos.Volume.toObject(message.volume, options);
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = $root.mesos.Resource.DiskInfo.Source.toObject(message.source, options);
                return object;
            };

            /**
             * Converts this DiskInfo to JSON.
             * @function toJSON
             * @memberof mesos.Resource.DiskInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiskInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DiskInfo.Persistence = (function() {

                /**
                 * Properties of a Persistence.
                 * @memberof mesos.Resource.DiskInfo
                 * @interface IPersistence
                 * @property {string} id Persistence id
                 * @property {string} [principal] Persistence principal
                 */

                /**
                 * Constructs a new Persistence.
                 * @memberof mesos.Resource.DiskInfo
                 * @classdesc Represents a Persistence.
                 * @constructor
                 * @param {mesos.Resource.DiskInfo.IPersistence=} [properties] Properties to set
                 */
                function Persistence(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Persistence id.
                 * @member {string}id
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @instance
                 */
                Persistence.prototype.id = "";

                /**
                 * Persistence principal.
                 * @member {string}principal
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @instance
                 */
                Persistence.prototype.principal = "";

                /**
                 * Creates a new Persistence instance using the specified properties.
                 * @function create
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {mesos.Resource.DiskInfo.IPersistence=} [properties] Properties to set
                 * @returns {mesos.Resource.DiskInfo.Persistence} Persistence instance
                 */
                Persistence.create = function create(properties) {
                    return new Persistence(properties);
                };

                /**
                 * Encodes the specified Persistence message. Does not implicitly {@link mesos.Resource.DiskInfo.Persistence.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {mesos.Resource.DiskInfo.IPersistence} message Persistence message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Persistence.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
                    return writer;
                };

                /**
                 * Encodes the specified Persistence message, length delimited. Does not implicitly {@link mesos.Resource.DiskInfo.Persistence.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {mesos.Resource.DiskInfo.IPersistence} message Persistence message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Persistence.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Persistence message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Resource.DiskInfo.Persistence} Persistence
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Persistence.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.DiskInfo.Persistence();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.principal = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("id"))
                        throw $util.ProtocolError("missing required 'id'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Persistence message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Resource.DiskInfo.Persistence} Persistence
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Persistence.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Persistence message.
                 * @function verify
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Persistence.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.id))
                        return "id: string expected";
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        if (!$util.isString(message.principal))
                            return "principal: string expected";
                    return null;
                };

                /**
                 * Creates a Persistence message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Resource.DiskInfo.Persistence} Persistence
                 */
                Persistence.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Resource.DiskInfo.Persistence)
                        return object;
                    let message = new $root.mesos.Resource.DiskInfo.Persistence();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.principal != null)
                        message.principal = String(object.principal);
                    return message;
                };

                /**
                 * Creates a plain object from a Persistence message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @static
                 * @param {mesos.Resource.DiskInfo.Persistence} message Persistence
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Persistence.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.principal = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.principal != null && message.hasOwnProperty("principal"))
                        object.principal = message.principal;
                    return object;
                };

                /**
                 * Converts this Persistence to JSON.
                 * @function toJSON
                 * @memberof mesos.Resource.DiskInfo.Persistence
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Persistence.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Persistence;
            })();

            DiskInfo.Source = (function() {

                /**
                 * Properties of a Source.
                 * @memberof mesos.Resource.DiskInfo
                 * @interface ISource
                 * @property {mesos.Resource.DiskInfo.Source.Type} type Source type
                 * @property {mesos.Resource.DiskInfo.Source.IPath} [path] Source path
                 * @property {mesos.Resource.DiskInfo.Source.IMount} [mount] Source mount
                 */

                /**
                 * Constructs a new Source.
                 * @memberof mesos.Resource.DiskInfo
                 * @classdesc Represents a Source.
                 * @constructor
                 * @param {mesos.Resource.DiskInfo.ISource=} [properties] Properties to set
                 */
                function Source(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Source type.
                 * @member {mesos.Resource.DiskInfo.Source.Type}type
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @instance
                 */
                Source.prototype.type = 1;

                /**
                 * Source path.
                 * @member {(mesos.Resource.DiskInfo.Source.IPath|null|undefined)}path
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @instance
                 */
                Source.prototype.path = null;

                /**
                 * Source mount.
                 * @member {(mesos.Resource.DiskInfo.Source.IMount|null|undefined)}mount
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @instance
                 */
                Source.prototype.mount = null;

                /**
                 * Creates a new Source instance using the specified properties.
                 * @function create
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {mesos.Resource.DiskInfo.ISource=} [properties] Properties to set
                 * @returns {mesos.Resource.DiskInfo.Source} Source instance
                 */
                Source.create = function create(properties) {
                    return new Source(properties);
                };

                /**
                 * Encodes the specified Source message. Does not implicitly {@link mesos.Resource.DiskInfo.Source.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {mesos.Resource.DiskInfo.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.path != null && message.hasOwnProperty("path"))
                        $root.mesos.Resource.DiskInfo.Source.Path.encode(message.path, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.mount != null && message.hasOwnProperty("mount"))
                        $root.mesos.Resource.DiskInfo.Source.Mount.encode(message.mount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Source message, length delimited. Does not implicitly {@link mesos.Resource.DiskInfo.Source.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {mesos.Resource.DiskInfo.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Source message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Resource.DiskInfo.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.DiskInfo.Source();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.path = $root.mesos.Resource.DiskInfo.Source.Path.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.mount = $root.mesos.Resource.DiskInfo.Source.Mount.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("type"))
                        throw $util.ProtocolError("missing required 'type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Source message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Resource.DiskInfo.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Source message.
                 * @function verify
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Source.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                    if (message.path != null && message.hasOwnProperty("path")) {
                        let error = $root.mesos.Resource.DiskInfo.Source.Path.verify(message.path);
                        if (error)
                            return "path." + error;
                    }
                    if (message.mount != null && message.hasOwnProperty("mount")) {
                        error = $root.mesos.Resource.DiskInfo.Source.Mount.verify(message.mount);
                        if (error)
                            return "mount." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Source message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Resource.DiskInfo.Source} Source
                 */
                Source.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Resource.DiskInfo.Source)
                        return object;
                    let message = new $root.mesos.Resource.DiskInfo.Source();
                    switch (object.type) {
                    case "PATH":
                    case 1:
                        message.type = 1;
                        break;
                    case "MOUNT":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.path != null) {
                        if (typeof object.path !== "object")
                            throw TypeError(".mesos.Resource.DiskInfo.Source.path: object expected");
                        message.path = $root.mesos.Resource.DiskInfo.Source.Path.fromObject(object.path);
                    }
                    if (object.mount != null) {
                        if (typeof object.mount !== "object")
                            throw TypeError(".mesos.Resource.DiskInfo.Source.mount: object expected");
                        message.mount = $root.mesos.Resource.DiskInfo.Source.Mount.fromObject(object.mount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Source message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @static
                 * @param {mesos.Resource.DiskInfo.Source} message Source
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Source.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "PATH" : 1;
                        object.path = null;
                        object.mount = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.mesos.Resource.DiskInfo.Source.Type[message.type] : message.type;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = $root.mesos.Resource.DiskInfo.Source.Path.toObject(message.path, options);
                    if (message.mount != null && message.hasOwnProperty("mount"))
                        object.mount = $root.mesos.Resource.DiskInfo.Source.Mount.toObject(message.mount, options);
                    return object;
                };

                /**
                 * Converts this Source to JSON.
                 * @function toJSON
                 * @memberof mesos.Resource.DiskInfo.Source
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Source.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @enum {string}
                 * @property {number} PATH=1 PATH value
                 * @property {number} MOUNT=2 MOUNT value
                 */
                Source.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "PATH"] = 1;
                    values[valuesById[2] = "MOUNT"] = 2;
                    return values;
                })();

                Source.Path = (function() {

                    /**
                     * Properties of a Path.
                     * @memberof mesos.Resource.DiskInfo.Source
                     * @interface IPath
                     * @property {string} root Path root
                     */

                    /**
                     * Constructs a new Path.
                     * @memberof mesos.Resource.DiskInfo.Source
                     * @classdesc Represents a Path.
                     * @constructor
                     * @param {mesos.Resource.DiskInfo.Source.IPath=} [properties] Properties to set
                     */
                    function Path(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Path root.
                     * @member {string}root
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @instance
                     */
                    Path.prototype.root = "";

                    /**
                     * Creates a new Path instance using the specified properties.
                     * @function create
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IPath=} [properties] Properties to set
                     * @returns {mesos.Resource.DiskInfo.Source.Path} Path instance
                     */
                    Path.create = function create(properties) {
                        return new Path(properties);
                    };

                    /**
                     * Encodes the specified Path message. Does not implicitly {@link mesos.Resource.DiskInfo.Source.Path.verify|verify} messages.
                     * @function encode
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IPath} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Path.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.root);
                        return writer;
                    };

                    /**
                     * Encodes the specified Path message, length delimited. Does not implicitly {@link mesos.Resource.DiskInfo.Source.Path.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IPath} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Path.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Path message from the specified reader or buffer.
                     * @function decode
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {mesos.Resource.DiskInfo.Source.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Path.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.DiskInfo.Source.Path();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.root = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("root"))
                            throw $util.ProtocolError("missing required 'root'", { instance: message });
                        return message;
                    };

                    /**
                     * Decodes a Path message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {mesos.Resource.DiskInfo.Source.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Path.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Path message.
                     * @function verify
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Path.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.root))
                            return "root: string expected";
                        return null;
                    };

                    /**
                     * Creates a Path message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {mesos.Resource.DiskInfo.Source.Path} Path
                     */
                    Path.fromObject = function fromObject(object) {
                        if (object instanceof $root.mesos.Resource.DiskInfo.Source.Path)
                            return object;
                        let message = new $root.mesos.Resource.DiskInfo.Source.Path();
                        if (object.root != null)
                            message.root = String(object.root);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Path message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.Path} message Path
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Path.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.root = "";
                        if (message.root != null && message.hasOwnProperty("root"))
                            object.root = message.root;
                        return object;
                    };

                    /**
                     * Converts this Path to JSON.
                     * @function toJSON
                     * @memberof mesos.Resource.DiskInfo.Source.Path
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Path.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Path;
                })();

                Source.Mount = (function() {

                    /**
                     * Properties of a Mount.
                     * @memberof mesos.Resource.DiskInfo.Source
                     * @interface IMount
                     * @property {string} root Mount root
                     */

                    /**
                     * Constructs a new Mount.
                     * @memberof mesos.Resource.DiskInfo.Source
                     * @classdesc Represents a Mount.
                     * @constructor
                     * @param {mesos.Resource.DiskInfo.Source.IMount=} [properties] Properties to set
                     */
                    function Mount(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Mount root.
                     * @member {string}root
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @instance
                     */
                    Mount.prototype.root = "";

                    /**
                     * Creates a new Mount instance using the specified properties.
                     * @function create
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IMount=} [properties] Properties to set
                     * @returns {mesos.Resource.DiskInfo.Source.Mount} Mount instance
                     */
                    Mount.create = function create(properties) {
                        return new Mount(properties);
                    };

                    /**
                     * Encodes the specified Mount message. Does not implicitly {@link mesos.Resource.DiskInfo.Source.Mount.verify|verify} messages.
                     * @function encode
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IMount} message Mount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Mount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.root);
                        return writer;
                    };

                    /**
                     * Encodes the specified Mount message, length delimited. Does not implicitly {@link mesos.Resource.DiskInfo.Source.Mount.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.IMount} message Mount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Mount.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Mount message from the specified reader or buffer.
                     * @function decode
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {mesos.Resource.DiskInfo.Source.Mount} Mount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Mount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.DiskInfo.Source.Mount();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.root = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("root"))
                            throw $util.ProtocolError("missing required 'root'", { instance: message });
                        return message;
                    };

                    /**
                     * Decodes a Mount message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {mesos.Resource.DiskInfo.Source.Mount} Mount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Mount.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Mount message.
                     * @function verify
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Mount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.root))
                            return "root: string expected";
                        return null;
                    };

                    /**
                     * Creates a Mount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {mesos.Resource.DiskInfo.Source.Mount} Mount
                     */
                    Mount.fromObject = function fromObject(object) {
                        if (object instanceof $root.mesos.Resource.DiskInfo.Source.Mount)
                            return object;
                        let message = new $root.mesos.Resource.DiskInfo.Source.Mount();
                        if (object.root != null)
                            message.root = String(object.root);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Mount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @static
                     * @param {mesos.Resource.DiskInfo.Source.Mount} message Mount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Mount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.root = "";
                        if (message.root != null && message.hasOwnProperty("root"))
                            object.root = message.root;
                        return object;
                    };

                    /**
                     * Converts this Mount to JSON.
                     * @function toJSON
                     * @memberof mesos.Resource.DiskInfo.Source.Mount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Mount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Mount;
                })();

                return Source;
            })();

            return DiskInfo;
        })();

        Resource.RevocableInfo = (function() {

            /**
             * Properties of a RevocableInfo.
             * @memberof mesos.Resource
             * @interface IRevocableInfo
             */

            /**
             * Constructs a new RevocableInfo.
             * @memberof mesos.Resource
             * @classdesc Represents a RevocableInfo.
             * @constructor
             * @param {mesos.Resource.IRevocableInfo=} [properties] Properties to set
             */
            function RevocableInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RevocableInfo instance using the specified properties.
             * @function create
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {mesos.Resource.IRevocableInfo=} [properties] Properties to set
             * @returns {mesos.Resource.RevocableInfo} RevocableInfo instance
             */
            RevocableInfo.create = function create(properties) {
                return new RevocableInfo(properties);
            };

            /**
             * Encodes the specified RevocableInfo message. Does not implicitly {@link mesos.Resource.RevocableInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {mesos.Resource.IRevocableInfo} message RevocableInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RevocableInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RevocableInfo message, length delimited. Does not implicitly {@link mesos.Resource.RevocableInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {mesos.Resource.IRevocableInfo} message RevocableInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RevocableInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RevocableInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Resource.RevocableInfo} RevocableInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RevocableInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.RevocableInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RevocableInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Resource.RevocableInfo} RevocableInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RevocableInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RevocableInfo message.
             * @function verify
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RevocableInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RevocableInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Resource.RevocableInfo} RevocableInfo
             */
            RevocableInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Resource.RevocableInfo)
                    return object;
                return new $root.mesos.Resource.RevocableInfo();
            };

            /**
             * Creates a plain object from a RevocableInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Resource.RevocableInfo
             * @static
             * @param {mesos.Resource.RevocableInfo} message RevocableInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RevocableInfo.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RevocableInfo to JSON.
             * @function toJSON
             * @memberof mesos.Resource.RevocableInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RevocableInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RevocableInfo;
        })();

        Resource.SharedInfo = (function() {

            /**
             * Properties of a SharedInfo.
             * @memberof mesos.Resource
             * @interface ISharedInfo
             */

            /**
             * Constructs a new SharedInfo.
             * @memberof mesos.Resource
             * @classdesc Represents a SharedInfo.
             * @constructor
             * @param {mesos.Resource.ISharedInfo=} [properties] Properties to set
             */
            function SharedInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SharedInfo instance using the specified properties.
             * @function create
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {mesos.Resource.ISharedInfo=} [properties] Properties to set
             * @returns {mesos.Resource.SharedInfo} SharedInfo instance
             */
            SharedInfo.create = function create(properties) {
                return new SharedInfo(properties);
            };

            /**
             * Encodes the specified SharedInfo message. Does not implicitly {@link mesos.Resource.SharedInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {mesos.Resource.ISharedInfo} message SharedInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SharedInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SharedInfo message, length delimited. Does not implicitly {@link mesos.Resource.SharedInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {mesos.Resource.ISharedInfo} message SharedInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SharedInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SharedInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Resource.SharedInfo} SharedInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SharedInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Resource.SharedInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SharedInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Resource.SharedInfo} SharedInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SharedInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SharedInfo message.
             * @function verify
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SharedInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SharedInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Resource.SharedInfo} SharedInfo
             */
            SharedInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Resource.SharedInfo)
                    return object;
                return new $root.mesos.Resource.SharedInfo();
            };

            /**
             * Creates a plain object from a SharedInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Resource.SharedInfo
             * @static
             * @param {mesos.Resource.SharedInfo} message SharedInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SharedInfo.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SharedInfo to JSON.
             * @function toJSON
             * @memberof mesos.Resource.SharedInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SharedInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SharedInfo;
        })();

        return Resource;
    })();

    mesos.TrafficControlStatistics = (function() {

        /**
         * Properties of a TrafficControlStatistics.
         * @memberof mesos
         * @interface ITrafficControlStatistics
         * @property {string} id TrafficControlStatistics id
         * @property {number} [backlog] TrafficControlStatistics backlog
         * @property {number} [bytes] TrafficControlStatistics bytes
         * @property {number} [drops] TrafficControlStatistics drops
         * @property {number} [overlimits] TrafficControlStatistics overlimits
         * @property {number} [packets] TrafficControlStatistics packets
         * @property {number} [qlen] TrafficControlStatistics qlen
         * @property {number} [ratebps] TrafficControlStatistics ratebps
         * @property {number} [ratepps] TrafficControlStatistics ratepps
         * @property {number} [requeues] TrafficControlStatistics requeues
         */

        /**
         * Constructs a new TrafficControlStatistics.
         * @memberof mesos
         * @classdesc When the network bandwidth caps are enabled and the container
         * is over its limit, outbound packets may be either delayed or
         * dropped completely either because it exceeds the maximum bandwidth
         * allocation for a single container (the cap) or because the combined
         * network traffic of multiple containers on the host exceeds the
         * transmit capacity of the host (the share). We can report the
         * following statistics for each of these conditions exported directly
         * from the Linux Traffic Control Queueing Discipline.
         * 
         * id         : name of the limiter, e.g. 'tx_bw_cap'
         * backlog    : number of packets currently delayed
         * bytes      : total bytes seen
         * drops      : number of packets dropped in total
         * overlimits : number of packets which exceeded allocation
         * packets    : total packets seen
         * qlen       : number of packets currently queued
         * rate_bps   : throughput in bytes/sec
         * rate_pps   : throughput in packets/sec
         * requeues   : number of times a packet has been delayed due to
         * locking or device contention issues
         * 
         * More information on the operation of Linux Traffic Control can be
         * found at http://www.lartc.org/lartc.html.
         * @constructor
         * @param {mesos.ITrafficControlStatistics=} [properties] Properties to set
         */
        function TrafficControlStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrafficControlStatistics id.
         * @member {string}id
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.id = "";

        /**
         * TrafficControlStatistics backlog.
         * @member {number}backlog
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.backlog = 0;

        /**
         * TrafficControlStatistics bytes.
         * @member {number}bytes
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.bytes = 0;

        /**
         * TrafficControlStatistics drops.
         * @member {number}drops
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.drops = 0;

        /**
         * TrafficControlStatistics overlimits.
         * @member {number}overlimits
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.overlimits = 0;

        /**
         * TrafficControlStatistics packets.
         * @member {number}packets
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.packets = 0;

        /**
         * TrafficControlStatistics qlen.
         * @member {number}qlen
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.qlen = 0;

        /**
         * TrafficControlStatistics ratebps.
         * @member {number}ratebps
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.ratebps = 0;

        /**
         * TrafficControlStatistics ratepps.
         * @member {number}ratepps
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.ratepps = 0;

        /**
         * TrafficControlStatistics requeues.
         * @member {number}requeues
         * @memberof mesos.TrafficControlStatistics
         * @instance
         */
        TrafficControlStatistics.prototype.requeues = 0;

        /**
         * Creates a new TrafficControlStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {mesos.ITrafficControlStatistics=} [properties] Properties to set
         * @returns {mesos.TrafficControlStatistics} TrafficControlStatistics instance
         */
        TrafficControlStatistics.create = function create(properties) {
            return new TrafficControlStatistics(properties);
        };

        /**
         * Encodes the specified TrafficControlStatistics message. Does not implicitly {@link mesos.TrafficControlStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {mesos.ITrafficControlStatistics} message TrafficControlStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficControlStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.backlog != null && message.hasOwnProperty("backlog"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.backlog);
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.bytes);
            if (message.drops != null && message.hasOwnProperty("drops"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.drops);
            if (message.overlimits != null && message.hasOwnProperty("overlimits"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.overlimits);
            if (message.packets != null && message.hasOwnProperty("packets"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.packets);
            if (message.qlen != null && message.hasOwnProperty("qlen"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.qlen);
            if (message.ratebps != null && message.hasOwnProperty("ratebps"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.ratebps);
            if (message.ratepps != null && message.hasOwnProperty("ratepps"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ratepps);
            if (message.requeues != null && message.hasOwnProperty("requeues"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.requeues);
            return writer;
        };

        /**
         * Encodes the specified TrafficControlStatistics message, length delimited. Does not implicitly {@link mesos.TrafficControlStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {mesos.ITrafficControlStatistics} message TrafficControlStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficControlStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrafficControlStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TrafficControlStatistics} TrafficControlStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficControlStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TrafficControlStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.backlog = reader.uint32();
                    break;
                case 3:
                    message.bytes = reader.uint32();
                    break;
                case 4:
                    message.drops = reader.uint32();
                    break;
                case 5:
                    message.overlimits = reader.uint32();
                    break;
                case 6:
                    message.packets = reader.uint32();
                    break;
                case 7:
                    message.qlen = reader.uint32();
                    break;
                case 8:
                    message.ratebps = reader.uint32();
                    break;
                case 9:
                    message.ratepps = reader.uint32();
                    break;
                case 10:
                    message.requeues = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrafficControlStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TrafficControlStatistics} TrafficControlStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficControlStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrafficControlStatistics message.
         * @function verify
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrafficControlStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (message.backlog != null && message.hasOwnProperty("backlog"))
                if (!$util.isInteger(message.backlog))
                    return "backlog: integer expected";
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (!$util.isInteger(message.bytes))
                    return "bytes: integer expected";
            if (message.drops != null && message.hasOwnProperty("drops"))
                if (!$util.isInteger(message.drops))
                    return "drops: integer expected";
            if (message.overlimits != null && message.hasOwnProperty("overlimits"))
                if (!$util.isInteger(message.overlimits))
                    return "overlimits: integer expected";
            if (message.packets != null && message.hasOwnProperty("packets"))
                if (!$util.isInteger(message.packets))
                    return "packets: integer expected";
            if (message.qlen != null && message.hasOwnProperty("qlen"))
                if (!$util.isInteger(message.qlen))
                    return "qlen: integer expected";
            if (message.ratebps != null && message.hasOwnProperty("ratebps"))
                if (!$util.isInteger(message.ratebps))
                    return "ratebps: integer expected";
            if (message.ratepps != null && message.hasOwnProperty("ratepps"))
                if (!$util.isInteger(message.ratepps))
                    return "ratepps: integer expected";
            if (message.requeues != null && message.hasOwnProperty("requeues"))
                if (!$util.isInteger(message.requeues))
                    return "requeues: integer expected";
            return null;
        };

        /**
         * Creates a TrafficControlStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TrafficControlStatistics} TrafficControlStatistics
         */
        TrafficControlStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TrafficControlStatistics)
                return object;
            let message = new $root.mesos.TrafficControlStatistics();
            if (object.id != null)
                message.id = String(object.id);
            if (object.backlog != null)
                message.backlog = object.backlog >>> 0;
            if (object.bytes != null)
                message.bytes = object.bytes >>> 0;
            if (object.drops != null)
                message.drops = object.drops >>> 0;
            if (object.overlimits != null)
                message.overlimits = object.overlimits >>> 0;
            if (object.packets != null)
                message.packets = object.packets >>> 0;
            if (object.qlen != null)
                message.qlen = object.qlen >>> 0;
            if (object.ratebps != null)
                message.ratebps = object.ratebps >>> 0;
            if (object.ratepps != null)
                message.ratepps = object.ratepps >>> 0;
            if (object.requeues != null)
                message.requeues = object.requeues >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TrafficControlStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TrafficControlStatistics
         * @static
         * @param {mesos.TrafficControlStatistics} message TrafficControlStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrafficControlStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.backlog = 0;
                object.bytes = 0;
                object.drops = 0;
                object.overlimits = 0;
                object.packets = 0;
                object.qlen = 0;
                object.ratebps = 0;
                object.ratepps = 0;
                object.requeues = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.backlog != null && message.hasOwnProperty("backlog"))
                object.backlog = message.backlog;
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                object.bytes = message.bytes;
            if (message.drops != null && message.hasOwnProperty("drops"))
                object.drops = message.drops;
            if (message.overlimits != null && message.hasOwnProperty("overlimits"))
                object.overlimits = message.overlimits;
            if (message.packets != null && message.hasOwnProperty("packets"))
                object.packets = message.packets;
            if (message.qlen != null && message.hasOwnProperty("qlen"))
                object.qlen = message.qlen;
            if (message.ratebps != null && message.hasOwnProperty("ratebps"))
                object.ratebps = message.ratebps;
            if (message.ratepps != null && message.hasOwnProperty("ratepps"))
                object.ratepps = message.ratepps;
            if (message.requeues != null && message.hasOwnProperty("requeues"))
                object.requeues = message.requeues;
            return object;
        };

        /**
         * Converts this TrafficControlStatistics to JSON.
         * @function toJSON
         * @memberof mesos.TrafficControlStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrafficControlStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrafficControlStatistics;
    })();

    mesos.IpStatistics = (function() {

        /**
         * Properties of an IpStatistics.
         * @memberof mesos
         * @interface IIpStatistics
         * @property {number|Long} [Forwarding] IpStatistics Forwarding
         * @property {number|Long} [DefaultTTL] IpStatistics DefaultTTL
         * @property {number|Long} [InReceives] IpStatistics InReceives
         * @property {number|Long} [InHdrErrors] IpStatistics InHdrErrors
         * @property {number|Long} [InAddrErrors] IpStatistics InAddrErrors
         * @property {number|Long} [ForwDatagrams] IpStatistics ForwDatagrams
         * @property {number|Long} [InUnknownProtos] IpStatistics InUnknownProtos
         * @property {number|Long} [InDiscards] IpStatistics InDiscards
         * @property {number|Long} [InDelivers] IpStatistics InDelivers
         * @property {number|Long} [OutRequests] IpStatistics OutRequests
         * @property {number|Long} [OutDiscards] IpStatistics OutDiscards
         * @property {number|Long} [OutNoRoutes] IpStatistics OutNoRoutes
         * @property {number|Long} [ReasmTimeout] IpStatistics ReasmTimeout
         * @property {number|Long} [ReasmReqds] IpStatistics ReasmReqds
         * @property {number|Long} [ReasmOKs] IpStatistics ReasmOKs
         * @property {number|Long} [ReasmFails] IpStatistics ReasmFails
         * @property {number|Long} [FragOKs] IpStatistics FragOKs
         * @property {number|Long} [FragFails] IpStatistics FragFails
         * @property {number|Long} [FragCreates] IpStatistics FragCreates
         */

        /**
         * Constructs a new IpStatistics.
         * @memberof mesos
         * @classdesc Represents an IpStatistics.
         * @constructor
         * @param {mesos.IIpStatistics=} [properties] Properties to set
         */
        function IpStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IpStatistics Forwarding.
         * @member {number|Long}Forwarding
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.Forwarding = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics DefaultTTL.
         * @member {number|Long}DefaultTTL
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.DefaultTTL = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InReceives.
         * @member {number|Long}InReceives
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InReceives = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InHdrErrors.
         * @member {number|Long}InHdrErrors
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InHdrErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InAddrErrors.
         * @member {number|Long}InAddrErrors
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InAddrErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics ForwDatagrams.
         * @member {number|Long}ForwDatagrams
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.ForwDatagrams = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InUnknownProtos.
         * @member {number|Long}InUnknownProtos
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InUnknownProtos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InDiscards.
         * @member {number|Long}InDiscards
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InDiscards = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics InDelivers.
         * @member {number|Long}InDelivers
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.InDelivers = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics OutRequests.
         * @member {number|Long}OutRequests
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.OutRequests = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics OutDiscards.
         * @member {number|Long}OutDiscards
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.OutDiscards = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics OutNoRoutes.
         * @member {number|Long}OutNoRoutes
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.OutNoRoutes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics ReasmTimeout.
         * @member {number|Long}ReasmTimeout
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.ReasmTimeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics ReasmReqds.
         * @member {number|Long}ReasmReqds
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.ReasmReqds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics ReasmOKs.
         * @member {number|Long}ReasmOKs
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.ReasmOKs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics ReasmFails.
         * @member {number|Long}ReasmFails
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.ReasmFails = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics FragOKs.
         * @member {number|Long}FragOKs
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.FragOKs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics FragFails.
         * @member {number|Long}FragFails
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.FragFails = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpStatistics FragCreates.
         * @member {number|Long}FragCreates
         * @memberof mesos.IpStatistics
         * @instance
         */
        IpStatistics.prototype.FragCreates = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IpStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.IpStatistics
         * @static
         * @param {mesos.IIpStatistics=} [properties] Properties to set
         * @returns {mesos.IpStatistics} IpStatistics instance
         */
        IpStatistics.create = function create(properties) {
            return new IpStatistics(properties);
        };

        /**
         * Encodes the specified IpStatistics message. Does not implicitly {@link mesos.IpStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.IpStatistics
         * @static
         * @param {mesos.IIpStatistics} message IpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Forwarding != null && message.hasOwnProperty("Forwarding"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Forwarding);
            if (message.DefaultTTL != null && message.hasOwnProperty("DefaultTTL"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.DefaultTTL);
            if (message.InReceives != null && message.hasOwnProperty("InReceives"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.InReceives);
            if (message.InHdrErrors != null && message.hasOwnProperty("InHdrErrors"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.InHdrErrors);
            if (message.InAddrErrors != null && message.hasOwnProperty("InAddrErrors"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.InAddrErrors);
            if (message.ForwDatagrams != null && message.hasOwnProperty("ForwDatagrams"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.ForwDatagrams);
            if (message.InUnknownProtos != null && message.hasOwnProperty("InUnknownProtos"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.InUnknownProtos);
            if (message.InDiscards != null && message.hasOwnProperty("InDiscards"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.InDiscards);
            if (message.InDelivers != null && message.hasOwnProperty("InDelivers"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.InDelivers);
            if (message.OutRequests != null && message.hasOwnProperty("OutRequests"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.OutRequests);
            if (message.OutDiscards != null && message.hasOwnProperty("OutDiscards"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.OutDiscards);
            if (message.OutNoRoutes != null && message.hasOwnProperty("OutNoRoutes"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.OutNoRoutes);
            if (message.ReasmTimeout != null && message.hasOwnProperty("ReasmTimeout"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.ReasmTimeout);
            if (message.ReasmReqds != null && message.hasOwnProperty("ReasmReqds"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.ReasmReqds);
            if (message.ReasmOKs != null && message.hasOwnProperty("ReasmOKs"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.ReasmOKs);
            if (message.ReasmFails != null && message.hasOwnProperty("ReasmFails"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.ReasmFails);
            if (message.FragOKs != null && message.hasOwnProperty("FragOKs"))
                writer.uint32(/* id 17, wireType 0 =*/136).int64(message.FragOKs);
            if (message.FragFails != null && message.hasOwnProperty("FragFails"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.FragFails);
            if (message.FragCreates != null && message.hasOwnProperty("FragCreates"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.FragCreates);
            return writer;
        };

        /**
         * Encodes the specified IpStatistics message, length delimited. Does not implicitly {@link mesos.IpStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.IpStatistics
         * @static
         * @param {mesos.IIpStatistics} message IpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IpStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.IpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.IpStatistics} IpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.IpStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Forwarding = reader.int64();
                    break;
                case 2:
                    message.DefaultTTL = reader.int64();
                    break;
                case 3:
                    message.InReceives = reader.int64();
                    break;
                case 4:
                    message.InHdrErrors = reader.int64();
                    break;
                case 5:
                    message.InAddrErrors = reader.int64();
                    break;
                case 6:
                    message.ForwDatagrams = reader.int64();
                    break;
                case 7:
                    message.InUnknownProtos = reader.int64();
                    break;
                case 8:
                    message.InDiscards = reader.int64();
                    break;
                case 9:
                    message.InDelivers = reader.int64();
                    break;
                case 10:
                    message.OutRequests = reader.int64();
                    break;
                case 11:
                    message.OutDiscards = reader.int64();
                    break;
                case 12:
                    message.OutNoRoutes = reader.int64();
                    break;
                case 13:
                    message.ReasmTimeout = reader.int64();
                    break;
                case 14:
                    message.ReasmReqds = reader.int64();
                    break;
                case 15:
                    message.ReasmOKs = reader.int64();
                    break;
                case 16:
                    message.ReasmFails = reader.int64();
                    break;
                case 17:
                    message.FragOKs = reader.int64();
                    break;
                case 18:
                    message.FragFails = reader.int64();
                    break;
                case 19:
                    message.FragCreates = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IpStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.IpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.IpStatistics} IpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IpStatistics message.
         * @function verify
         * @memberof mesos.IpStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IpStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Forwarding != null && message.hasOwnProperty("Forwarding"))
                if (!$util.isInteger(message.Forwarding) && !(message.Forwarding && $util.isInteger(message.Forwarding.low) && $util.isInteger(message.Forwarding.high)))
                    return "Forwarding: integer|Long expected";
            if (message.DefaultTTL != null && message.hasOwnProperty("DefaultTTL"))
                if (!$util.isInteger(message.DefaultTTL) && !(message.DefaultTTL && $util.isInteger(message.DefaultTTL.low) && $util.isInteger(message.DefaultTTL.high)))
                    return "DefaultTTL: integer|Long expected";
            if (message.InReceives != null && message.hasOwnProperty("InReceives"))
                if (!$util.isInteger(message.InReceives) && !(message.InReceives && $util.isInteger(message.InReceives.low) && $util.isInteger(message.InReceives.high)))
                    return "InReceives: integer|Long expected";
            if (message.InHdrErrors != null && message.hasOwnProperty("InHdrErrors"))
                if (!$util.isInteger(message.InHdrErrors) && !(message.InHdrErrors && $util.isInteger(message.InHdrErrors.low) && $util.isInteger(message.InHdrErrors.high)))
                    return "InHdrErrors: integer|Long expected";
            if (message.InAddrErrors != null && message.hasOwnProperty("InAddrErrors"))
                if (!$util.isInteger(message.InAddrErrors) && !(message.InAddrErrors && $util.isInteger(message.InAddrErrors.low) && $util.isInteger(message.InAddrErrors.high)))
                    return "InAddrErrors: integer|Long expected";
            if (message.ForwDatagrams != null && message.hasOwnProperty("ForwDatagrams"))
                if (!$util.isInteger(message.ForwDatagrams) && !(message.ForwDatagrams && $util.isInteger(message.ForwDatagrams.low) && $util.isInteger(message.ForwDatagrams.high)))
                    return "ForwDatagrams: integer|Long expected";
            if (message.InUnknownProtos != null && message.hasOwnProperty("InUnknownProtos"))
                if (!$util.isInteger(message.InUnknownProtos) && !(message.InUnknownProtos && $util.isInteger(message.InUnknownProtos.low) && $util.isInteger(message.InUnknownProtos.high)))
                    return "InUnknownProtos: integer|Long expected";
            if (message.InDiscards != null && message.hasOwnProperty("InDiscards"))
                if (!$util.isInteger(message.InDiscards) && !(message.InDiscards && $util.isInteger(message.InDiscards.low) && $util.isInteger(message.InDiscards.high)))
                    return "InDiscards: integer|Long expected";
            if (message.InDelivers != null && message.hasOwnProperty("InDelivers"))
                if (!$util.isInteger(message.InDelivers) && !(message.InDelivers && $util.isInteger(message.InDelivers.low) && $util.isInteger(message.InDelivers.high)))
                    return "InDelivers: integer|Long expected";
            if (message.OutRequests != null && message.hasOwnProperty("OutRequests"))
                if (!$util.isInteger(message.OutRequests) && !(message.OutRequests && $util.isInteger(message.OutRequests.low) && $util.isInteger(message.OutRequests.high)))
                    return "OutRequests: integer|Long expected";
            if (message.OutDiscards != null && message.hasOwnProperty("OutDiscards"))
                if (!$util.isInteger(message.OutDiscards) && !(message.OutDiscards && $util.isInteger(message.OutDiscards.low) && $util.isInteger(message.OutDiscards.high)))
                    return "OutDiscards: integer|Long expected";
            if (message.OutNoRoutes != null && message.hasOwnProperty("OutNoRoutes"))
                if (!$util.isInteger(message.OutNoRoutes) && !(message.OutNoRoutes && $util.isInteger(message.OutNoRoutes.low) && $util.isInteger(message.OutNoRoutes.high)))
                    return "OutNoRoutes: integer|Long expected";
            if (message.ReasmTimeout != null && message.hasOwnProperty("ReasmTimeout"))
                if (!$util.isInteger(message.ReasmTimeout) && !(message.ReasmTimeout && $util.isInteger(message.ReasmTimeout.low) && $util.isInteger(message.ReasmTimeout.high)))
                    return "ReasmTimeout: integer|Long expected";
            if (message.ReasmReqds != null && message.hasOwnProperty("ReasmReqds"))
                if (!$util.isInteger(message.ReasmReqds) && !(message.ReasmReqds && $util.isInteger(message.ReasmReqds.low) && $util.isInteger(message.ReasmReqds.high)))
                    return "ReasmReqds: integer|Long expected";
            if (message.ReasmOKs != null && message.hasOwnProperty("ReasmOKs"))
                if (!$util.isInteger(message.ReasmOKs) && !(message.ReasmOKs && $util.isInteger(message.ReasmOKs.low) && $util.isInteger(message.ReasmOKs.high)))
                    return "ReasmOKs: integer|Long expected";
            if (message.ReasmFails != null && message.hasOwnProperty("ReasmFails"))
                if (!$util.isInteger(message.ReasmFails) && !(message.ReasmFails && $util.isInteger(message.ReasmFails.low) && $util.isInteger(message.ReasmFails.high)))
                    return "ReasmFails: integer|Long expected";
            if (message.FragOKs != null && message.hasOwnProperty("FragOKs"))
                if (!$util.isInteger(message.FragOKs) && !(message.FragOKs && $util.isInteger(message.FragOKs.low) && $util.isInteger(message.FragOKs.high)))
                    return "FragOKs: integer|Long expected";
            if (message.FragFails != null && message.hasOwnProperty("FragFails"))
                if (!$util.isInteger(message.FragFails) && !(message.FragFails && $util.isInteger(message.FragFails.low) && $util.isInteger(message.FragFails.high)))
                    return "FragFails: integer|Long expected";
            if (message.FragCreates != null && message.hasOwnProperty("FragCreates"))
                if (!$util.isInteger(message.FragCreates) && !(message.FragCreates && $util.isInteger(message.FragCreates.low) && $util.isInteger(message.FragCreates.high)))
                    return "FragCreates: integer|Long expected";
            return null;
        };

        /**
         * Creates an IpStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.IpStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.IpStatistics} IpStatistics
         */
        IpStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.IpStatistics)
                return object;
            let message = new $root.mesos.IpStatistics();
            if (object.Forwarding != null)
                if ($util.Long)
                    (message.Forwarding = $util.Long.fromValue(object.Forwarding)).unsigned = false;
                else if (typeof object.Forwarding === "string")
                    message.Forwarding = parseInt(object.Forwarding, 10);
                else if (typeof object.Forwarding === "number")
                    message.Forwarding = object.Forwarding;
                else if (typeof object.Forwarding === "object")
                    message.Forwarding = new $util.LongBits(object.Forwarding.low >>> 0, object.Forwarding.high >>> 0).toNumber();
            if (object.DefaultTTL != null)
                if ($util.Long)
                    (message.DefaultTTL = $util.Long.fromValue(object.DefaultTTL)).unsigned = false;
                else if (typeof object.DefaultTTL === "string")
                    message.DefaultTTL = parseInt(object.DefaultTTL, 10);
                else if (typeof object.DefaultTTL === "number")
                    message.DefaultTTL = object.DefaultTTL;
                else if (typeof object.DefaultTTL === "object")
                    message.DefaultTTL = new $util.LongBits(object.DefaultTTL.low >>> 0, object.DefaultTTL.high >>> 0).toNumber();
            if (object.InReceives != null)
                if ($util.Long)
                    (message.InReceives = $util.Long.fromValue(object.InReceives)).unsigned = false;
                else if (typeof object.InReceives === "string")
                    message.InReceives = parseInt(object.InReceives, 10);
                else if (typeof object.InReceives === "number")
                    message.InReceives = object.InReceives;
                else if (typeof object.InReceives === "object")
                    message.InReceives = new $util.LongBits(object.InReceives.low >>> 0, object.InReceives.high >>> 0).toNumber();
            if (object.InHdrErrors != null)
                if ($util.Long)
                    (message.InHdrErrors = $util.Long.fromValue(object.InHdrErrors)).unsigned = false;
                else if (typeof object.InHdrErrors === "string")
                    message.InHdrErrors = parseInt(object.InHdrErrors, 10);
                else if (typeof object.InHdrErrors === "number")
                    message.InHdrErrors = object.InHdrErrors;
                else if (typeof object.InHdrErrors === "object")
                    message.InHdrErrors = new $util.LongBits(object.InHdrErrors.low >>> 0, object.InHdrErrors.high >>> 0).toNumber();
            if (object.InAddrErrors != null)
                if ($util.Long)
                    (message.InAddrErrors = $util.Long.fromValue(object.InAddrErrors)).unsigned = false;
                else if (typeof object.InAddrErrors === "string")
                    message.InAddrErrors = parseInt(object.InAddrErrors, 10);
                else if (typeof object.InAddrErrors === "number")
                    message.InAddrErrors = object.InAddrErrors;
                else if (typeof object.InAddrErrors === "object")
                    message.InAddrErrors = new $util.LongBits(object.InAddrErrors.low >>> 0, object.InAddrErrors.high >>> 0).toNumber();
            if (object.ForwDatagrams != null)
                if ($util.Long)
                    (message.ForwDatagrams = $util.Long.fromValue(object.ForwDatagrams)).unsigned = false;
                else if (typeof object.ForwDatagrams === "string")
                    message.ForwDatagrams = parseInt(object.ForwDatagrams, 10);
                else if (typeof object.ForwDatagrams === "number")
                    message.ForwDatagrams = object.ForwDatagrams;
                else if (typeof object.ForwDatagrams === "object")
                    message.ForwDatagrams = new $util.LongBits(object.ForwDatagrams.low >>> 0, object.ForwDatagrams.high >>> 0).toNumber();
            if (object.InUnknownProtos != null)
                if ($util.Long)
                    (message.InUnknownProtos = $util.Long.fromValue(object.InUnknownProtos)).unsigned = false;
                else if (typeof object.InUnknownProtos === "string")
                    message.InUnknownProtos = parseInt(object.InUnknownProtos, 10);
                else if (typeof object.InUnknownProtos === "number")
                    message.InUnknownProtos = object.InUnknownProtos;
                else if (typeof object.InUnknownProtos === "object")
                    message.InUnknownProtos = new $util.LongBits(object.InUnknownProtos.low >>> 0, object.InUnknownProtos.high >>> 0).toNumber();
            if (object.InDiscards != null)
                if ($util.Long)
                    (message.InDiscards = $util.Long.fromValue(object.InDiscards)).unsigned = false;
                else if (typeof object.InDiscards === "string")
                    message.InDiscards = parseInt(object.InDiscards, 10);
                else if (typeof object.InDiscards === "number")
                    message.InDiscards = object.InDiscards;
                else if (typeof object.InDiscards === "object")
                    message.InDiscards = new $util.LongBits(object.InDiscards.low >>> 0, object.InDiscards.high >>> 0).toNumber();
            if (object.InDelivers != null)
                if ($util.Long)
                    (message.InDelivers = $util.Long.fromValue(object.InDelivers)).unsigned = false;
                else if (typeof object.InDelivers === "string")
                    message.InDelivers = parseInt(object.InDelivers, 10);
                else if (typeof object.InDelivers === "number")
                    message.InDelivers = object.InDelivers;
                else if (typeof object.InDelivers === "object")
                    message.InDelivers = new $util.LongBits(object.InDelivers.low >>> 0, object.InDelivers.high >>> 0).toNumber();
            if (object.OutRequests != null)
                if ($util.Long)
                    (message.OutRequests = $util.Long.fromValue(object.OutRequests)).unsigned = false;
                else if (typeof object.OutRequests === "string")
                    message.OutRequests = parseInt(object.OutRequests, 10);
                else if (typeof object.OutRequests === "number")
                    message.OutRequests = object.OutRequests;
                else if (typeof object.OutRequests === "object")
                    message.OutRequests = new $util.LongBits(object.OutRequests.low >>> 0, object.OutRequests.high >>> 0).toNumber();
            if (object.OutDiscards != null)
                if ($util.Long)
                    (message.OutDiscards = $util.Long.fromValue(object.OutDiscards)).unsigned = false;
                else if (typeof object.OutDiscards === "string")
                    message.OutDiscards = parseInt(object.OutDiscards, 10);
                else if (typeof object.OutDiscards === "number")
                    message.OutDiscards = object.OutDiscards;
                else if (typeof object.OutDiscards === "object")
                    message.OutDiscards = new $util.LongBits(object.OutDiscards.low >>> 0, object.OutDiscards.high >>> 0).toNumber();
            if (object.OutNoRoutes != null)
                if ($util.Long)
                    (message.OutNoRoutes = $util.Long.fromValue(object.OutNoRoutes)).unsigned = false;
                else if (typeof object.OutNoRoutes === "string")
                    message.OutNoRoutes = parseInt(object.OutNoRoutes, 10);
                else if (typeof object.OutNoRoutes === "number")
                    message.OutNoRoutes = object.OutNoRoutes;
                else if (typeof object.OutNoRoutes === "object")
                    message.OutNoRoutes = new $util.LongBits(object.OutNoRoutes.low >>> 0, object.OutNoRoutes.high >>> 0).toNumber();
            if (object.ReasmTimeout != null)
                if ($util.Long)
                    (message.ReasmTimeout = $util.Long.fromValue(object.ReasmTimeout)).unsigned = false;
                else if (typeof object.ReasmTimeout === "string")
                    message.ReasmTimeout = parseInt(object.ReasmTimeout, 10);
                else if (typeof object.ReasmTimeout === "number")
                    message.ReasmTimeout = object.ReasmTimeout;
                else if (typeof object.ReasmTimeout === "object")
                    message.ReasmTimeout = new $util.LongBits(object.ReasmTimeout.low >>> 0, object.ReasmTimeout.high >>> 0).toNumber();
            if (object.ReasmReqds != null)
                if ($util.Long)
                    (message.ReasmReqds = $util.Long.fromValue(object.ReasmReqds)).unsigned = false;
                else if (typeof object.ReasmReqds === "string")
                    message.ReasmReqds = parseInt(object.ReasmReqds, 10);
                else if (typeof object.ReasmReqds === "number")
                    message.ReasmReqds = object.ReasmReqds;
                else if (typeof object.ReasmReqds === "object")
                    message.ReasmReqds = new $util.LongBits(object.ReasmReqds.low >>> 0, object.ReasmReqds.high >>> 0).toNumber();
            if (object.ReasmOKs != null)
                if ($util.Long)
                    (message.ReasmOKs = $util.Long.fromValue(object.ReasmOKs)).unsigned = false;
                else if (typeof object.ReasmOKs === "string")
                    message.ReasmOKs = parseInt(object.ReasmOKs, 10);
                else if (typeof object.ReasmOKs === "number")
                    message.ReasmOKs = object.ReasmOKs;
                else if (typeof object.ReasmOKs === "object")
                    message.ReasmOKs = new $util.LongBits(object.ReasmOKs.low >>> 0, object.ReasmOKs.high >>> 0).toNumber();
            if (object.ReasmFails != null)
                if ($util.Long)
                    (message.ReasmFails = $util.Long.fromValue(object.ReasmFails)).unsigned = false;
                else if (typeof object.ReasmFails === "string")
                    message.ReasmFails = parseInt(object.ReasmFails, 10);
                else if (typeof object.ReasmFails === "number")
                    message.ReasmFails = object.ReasmFails;
                else if (typeof object.ReasmFails === "object")
                    message.ReasmFails = new $util.LongBits(object.ReasmFails.low >>> 0, object.ReasmFails.high >>> 0).toNumber();
            if (object.FragOKs != null)
                if ($util.Long)
                    (message.FragOKs = $util.Long.fromValue(object.FragOKs)).unsigned = false;
                else if (typeof object.FragOKs === "string")
                    message.FragOKs = parseInt(object.FragOKs, 10);
                else if (typeof object.FragOKs === "number")
                    message.FragOKs = object.FragOKs;
                else if (typeof object.FragOKs === "object")
                    message.FragOKs = new $util.LongBits(object.FragOKs.low >>> 0, object.FragOKs.high >>> 0).toNumber();
            if (object.FragFails != null)
                if ($util.Long)
                    (message.FragFails = $util.Long.fromValue(object.FragFails)).unsigned = false;
                else if (typeof object.FragFails === "string")
                    message.FragFails = parseInt(object.FragFails, 10);
                else if (typeof object.FragFails === "number")
                    message.FragFails = object.FragFails;
                else if (typeof object.FragFails === "object")
                    message.FragFails = new $util.LongBits(object.FragFails.low >>> 0, object.FragFails.high >>> 0).toNumber();
            if (object.FragCreates != null)
                if ($util.Long)
                    (message.FragCreates = $util.Long.fromValue(object.FragCreates)).unsigned = false;
                else if (typeof object.FragCreates === "string")
                    message.FragCreates = parseInt(object.FragCreates, 10);
                else if (typeof object.FragCreates === "number")
                    message.FragCreates = object.FragCreates;
                else if (typeof object.FragCreates === "object")
                    message.FragCreates = new $util.LongBits(object.FragCreates.low >>> 0, object.FragCreates.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IpStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.IpStatistics
         * @static
         * @param {mesos.IpStatistics} message IpStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IpStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.Forwarding = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Forwarding = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.DefaultTTL = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.DefaultTTL = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InReceives = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InReceives = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InHdrErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InHdrErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InAddrErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InAddrErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ForwDatagrams = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ForwDatagrams = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InUnknownProtos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InUnknownProtos = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InDiscards = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InDiscards = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InDelivers = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InDelivers = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutRequests = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutRequests = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutDiscards = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutDiscards = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutNoRoutes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutNoRoutes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ReasmTimeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ReasmTimeout = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ReasmReqds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ReasmReqds = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ReasmOKs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ReasmOKs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ReasmFails = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ReasmFails = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.FragOKs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.FragOKs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.FragFails = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.FragFails = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.FragCreates = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.FragCreates = options.longs === String ? "0" : 0;
            }
            if (message.Forwarding != null && message.hasOwnProperty("Forwarding"))
                if (typeof message.Forwarding === "number")
                    object.Forwarding = options.longs === String ? String(message.Forwarding) : message.Forwarding;
                else
                    object.Forwarding = options.longs === String ? $util.Long.prototype.toString.call(message.Forwarding) : options.longs === Number ? new $util.LongBits(message.Forwarding.low >>> 0, message.Forwarding.high >>> 0).toNumber() : message.Forwarding;
            if (message.DefaultTTL != null && message.hasOwnProperty("DefaultTTL"))
                if (typeof message.DefaultTTL === "number")
                    object.DefaultTTL = options.longs === String ? String(message.DefaultTTL) : message.DefaultTTL;
                else
                    object.DefaultTTL = options.longs === String ? $util.Long.prototype.toString.call(message.DefaultTTL) : options.longs === Number ? new $util.LongBits(message.DefaultTTL.low >>> 0, message.DefaultTTL.high >>> 0).toNumber() : message.DefaultTTL;
            if (message.InReceives != null && message.hasOwnProperty("InReceives"))
                if (typeof message.InReceives === "number")
                    object.InReceives = options.longs === String ? String(message.InReceives) : message.InReceives;
                else
                    object.InReceives = options.longs === String ? $util.Long.prototype.toString.call(message.InReceives) : options.longs === Number ? new $util.LongBits(message.InReceives.low >>> 0, message.InReceives.high >>> 0).toNumber() : message.InReceives;
            if (message.InHdrErrors != null && message.hasOwnProperty("InHdrErrors"))
                if (typeof message.InHdrErrors === "number")
                    object.InHdrErrors = options.longs === String ? String(message.InHdrErrors) : message.InHdrErrors;
                else
                    object.InHdrErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InHdrErrors) : options.longs === Number ? new $util.LongBits(message.InHdrErrors.low >>> 0, message.InHdrErrors.high >>> 0).toNumber() : message.InHdrErrors;
            if (message.InAddrErrors != null && message.hasOwnProperty("InAddrErrors"))
                if (typeof message.InAddrErrors === "number")
                    object.InAddrErrors = options.longs === String ? String(message.InAddrErrors) : message.InAddrErrors;
                else
                    object.InAddrErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InAddrErrors) : options.longs === Number ? new $util.LongBits(message.InAddrErrors.low >>> 0, message.InAddrErrors.high >>> 0).toNumber() : message.InAddrErrors;
            if (message.ForwDatagrams != null && message.hasOwnProperty("ForwDatagrams"))
                if (typeof message.ForwDatagrams === "number")
                    object.ForwDatagrams = options.longs === String ? String(message.ForwDatagrams) : message.ForwDatagrams;
                else
                    object.ForwDatagrams = options.longs === String ? $util.Long.prototype.toString.call(message.ForwDatagrams) : options.longs === Number ? new $util.LongBits(message.ForwDatagrams.low >>> 0, message.ForwDatagrams.high >>> 0).toNumber() : message.ForwDatagrams;
            if (message.InUnknownProtos != null && message.hasOwnProperty("InUnknownProtos"))
                if (typeof message.InUnknownProtos === "number")
                    object.InUnknownProtos = options.longs === String ? String(message.InUnknownProtos) : message.InUnknownProtos;
                else
                    object.InUnknownProtos = options.longs === String ? $util.Long.prototype.toString.call(message.InUnknownProtos) : options.longs === Number ? new $util.LongBits(message.InUnknownProtos.low >>> 0, message.InUnknownProtos.high >>> 0).toNumber() : message.InUnknownProtos;
            if (message.InDiscards != null && message.hasOwnProperty("InDiscards"))
                if (typeof message.InDiscards === "number")
                    object.InDiscards = options.longs === String ? String(message.InDiscards) : message.InDiscards;
                else
                    object.InDiscards = options.longs === String ? $util.Long.prototype.toString.call(message.InDiscards) : options.longs === Number ? new $util.LongBits(message.InDiscards.low >>> 0, message.InDiscards.high >>> 0).toNumber() : message.InDiscards;
            if (message.InDelivers != null && message.hasOwnProperty("InDelivers"))
                if (typeof message.InDelivers === "number")
                    object.InDelivers = options.longs === String ? String(message.InDelivers) : message.InDelivers;
                else
                    object.InDelivers = options.longs === String ? $util.Long.prototype.toString.call(message.InDelivers) : options.longs === Number ? new $util.LongBits(message.InDelivers.low >>> 0, message.InDelivers.high >>> 0).toNumber() : message.InDelivers;
            if (message.OutRequests != null && message.hasOwnProperty("OutRequests"))
                if (typeof message.OutRequests === "number")
                    object.OutRequests = options.longs === String ? String(message.OutRequests) : message.OutRequests;
                else
                    object.OutRequests = options.longs === String ? $util.Long.prototype.toString.call(message.OutRequests) : options.longs === Number ? new $util.LongBits(message.OutRequests.low >>> 0, message.OutRequests.high >>> 0).toNumber() : message.OutRequests;
            if (message.OutDiscards != null && message.hasOwnProperty("OutDiscards"))
                if (typeof message.OutDiscards === "number")
                    object.OutDiscards = options.longs === String ? String(message.OutDiscards) : message.OutDiscards;
                else
                    object.OutDiscards = options.longs === String ? $util.Long.prototype.toString.call(message.OutDiscards) : options.longs === Number ? new $util.LongBits(message.OutDiscards.low >>> 0, message.OutDiscards.high >>> 0).toNumber() : message.OutDiscards;
            if (message.OutNoRoutes != null && message.hasOwnProperty("OutNoRoutes"))
                if (typeof message.OutNoRoutes === "number")
                    object.OutNoRoutes = options.longs === String ? String(message.OutNoRoutes) : message.OutNoRoutes;
                else
                    object.OutNoRoutes = options.longs === String ? $util.Long.prototype.toString.call(message.OutNoRoutes) : options.longs === Number ? new $util.LongBits(message.OutNoRoutes.low >>> 0, message.OutNoRoutes.high >>> 0).toNumber() : message.OutNoRoutes;
            if (message.ReasmTimeout != null && message.hasOwnProperty("ReasmTimeout"))
                if (typeof message.ReasmTimeout === "number")
                    object.ReasmTimeout = options.longs === String ? String(message.ReasmTimeout) : message.ReasmTimeout;
                else
                    object.ReasmTimeout = options.longs === String ? $util.Long.prototype.toString.call(message.ReasmTimeout) : options.longs === Number ? new $util.LongBits(message.ReasmTimeout.low >>> 0, message.ReasmTimeout.high >>> 0).toNumber() : message.ReasmTimeout;
            if (message.ReasmReqds != null && message.hasOwnProperty("ReasmReqds"))
                if (typeof message.ReasmReqds === "number")
                    object.ReasmReqds = options.longs === String ? String(message.ReasmReqds) : message.ReasmReqds;
                else
                    object.ReasmReqds = options.longs === String ? $util.Long.prototype.toString.call(message.ReasmReqds) : options.longs === Number ? new $util.LongBits(message.ReasmReqds.low >>> 0, message.ReasmReqds.high >>> 0).toNumber() : message.ReasmReqds;
            if (message.ReasmOKs != null && message.hasOwnProperty("ReasmOKs"))
                if (typeof message.ReasmOKs === "number")
                    object.ReasmOKs = options.longs === String ? String(message.ReasmOKs) : message.ReasmOKs;
                else
                    object.ReasmOKs = options.longs === String ? $util.Long.prototype.toString.call(message.ReasmOKs) : options.longs === Number ? new $util.LongBits(message.ReasmOKs.low >>> 0, message.ReasmOKs.high >>> 0).toNumber() : message.ReasmOKs;
            if (message.ReasmFails != null && message.hasOwnProperty("ReasmFails"))
                if (typeof message.ReasmFails === "number")
                    object.ReasmFails = options.longs === String ? String(message.ReasmFails) : message.ReasmFails;
                else
                    object.ReasmFails = options.longs === String ? $util.Long.prototype.toString.call(message.ReasmFails) : options.longs === Number ? new $util.LongBits(message.ReasmFails.low >>> 0, message.ReasmFails.high >>> 0).toNumber() : message.ReasmFails;
            if (message.FragOKs != null && message.hasOwnProperty("FragOKs"))
                if (typeof message.FragOKs === "number")
                    object.FragOKs = options.longs === String ? String(message.FragOKs) : message.FragOKs;
                else
                    object.FragOKs = options.longs === String ? $util.Long.prototype.toString.call(message.FragOKs) : options.longs === Number ? new $util.LongBits(message.FragOKs.low >>> 0, message.FragOKs.high >>> 0).toNumber() : message.FragOKs;
            if (message.FragFails != null && message.hasOwnProperty("FragFails"))
                if (typeof message.FragFails === "number")
                    object.FragFails = options.longs === String ? String(message.FragFails) : message.FragFails;
                else
                    object.FragFails = options.longs === String ? $util.Long.prototype.toString.call(message.FragFails) : options.longs === Number ? new $util.LongBits(message.FragFails.low >>> 0, message.FragFails.high >>> 0).toNumber() : message.FragFails;
            if (message.FragCreates != null && message.hasOwnProperty("FragCreates"))
                if (typeof message.FragCreates === "number")
                    object.FragCreates = options.longs === String ? String(message.FragCreates) : message.FragCreates;
                else
                    object.FragCreates = options.longs === String ? $util.Long.prototype.toString.call(message.FragCreates) : options.longs === Number ? new $util.LongBits(message.FragCreates.low >>> 0, message.FragCreates.high >>> 0).toNumber() : message.FragCreates;
            return object;
        };

        /**
         * Converts this IpStatistics to JSON.
         * @function toJSON
         * @memberof mesos.IpStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IpStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IpStatistics;
    })();

    mesos.IcmpStatistics = (function() {

        /**
         * Properties of an IcmpStatistics.
         * @memberof mesos
         * @interface IIcmpStatistics
         * @property {number|Long} [InMsgs] IcmpStatistics InMsgs
         * @property {number|Long} [InErrors] IcmpStatistics InErrors
         * @property {number|Long} [InCsumErrors] IcmpStatistics InCsumErrors
         * @property {number|Long} [InDestUnreachs] IcmpStatistics InDestUnreachs
         * @property {number|Long} [InTimeExcds] IcmpStatistics InTimeExcds
         * @property {number|Long} [InParmProbs] IcmpStatistics InParmProbs
         * @property {number|Long} [InSrcQuenchs] IcmpStatistics InSrcQuenchs
         * @property {number|Long} [InRedirects] IcmpStatistics InRedirects
         * @property {number|Long} [InEchos] IcmpStatistics InEchos
         * @property {number|Long} [InEchoReps] IcmpStatistics InEchoReps
         * @property {number|Long} [InTimestamps] IcmpStatistics InTimestamps
         * @property {number|Long} [InTimestampReps] IcmpStatistics InTimestampReps
         * @property {number|Long} [InAddrMasks] IcmpStatistics InAddrMasks
         * @property {number|Long} [InAddrMaskReps] IcmpStatistics InAddrMaskReps
         * @property {number|Long} [OutMsgs] IcmpStatistics OutMsgs
         * @property {number|Long} [OutErrors] IcmpStatistics OutErrors
         * @property {number|Long} [OutDestUnreachs] IcmpStatistics OutDestUnreachs
         * @property {number|Long} [OutTimeExcds] IcmpStatistics OutTimeExcds
         * @property {number|Long} [OutParmProbs] IcmpStatistics OutParmProbs
         * @property {number|Long} [OutSrcQuenchs] IcmpStatistics OutSrcQuenchs
         * @property {number|Long} [OutRedirects] IcmpStatistics OutRedirects
         * @property {number|Long} [OutEchos] IcmpStatistics OutEchos
         * @property {number|Long} [OutEchoReps] IcmpStatistics OutEchoReps
         * @property {number|Long} [OutTimestamps] IcmpStatistics OutTimestamps
         * @property {number|Long} [OutTimestampReps] IcmpStatistics OutTimestampReps
         * @property {number|Long} [OutAddrMasks] IcmpStatistics OutAddrMasks
         * @property {number|Long} [OutAddrMaskReps] IcmpStatistics OutAddrMaskReps
         */

        /**
         * Constructs a new IcmpStatistics.
         * @memberof mesos
         * @classdesc Represents an IcmpStatistics.
         * @constructor
         * @param {mesos.IIcmpStatistics=} [properties] Properties to set
         */
        function IcmpStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IcmpStatistics InMsgs.
         * @member {number|Long}InMsgs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InMsgs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InErrors.
         * @member {number|Long}InErrors
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InCsumErrors.
         * @member {number|Long}InCsumErrors
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InCsumErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InDestUnreachs.
         * @member {number|Long}InDestUnreachs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InDestUnreachs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InTimeExcds.
         * @member {number|Long}InTimeExcds
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InTimeExcds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InParmProbs.
         * @member {number|Long}InParmProbs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InParmProbs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InSrcQuenchs.
         * @member {number|Long}InSrcQuenchs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InSrcQuenchs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InRedirects.
         * @member {number|Long}InRedirects
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InRedirects = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InEchos.
         * @member {number|Long}InEchos
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InEchos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InEchoReps.
         * @member {number|Long}InEchoReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InEchoReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InTimestamps.
         * @member {number|Long}InTimestamps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InTimestamps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InTimestampReps.
         * @member {number|Long}InTimestampReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InTimestampReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InAddrMasks.
         * @member {number|Long}InAddrMasks
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InAddrMasks = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics InAddrMaskReps.
         * @member {number|Long}InAddrMaskReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.InAddrMaskReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutMsgs.
         * @member {number|Long}OutMsgs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutMsgs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutErrors.
         * @member {number|Long}OutErrors
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutDestUnreachs.
         * @member {number|Long}OutDestUnreachs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutDestUnreachs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutTimeExcds.
         * @member {number|Long}OutTimeExcds
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutTimeExcds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutParmProbs.
         * @member {number|Long}OutParmProbs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutParmProbs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutSrcQuenchs.
         * @member {number|Long}OutSrcQuenchs
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutSrcQuenchs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutRedirects.
         * @member {number|Long}OutRedirects
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutRedirects = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutEchos.
         * @member {number|Long}OutEchos
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutEchos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutEchoReps.
         * @member {number|Long}OutEchoReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutEchoReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutTimestamps.
         * @member {number|Long}OutTimestamps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutTimestamps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutTimestampReps.
         * @member {number|Long}OutTimestampReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutTimestampReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutAddrMasks.
         * @member {number|Long}OutAddrMasks
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutAddrMasks = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IcmpStatistics OutAddrMaskReps.
         * @member {number|Long}OutAddrMaskReps
         * @memberof mesos.IcmpStatistics
         * @instance
         */
        IcmpStatistics.prototype.OutAddrMaskReps = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IcmpStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {mesos.IIcmpStatistics=} [properties] Properties to set
         * @returns {mesos.IcmpStatistics} IcmpStatistics instance
         */
        IcmpStatistics.create = function create(properties) {
            return new IcmpStatistics(properties);
        };

        /**
         * Encodes the specified IcmpStatistics message. Does not implicitly {@link mesos.IcmpStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {mesos.IIcmpStatistics} message IcmpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IcmpStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.InMsgs != null && message.hasOwnProperty("InMsgs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.InMsgs);
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.InErrors);
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.InCsumErrors);
            if (message.InDestUnreachs != null && message.hasOwnProperty("InDestUnreachs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.InDestUnreachs);
            if (message.InTimeExcds != null && message.hasOwnProperty("InTimeExcds"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.InTimeExcds);
            if (message.InParmProbs != null && message.hasOwnProperty("InParmProbs"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.InParmProbs);
            if (message.InSrcQuenchs != null && message.hasOwnProperty("InSrcQuenchs"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.InSrcQuenchs);
            if (message.InRedirects != null && message.hasOwnProperty("InRedirects"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.InRedirects);
            if (message.InEchos != null && message.hasOwnProperty("InEchos"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.InEchos);
            if (message.InEchoReps != null && message.hasOwnProperty("InEchoReps"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.InEchoReps);
            if (message.InTimestamps != null && message.hasOwnProperty("InTimestamps"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.InTimestamps);
            if (message.InTimestampReps != null && message.hasOwnProperty("InTimestampReps"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.InTimestampReps);
            if (message.InAddrMasks != null && message.hasOwnProperty("InAddrMasks"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.InAddrMasks);
            if (message.InAddrMaskReps != null && message.hasOwnProperty("InAddrMaskReps"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.InAddrMaskReps);
            if (message.OutMsgs != null && message.hasOwnProperty("OutMsgs"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.OutMsgs);
            if (message.OutErrors != null && message.hasOwnProperty("OutErrors"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.OutErrors);
            if (message.OutDestUnreachs != null && message.hasOwnProperty("OutDestUnreachs"))
                writer.uint32(/* id 17, wireType 0 =*/136).int64(message.OutDestUnreachs);
            if (message.OutTimeExcds != null && message.hasOwnProperty("OutTimeExcds"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.OutTimeExcds);
            if (message.OutParmProbs != null && message.hasOwnProperty("OutParmProbs"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.OutParmProbs);
            if (message.OutSrcQuenchs != null && message.hasOwnProperty("OutSrcQuenchs"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.OutSrcQuenchs);
            if (message.OutRedirects != null && message.hasOwnProperty("OutRedirects"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.OutRedirects);
            if (message.OutEchos != null && message.hasOwnProperty("OutEchos"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.OutEchos);
            if (message.OutEchoReps != null && message.hasOwnProperty("OutEchoReps"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.OutEchoReps);
            if (message.OutTimestamps != null && message.hasOwnProperty("OutTimestamps"))
                writer.uint32(/* id 24, wireType 0 =*/192).int64(message.OutTimestamps);
            if (message.OutTimestampReps != null && message.hasOwnProperty("OutTimestampReps"))
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.OutTimestampReps);
            if (message.OutAddrMasks != null && message.hasOwnProperty("OutAddrMasks"))
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.OutAddrMasks);
            if (message.OutAddrMaskReps != null && message.hasOwnProperty("OutAddrMaskReps"))
                writer.uint32(/* id 27, wireType 0 =*/216).int64(message.OutAddrMaskReps);
            return writer;
        };

        /**
         * Encodes the specified IcmpStatistics message, length delimited. Does not implicitly {@link mesos.IcmpStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {mesos.IIcmpStatistics} message IcmpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IcmpStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IcmpStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.IcmpStatistics} IcmpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IcmpStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.IcmpStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.InMsgs = reader.int64();
                    break;
                case 2:
                    message.InErrors = reader.int64();
                    break;
                case 3:
                    message.InCsumErrors = reader.int64();
                    break;
                case 4:
                    message.InDestUnreachs = reader.int64();
                    break;
                case 5:
                    message.InTimeExcds = reader.int64();
                    break;
                case 6:
                    message.InParmProbs = reader.int64();
                    break;
                case 7:
                    message.InSrcQuenchs = reader.int64();
                    break;
                case 8:
                    message.InRedirects = reader.int64();
                    break;
                case 9:
                    message.InEchos = reader.int64();
                    break;
                case 10:
                    message.InEchoReps = reader.int64();
                    break;
                case 11:
                    message.InTimestamps = reader.int64();
                    break;
                case 12:
                    message.InTimestampReps = reader.int64();
                    break;
                case 13:
                    message.InAddrMasks = reader.int64();
                    break;
                case 14:
                    message.InAddrMaskReps = reader.int64();
                    break;
                case 15:
                    message.OutMsgs = reader.int64();
                    break;
                case 16:
                    message.OutErrors = reader.int64();
                    break;
                case 17:
                    message.OutDestUnreachs = reader.int64();
                    break;
                case 18:
                    message.OutTimeExcds = reader.int64();
                    break;
                case 19:
                    message.OutParmProbs = reader.int64();
                    break;
                case 20:
                    message.OutSrcQuenchs = reader.int64();
                    break;
                case 21:
                    message.OutRedirects = reader.int64();
                    break;
                case 22:
                    message.OutEchos = reader.int64();
                    break;
                case 23:
                    message.OutEchoReps = reader.int64();
                    break;
                case 24:
                    message.OutTimestamps = reader.int64();
                    break;
                case 25:
                    message.OutTimestampReps = reader.int64();
                    break;
                case 26:
                    message.OutAddrMasks = reader.int64();
                    break;
                case 27:
                    message.OutAddrMaskReps = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IcmpStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.IcmpStatistics} IcmpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IcmpStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IcmpStatistics message.
         * @function verify
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IcmpStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.InMsgs != null && message.hasOwnProperty("InMsgs"))
                if (!$util.isInteger(message.InMsgs) && !(message.InMsgs && $util.isInteger(message.InMsgs.low) && $util.isInteger(message.InMsgs.high)))
                    return "InMsgs: integer|Long expected";
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                if (!$util.isInteger(message.InErrors) && !(message.InErrors && $util.isInteger(message.InErrors.low) && $util.isInteger(message.InErrors.high)))
                    return "InErrors: integer|Long expected";
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (!$util.isInteger(message.InCsumErrors) && !(message.InCsumErrors && $util.isInteger(message.InCsumErrors.low) && $util.isInteger(message.InCsumErrors.high)))
                    return "InCsumErrors: integer|Long expected";
            if (message.InDestUnreachs != null && message.hasOwnProperty("InDestUnreachs"))
                if (!$util.isInteger(message.InDestUnreachs) && !(message.InDestUnreachs && $util.isInteger(message.InDestUnreachs.low) && $util.isInteger(message.InDestUnreachs.high)))
                    return "InDestUnreachs: integer|Long expected";
            if (message.InTimeExcds != null && message.hasOwnProperty("InTimeExcds"))
                if (!$util.isInteger(message.InTimeExcds) && !(message.InTimeExcds && $util.isInteger(message.InTimeExcds.low) && $util.isInteger(message.InTimeExcds.high)))
                    return "InTimeExcds: integer|Long expected";
            if (message.InParmProbs != null && message.hasOwnProperty("InParmProbs"))
                if (!$util.isInteger(message.InParmProbs) && !(message.InParmProbs && $util.isInteger(message.InParmProbs.low) && $util.isInteger(message.InParmProbs.high)))
                    return "InParmProbs: integer|Long expected";
            if (message.InSrcQuenchs != null && message.hasOwnProperty("InSrcQuenchs"))
                if (!$util.isInteger(message.InSrcQuenchs) && !(message.InSrcQuenchs && $util.isInteger(message.InSrcQuenchs.low) && $util.isInteger(message.InSrcQuenchs.high)))
                    return "InSrcQuenchs: integer|Long expected";
            if (message.InRedirects != null && message.hasOwnProperty("InRedirects"))
                if (!$util.isInteger(message.InRedirects) && !(message.InRedirects && $util.isInteger(message.InRedirects.low) && $util.isInteger(message.InRedirects.high)))
                    return "InRedirects: integer|Long expected";
            if (message.InEchos != null && message.hasOwnProperty("InEchos"))
                if (!$util.isInteger(message.InEchos) && !(message.InEchos && $util.isInteger(message.InEchos.low) && $util.isInteger(message.InEchos.high)))
                    return "InEchos: integer|Long expected";
            if (message.InEchoReps != null && message.hasOwnProperty("InEchoReps"))
                if (!$util.isInteger(message.InEchoReps) && !(message.InEchoReps && $util.isInteger(message.InEchoReps.low) && $util.isInteger(message.InEchoReps.high)))
                    return "InEchoReps: integer|Long expected";
            if (message.InTimestamps != null && message.hasOwnProperty("InTimestamps"))
                if (!$util.isInteger(message.InTimestamps) && !(message.InTimestamps && $util.isInteger(message.InTimestamps.low) && $util.isInteger(message.InTimestamps.high)))
                    return "InTimestamps: integer|Long expected";
            if (message.InTimestampReps != null && message.hasOwnProperty("InTimestampReps"))
                if (!$util.isInteger(message.InTimestampReps) && !(message.InTimestampReps && $util.isInteger(message.InTimestampReps.low) && $util.isInteger(message.InTimestampReps.high)))
                    return "InTimestampReps: integer|Long expected";
            if (message.InAddrMasks != null && message.hasOwnProperty("InAddrMasks"))
                if (!$util.isInteger(message.InAddrMasks) && !(message.InAddrMasks && $util.isInteger(message.InAddrMasks.low) && $util.isInteger(message.InAddrMasks.high)))
                    return "InAddrMasks: integer|Long expected";
            if (message.InAddrMaskReps != null && message.hasOwnProperty("InAddrMaskReps"))
                if (!$util.isInteger(message.InAddrMaskReps) && !(message.InAddrMaskReps && $util.isInteger(message.InAddrMaskReps.low) && $util.isInteger(message.InAddrMaskReps.high)))
                    return "InAddrMaskReps: integer|Long expected";
            if (message.OutMsgs != null && message.hasOwnProperty("OutMsgs"))
                if (!$util.isInteger(message.OutMsgs) && !(message.OutMsgs && $util.isInteger(message.OutMsgs.low) && $util.isInteger(message.OutMsgs.high)))
                    return "OutMsgs: integer|Long expected";
            if (message.OutErrors != null && message.hasOwnProperty("OutErrors"))
                if (!$util.isInteger(message.OutErrors) && !(message.OutErrors && $util.isInteger(message.OutErrors.low) && $util.isInteger(message.OutErrors.high)))
                    return "OutErrors: integer|Long expected";
            if (message.OutDestUnreachs != null && message.hasOwnProperty("OutDestUnreachs"))
                if (!$util.isInteger(message.OutDestUnreachs) && !(message.OutDestUnreachs && $util.isInteger(message.OutDestUnreachs.low) && $util.isInteger(message.OutDestUnreachs.high)))
                    return "OutDestUnreachs: integer|Long expected";
            if (message.OutTimeExcds != null && message.hasOwnProperty("OutTimeExcds"))
                if (!$util.isInteger(message.OutTimeExcds) && !(message.OutTimeExcds && $util.isInteger(message.OutTimeExcds.low) && $util.isInteger(message.OutTimeExcds.high)))
                    return "OutTimeExcds: integer|Long expected";
            if (message.OutParmProbs != null && message.hasOwnProperty("OutParmProbs"))
                if (!$util.isInteger(message.OutParmProbs) && !(message.OutParmProbs && $util.isInteger(message.OutParmProbs.low) && $util.isInteger(message.OutParmProbs.high)))
                    return "OutParmProbs: integer|Long expected";
            if (message.OutSrcQuenchs != null && message.hasOwnProperty("OutSrcQuenchs"))
                if (!$util.isInteger(message.OutSrcQuenchs) && !(message.OutSrcQuenchs && $util.isInteger(message.OutSrcQuenchs.low) && $util.isInteger(message.OutSrcQuenchs.high)))
                    return "OutSrcQuenchs: integer|Long expected";
            if (message.OutRedirects != null && message.hasOwnProperty("OutRedirects"))
                if (!$util.isInteger(message.OutRedirects) && !(message.OutRedirects && $util.isInteger(message.OutRedirects.low) && $util.isInteger(message.OutRedirects.high)))
                    return "OutRedirects: integer|Long expected";
            if (message.OutEchos != null && message.hasOwnProperty("OutEchos"))
                if (!$util.isInteger(message.OutEchos) && !(message.OutEchos && $util.isInteger(message.OutEchos.low) && $util.isInteger(message.OutEchos.high)))
                    return "OutEchos: integer|Long expected";
            if (message.OutEchoReps != null && message.hasOwnProperty("OutEchoReps"))
                if (!$util.isInteger(message.OutEchoReps) && !(message.OutEchoReps && $util.isInteger(message.OutEchoReps.low) && $util.isInteger(message.OutEchoReps.high)))
                    return "OutEchoReps: integer|Long expected";
            if (message.OutTimestamps != null && message.hasOwnProperty("OutTimestamps"))
                if (!$util.isInteger(message.OutTimestamps) && !(message.OutTimestamps && $util.isInteger(message.OutTimestamps.low) && $util.isInteger(message.OutTimestamps.high)))
                    return "OutTimestamps: integer|Long expected";
            if (message.OutTimestampReps != null && message.hasOwnProperty("OutTimestampReps"))
                if (!$util.isInteger(message.OutTimestampReps) && !(message.OutTimestampReps && $util.isInteger(message.OutTimestampReps.low) && $util.isInteger(message.OutTimestampReps.high)))
                    return "OutTimestampReps: integer|Long expected";
            if (message.OutAddrMasks != null && message.hasOwnProperty("OutAddrMasks"))
                if (!$util.isInteger(message.OutAddrMasks) && !(message.OutAddrMasks && $util.isInteger(message.OutAddrMasks.low) && $util.isInteger(message.OutAddrMasks.high)))
                    return "OutAddrMasks: integer|Long expected";
            if (message.OutAddrMaskReps != null && message.hasOwnProperty("OutAddrMaskReps"))
                if (!$util.isInteger(message.OutAddrMaskReps) && !(message.OutAddrMaskReps && $util.isInteger(message.OutAddrMaskReps.low) && $util.isInteger(message.OutAddrMaskReps.high)))
                    return "OutAddrMaskReps: integer|Long expected";
            return null;
        };

        /**
         * Creates an IcmpStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.IcmpStatistics} IcmpStatistics
         */
        IcmpStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.IcmpStatistics)
                return object;
            let message = new $root.mesos.IcmpStatistics();
            if (object.InMsgs != null)
                if ($util.Long)
                    (message.InMsgs = $util.Long.fromValue(object.InMsgs)).unsigned = false;
                else if (typeof object.InMsgs === "string")
                    message.InMsgs = parseInt(object.InMsgs, 10);
                else if (typeof object.InMsgs === "number")
                    message.InMsgs = object.InMsgs;
                else if (typeof object.InMsgs === "object")
                    message.InMsgs = new $util.LongBits(object.InMsgs.low >>> 0, object.InMsgs.high >>> 0).toNumber();
            if (object.InErrors != null)
                if ($util.Long)
                    (message.InErrors = $util.Long.fromValue(object.InErrors)).unsigned = false;
                else if (typeof object.InErrors === "string")
                    message.InErrors = parseInt(object.InErrors, 10);
                else if (typeof object.InErrors === "number")
                    message.InErrors = object.InErrors;
                else if (typeof object.InErrors === "object")
                    message.InErrors = new $util.LongBits(object.InErrors.low >>> 0, object.InErrors.high >>> 0).toNumber();
            if (object.InCsumErrors != null)
                if ($util.Long)
                    (message.InCsumErrors = $util.Long.fromValue(object.InCsumErrors)).unsigned = false;
                else if (typeof object.InCsumErrors === "string")
                    message.InCsumErrors = parseInt(object.InCsumErrors, 10);
                else if (typeof object.InCsumErrors === "number")
                    message.InCsumErrors = object.InCsumErrors;
                else if (typeof object.InCsumErrors === "object")
                    message.InCsumErrors = new $util.LongBits(object.InCsumErrors.low >>> 0, object.InCsumErrors.high >>> 0).toNumber();
            if (object.InDestUnreachs != null)
                if ($util.Long)
                    (message.InDestUnreachs = $util.Long.fromValue(object.InDestUnreachs)).unsigned = false;
                else if (typeof object.InDestUnreachs === "string")
                    message.InDestUnreachs = parseInt(object.InDestUnreachs, 10);
                else if (typeof object.InDestUnreachs === "number")
                    message.InDestUnreachs = object.InDestUnreachs;
                else if (typeof object.InDestUnreachs === "object")
                    message.InDestUnreachs = new $util.LongBits(object.InDestUnreachs.low >>> 0, object.InDestUnreachs.high >>> 0).toNumber();
            if (object.InTimeExcds != null)
                if ($util.Long)
                    (message.InTimeExcds = $util.Long.fromValue(object.InTimeExcds)).unsigned = false;
                else if (typeof object.InTimeExcds === "string")
                    message.InTimeExcds = parseInt(object.InTimeExcds, 10);
                else if (typeof object.InTimeExcds === "number")
                    message.InTimeExcds = object.InTimeExcds;
                else if (typeof object.InTimeExcds === "object")
                    message.InTimeExcds = new $util.LongBits(object.InTimeExcds.low >>> 0, object.InTimeExcds.high >>> 0).toNumber();
            if (object.InParmProbs != null)
                if ($util.Long)
                    (message.InParmProbs = $util.Long.fromValue(object.InParmProbs)).unsigned = false;
                else if (typeof object.InParmProbs === "string")
                    message.InParmProbs = parseInt(object.InParmProbs, 10);
                else if (typeof object.InParmProbs === "number")
                    message.InParmProbs = object.InParmProbs;
                else if (typeof object.InParmProbs === "object")
                    message.InParmProbs = new $util.LongBits(object.InParmProbs.low >>> 0, object.InParmProbs.high >>> 0).toNumber();
            if (object.InSrcQuenchs != null)
                if ($util.Long)
                    (message.InSrcQuenchs = $util.Long.fromValue(object.InSrcQuenchs)).unsigned = false;
                else if (typeof object.InSrcQuenchs === "string")
                    message.InSrcQuenchs = parseInt(object.InSrcQuenchs, 10);
                else if (typeof object.InSrcQuenchs === "number")
                    message.InSrcQuenchs = object.InSrcQuenchs;
                else if (typeof object.InSrcQuenchs === "object")
                    message.InSrcQuenchs = new $util.LongBits(object.InSrcQuenchs.low >>> 0, object.InSrcQuenchs.high >>> 0).toNumber();
            if (object.InRedirects != null)
                if ($util.Long)
                    (message.InRedirects = $util.Long.fromValue(object.InRedirects)).unsigned = false;
                else if (typeof object.InRedirects === "string")
                    message.InRedirects = parseInt(object.InRedirects, 10);
                else if (typeof object.InRedirects === "number")
                    message.InRedirects = object.InRedirects;
                else if (typeof object.InRedirects === "object")
                    message.InRedirects = new $util.LongBits(object.InRedirects.low >>> 0, object.InRedirects.high >>> 0).toNumber();
            if (object.InEchos != null)
                if ($util.Long)
                    (message.InEchos = $util.Long.fromValue(object.InEchos)).unsigned = false;
                else if (typeof object.InEchos === "string")
                    message.InEchos = parseInt(object.InEchos, 10);
                else if (typeof object.InEchos === "number")
                    message.InEchos = object.InEchos;
                else if (typeof object.InEchos === "object")
                    message.InEchos = new $util.LongBits(object.InEchos.low >>> 0, object.InEchos.high >>> 0).toNumber();
            if (object.InEchoReps != null)
                if ($util.Long)
                    (message.InEchoReps = $util.Long.fromValue(object.InEchoReps)).unsigned = false;
                else if (typeof object.InEchoReps === "string")
                    message.InEchoReps = parseInt(object.InEchoReps, 10);
                else if (typeof object.InEchoReps === "number")
                    message.InEchoReps = object.InEchoReps;
                else if (typeof object.InEchoReps === "object")
                    message.InEchoReps = new $util.LongBits(object.InEchoReps.low >>> 0, object.InEchoReps.high >>> 0).toNumber();
            if (object.InTimestamps != null)
                if ($util.Long)
                    (message.InTimestamps = $util.Long.fromValue(object.InTimestamps)).unsigned = false;
                else if (typeof object.InTimestamps === "string")
                    message.InTimestamps = parseInt(object.InTimestamps, 10);
                else if (typeof object.InTimestamps === "number")
                    message.InTimestamps = object.InTimestamps;
                else if (typeof object.InTimestamps === "object")
                    message.InTimestamps = new $util.LongBits(object.InTimestamps.low >>> 0, object.InTimestamps.high >>> 0).toNumber();
            if (object.InTimestampReps != null)
                if ($util.Long)
                    (message.InTimestampReps = $util.Long.fromValue(object.InTimestampReps)).unsigned = false;
                else if (typeof object.InTimestampReps === "string")
                    message.InTimestampReps = parseInt(object.InTimestampReps, 10);
                else if (typeof object.InTimestampReps === "number")
                    message.InTimestampReps = object.InTimestampReps;
                else if (typeof object.InTimestampReps === "object")
                    message.InTimestampReps = new $util.LongBits(object.InTimestampReps.low >>> 0, object.InTimestampReps.high >>> 0).toNumber();
            if (object.InAddrMasks != null)
                if ($util.Long)
                    (message.InAddrMasks = $util.Long.fromValue(object.InAddrMasks)).unsigned = false;
                else if (typeof object.InAddrMasks === "string")
                    message.InAddrMasks = parseInt(object.InAddrMasks, 10);
                else if (typeof object.InAddrMasks === "number")
                    message.InAddrMasks = object.InAddrMasks;
                else if (typeof object.InAddrMasks === "object")
                    message.InAddrMasks = new $util.LongBits(object.InAddrMasks.low >>> 0, object.InAddrMasks.high >>> 0).toNumber();
            if (object.InAddrMaskReps != null)
                if ($util.Long)
                    (message.InAddrMaskReps = $util.Long.fromValue(object.InAddrMaskReps)).unsigned = false;
                else if (typeof object.InAddrMaskReps === "string")
                    message.InAddrMaskReps = parseInt(object.InAddrMaskReps, 10);
                else if (typeof object.InAddrMaskReps === "number")
                    message.InAddrMaskReps = object.InAddrMaskReps;
                else if (typeof object.InAddrMaskReps === "object")
                    message.InAddrMaskReps = new $util.LongBits(object.InAddrMaskReps.low >>> 0, object.InAddrMaskReps.high >>> 0).toNumber();
            if (object.OutMsgs != null)
                if ($util.Long)
                    (message.OutMsgs = $util.Long.fromValue(object.OutMsgs)).unsigned = false;
                else if (typeof object.OutMsgs === "string")
                    message.OutMsgs = parseInt(object.OutMsgs, 10);
                else if (typeof object.OutMsgs === "number")
                    message.OutMsgs = object.OutMsgs;
                else if (typeof object.OutMsgs === "object")
                    message.OutMsgs = new $util.LongBits(object.OutMsgs.low >>> 0, object.OutMsgs.high >>> 0).toNumber();
            if (object.OutErrors != null)
                if ($util.Long)
                    (message.OutErrors = $util.Long.fromValue(object.OutErrors)).unsigned = false;
                else if (typeof object.OutErrors === "string")
                    message.OutErrors = parseInt(object.OutErrors, 10);
                else if (typeof object.OutErrors === "number")
                    message.OutErrors = object.OutErrors;
                else if (typeof object.OutErrors === "object")
                    message.OutErrors = new $util.LongBits(object.OutErrors.low >>> 0, object.OutErrors.high >>> 0).toNumber();
            if (object.OutDestUnreachs != null)
                if ($util.Long)
                    (message.OutDestUnreachs = $util.Long.fromValue(object.OutDestUnreachs)).unsigned = false;
                else if (typeof object.OutDestUnreachs === "string")
                    message.OutDestUnreachs = parseInt(object.OutDestUnreachs, 10);
                else if (typeof object.OutDestUnreachs === "number")
                    message.OutDestUnreachs = object.OutDestUnreachs;
                else if (typeof object.OutDestUnreachs === "object")
                    message.OutDestUnreachs = new $util.LongBits(object.OutDestUnreachs.low >>> 0, object.OutDestUnreachs.high >>> 0).toNumber();
            if (object.OutTimeExcds != null)
                if ($util.Long)
                    (message.OutTimeExcds = $util.Long.fromValue(object.OutTimeExcds)).unsigned = false;
                else if (typeof object.OutTimeExcds === "string")
                    message.OutTimeExcds = parseInt(object.OutTimeExcds, 10);
                else if (typeof object.OutTimeExcds === "number")
                    message.OutTimeExcds = object.OutTimeExcds;
                else if (typeof object.OutTimeExcds === "object")
                    message.OutTimeExcds = new $util.LongBits(object.OutTimeExcds.low >>> 0, object.OutTimeExcds.high >>> 0).toNumber();
            if (object.OutParmProbs != null)
                if ($util.Long)
                    (message.OutParmProbs = $util.Long.fromValue(object.OutParmProbs)).unsigned = false;
                else if (typeof object.OutParmProbs === "string")
                    message.OutParmProbs = parseInt(object.OutParmProbs, 10);
                else if (typeof object.OutParmProbs === "number")
                    message.OutParmProbs = object.OutParmProbs;
                else if (typeof object.OutParmProbs === "object")
                    message.OutParmProbs = new $util.LongBits(object.OutParmProbs.low >>> 0, object.OutParmProbs.high >>> 0).toNumber();
            if (object.OutSrcQuenchs != null)
                if ($util.Long)
                    (message.OutSrcQuenchs = $util.Long.fromValue(object.OutSrcQuenchs)).unsigned = false;
                else if (typeof object.OutSrcQuenchs === "string")
                    message.OutSrcQuenchs = parseInt(object.OutSrcQuenchs, 10);
                else if (typeof object.OutSrcQuenchs === "number")
                    message.OutSrcQuenchs = object.OutSrcQuenchs;
                else if (typeof object.OutSrcQuenchs === "object")
                    message.OutSrcQuenchs = new $util.LongBits(object.OutSrcQuenchs.low >>> 0, object.OutSrcQuenchs.high >>> 0).toNumber();
            if (object.OutRedirects != null)
                if ($util.Long)
                    (message.OutRedirects = $util.Long.fromValue(object.OutRedirects)).unsigned = false;
                else if (typeof object.OutRedirects === "string")
                    message.OutRedirects = parseInt(object.OutRedirects, 10);
                else if (typeof object.OutRedirects === "number")
                    message.OutRedirects = object.OutRedirects;
                else if (typeof object.OutRedirects === "object")
                    message.OutRedirects = new $util.LongBits(object.OutRedirects.low >>> 0, object.OutRedirects.high >>> 0).toNumber();
            if (object.OutEchos != null)
                if ($util.Long)
                    (message.OutEchos = $util.Long.fromValue(object.OutEchos)).unsigned = false;
                else if (typeof object.OutEchos === "string")
                    message.OutEchos = parseInt(object.OutEchos, 10);
                else if (typeof object.OutEchos === "number")
                    message.OutEchos = object.OutEchos;
                else if (typeof object.OutEchos === "object")
                    message.OutEchos = new $util.LongBits(object.OutEchos.low >>> 0, object.OutEchos.high >>> 0).toNumber();
            if (object.OutEchoReps != null)
                if ($util.Long)
                    (message.OutEchoReps = $util.Long.fromValue(object.OutEchoReps)).unsigned = false;
                else if (typeof object.OutEchoReps === "string")
                    message.OutEchoReps = parseInt(object.OutEchoReps, 10);
                else if (typeof object.OutEchoReps === "number")
                    message.OutEchoReps = object.OutEchoReps;
                else if (typeof object.OutEchoReps === "object")
                    message.OutEchoReps = new $util.LongBits(object.OutEchoReps.low >>> 0, object.OutEchoReps.high >>> 0).toNumber();
            if (object.OutTimestamps != null)
                if ($util.Long)
                    (message.OutTimestamps = $util.Long.fromValue(object.OutTimestamps)).unsigned = false;
                else if (typeof object.OutTimestamps === "string")
                    message.OutTimestamps = parseInt(object.OutTimestamps, 10);
                else if (typeof object.OutTimestamps === "number")
                    message.OutTimestamps = object.OutTimestamps;
                else if (typeof object.OutTimestamps === "object")
                    message.OutTimestamps = new $util.LongBits(object.OutTimestamps.low >>> 0, object.OutTimestamps.high >>> 0).toNumber();
            if (object.OutTimestampReps != null)
                if ($util.Long)
                    (message.OutTimestampReps = $util.Long.fromValue(object.OutTimestampReps)).unsigned = false;
                else if (typeof object.OutTimestampReps === "string")
                    message.OutTimestampReps = parseInt(object.OutTimestampReps, 10);
                else if (typeof object.OutTimestampReps === "number")
                    message.OutTimestampReps = object.OutTimestampReps;
                else if (typeof object.OutTimestampReps === "object")
                    message.OutTimestampReps = new $util.LongBits(object.OutTimestampReps.low >>> 0, object.OutTimestampReps.high >>> 0).toNumber();
            if (object.OutAddrMasks != null)
                if ($util.Long)
                    (message.OutAddrMasks = $util.Long.fromValue(object.OutAddrMasks)).unsigned = false;
                else if (typeof object.OutAddrMasks === "string")
                    message.OutAddrMasks = parseInt(object.OutAddrMasks, 10);
                else if (typeof object.OutAddrMasks === "number")
                    message.OutAddrMasks = object.OutAddrMasks;
                else if (typeof object.OutAddrMasks === "object")
                    message.OutAddrMasks = new $util.LongBits(object.OutAddrMasks.low >>> 0, object.OutAddrMasks.high >>> 0).toNumber();
            if (object.OutAddrMaskReps != null)
                if ($util.Long)
                    (message.OutAddrMaskReps = $util.Long.fromValue(object.OutAddrMaskReps)).unsigned = false;
                else if (typeof object.OutAddrMaskReps === "string")
                    message.OutAddrMaskReps = parseInt(object.OutAddrMaskReps, 10);
                else if (typeof object.OutAddrMaskReps === "number")
                    message.OutAddrMaskReps = object.OutAddrMaskReps;
                else if (typeof object.OutAddrMaskReps === "object")
                    message.OutAddrMaskReps = new $util.LongBits(object.OutAddrMaskReps.low >>> 0, object.OutAddrMaskReps.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IcmpStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.IcmpStatistics
         * @static
         * @param {mesos.IcmpStatistics} message IcmpStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IcmpStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InMsgs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InMsgs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InCsumErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InCsumErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InDestUnreachs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InDestUnreachs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InTimeExcds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InTimeExcds = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InParmProbs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InParmProbs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InSrcQuenchs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InSrcQuenchs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InRedirects = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InRedirects = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InEchos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InEchos = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InEchoReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InEchoReps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InTimestamps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InTimestamps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InTimestampReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InTimestampReps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InAddrMasks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InAddrMasks = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InAddrMaskReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InAddrMaskReps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutMsgs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutMsgs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutDestUnreachs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutDestUnreachs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutTimeExcds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutTimeExcds = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutParmProbs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutParmProbs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutSrcQuenchs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutSrcQuenchs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutRedirects = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutRedirects = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutEchos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutEchos = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutEchoReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutEchoReps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutTimestamps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutTimestamps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutTimestampReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutTimestampReps = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutAddrMasks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutAddrMasks = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutAddrMaskReps = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutAddrMaskReps = options.longs === String ? "0" : 0;
            }
            if (message.InMsgs != null && message.hasOwnProperty("InMsgs"))
                if (typeof message.InMsgs === "number")
                    object.InMsgs = options.longs === String ? String(message.InMsgs) : message.InMsgs;
                else
                    object.InMsgs = options.longs === String ? $util.Long.prototype.toString.call(message.InMsgs) : options.longs === Number ? new $util.LongBits(message.InMsgs.low >>> 0, message.InMsgs.high >>> 0).toNumber() : message.InMsgs;
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                if (typeof message.InErrors === "number")
                    object.InErrors = options.longs === String ? String(message.InErrors) : message.InErrors;
                else
                    object.InErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InErrors) : options.longs === Number ? new $util.LongBits(message.InErrors.low >>> 0, message.InErrors.high >>> 0).toNumber() : message.InErrors;
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (typeof message.InCsumErrors === "number")
                    object.InCsumErrors = options.longs === String ? String(message.InCsumErrors) : message.InCsumErrors;
                else
                    object.InCsumErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InCsumErrors) : options.longs === Number ? new $util.LongBits(message.InCsumErrors.low >>> 0, message.InCsumErrors.high >>> 0).toNumber() : message.InCsumErrors;
            if (message.InDestUnreachs != null && message.hasOwnProperty("InDestUnreachs"))
                if (typeof message.InDestUnreachs === "number")
                    object.InDestUnreachs = options.longs === String ? String(message.InDestUnreachs) : message.InDestUnreachs;
                else
                    object.InDestUnreachs = options.longs === String ? $util.Long.prototype.toString.call(message.InDestUnreachs) : options.longs === Number ? new $util.LongBits(message.InDestUnreachs.low >>> 0, message.InDestUnreachs.high >>> 0).toNumber() : message.InDestUnreachs;
            if (message.InTimeExcds != null && message.hasOwnProperty("InTimeExcds"))
                if (typeof message.InTimeExcds === "number")
                    object.InTimeExcds = options.longs === String ? String(message.InTimeExcds) : message.InTimeExcds;
                else
                    object.InTimeExcds = options.longs === String ? $util.Long.prototype.toString.call(message.InTimeExcds) : options.longs === Number ? new $util.LongBits(message.InTimeExcds.low >>> 0, message.InTimeExcds.high >>> 0).toNumber() : message.InTimeExcds;
            if (message.InParmProbs != null && message.hasOwnProperty("InParmProbs"))
                if (typeof message.InParmProbs === "number")
                    object.InParmProbs = options.longs === String ? String(message.InParmProbs) : message.InParmProbs;
                else
                    object.InParmProbs = options.longs === String ? $util.Long.prototype.toString.call(message.InParmProbs) : options.longs === Number ? new $util.LongBits(message.InParmProbs.low >>> 0, message.InParmProbs.high >>> 0).toNumber() : message.InParmProbs;
            if (message.InSrcQuenchs != null && message.hasOwnProperty("InSrcQuenchs"))
                if (typeof message.InSrcQuenchs === "number")
                    object.InSrcQuenchs = options.longs === String ? String(message.InSrcQuenchs) : message.InSrcQuenchs;
                else
                    object.InSrcQuenchs = options.longs === String ? $util.Long.prototype.toString.call(message.InSrcQuenchs) : options.longs === Number ? new $util.LongBits(message.InSrcQuenchs.low >>> 0, message.InSrcQuenchs.high >>> 0).toNumber() : message.InSrcQuenchs;
            if (message.InRedirects != null && message.hasOwnProperty("InRedirects"))
                if (typeof message.InRedirects === "number")
                    object.InRedirects = options.longs === String ? String(message.InRedirects) : message.InRedirects;
                else
                    object.InRedirects = options.longs === String ? $util.Long.prototype.toString.call(message.InRedirects) : options.longs === Number ? new $util.LongBits(message.InRedirects.low >>> 0, message.InRedirects.high >>> 0).toNumber() : message.InRedirects;
            if (message.InEchos != null && message.hasOwnProperty("InEchos"))
                if (typeof message.InEchos === "number")
                    object.InEchos = options.longs === String ? String(message.InEchos) : message.InEchos;
                else
                    object.InEchos = options.longs === String ? $util.Long.prototype.toString.call(message.InEchos) : options.longs === Number ? new $util.LongBits(message.InEchos.low >>> 0, message.InEchos.high >>> 0).toNumber() : message.InEchos;
            if (message.InEchoReps != null && message.hasOwnProperty("InEchoReps"))
                if (typeof message.InEchoReps === "number")
                    object.InEchoReps = options.longs === String ? String(message.InEchoReps) : message.InEchoReps;
                else
                    object.InEchoReps = options.longs === String ? $util.Long.prototype.toString.call(message.InEchoReps) : options.longs === Number ? new $util.LongBits(message.InEchoReps.low >>> 0, message.InEchoReps.high >>> 0).toNumber() : message.InEchoReps;
            if (message.InTimestamps != null && message.hasOwnProperty("InTimestamps"))
                if (typeof message.InTimestamps === "number")
                    object.InTimestamps = options.longs === String ? String(message.InTimestamps) : message.InTimestamps;
                else
                    object.InTimestamps = options.longs === String ? $util.Long.prototype.toString.call(message.InTimestamps) : options.longs === Number ? new $util.LongBits(message.InTimestamps.low >>> 0, message.InTimestamps.high >>> 0).toNumber() : message.InTimestamps;
            if (message.InTimestampReps != null && message.hasOwnProperty("InTimestampReps"))
                if (typeof message.InTimestampReps === "number")
                    object.InTimestampReps = options.longs === String ? String(message.InTimestampReps) : message.InTimestampReps;
                else
                    object.InTimestampReps = options.longs === String ? $util.Long.prototype.toString.call(message.InTimestampReps) : options.longs === Number ? new $util.LongBits(message.InTimestampReps.low >>> 0, message.InTimestampReps.high >>> 0).toNumber() : message.InTimestampReps;
            if (message.InAddrMasks != null && message.hasOwnProperty("InAddrMasks"))
                if (typeof message.InAddrMasks === "number")
                    object.InAddrMasks = options.longs === String ? String(message.InAddrMasks) : message.InAddrMasks;
                else
                    object.InAddrMasks = options.longs === String ? $util.Long.prototype.toString.call(message.InAddrMasks) : options.longs === Number ? new $util.LongBits(message.InAddrMasks.low >>> 0, message.InAddrMasks.high >>> 0).toNumber() : message.InAddrMasks;
            if (message.InAddrMaskReps != null && message.hasOwnProperty("InAddrMaskReps"))
                if (typeof message.InAddrMaskReps === "number")
                    object.InAddrMaskReps = options.longs === String ? String(message.InAddrMaskReps) : message.InAddrMaskReps;
                else
                    object.InAddrMaskReps = options.longs === String ? $util.Long.prototype.toString.call(message.InAddrMaskReps) : options.longs === Number ? new $util.LongBits(message.InAddrMaskReps.low >>> 0, message.InAddrMaskReps.high >>> 0).toNumber() : message.InAddrMaskReps;
            if (message.OutMsgs != null && message.hasOwnProperty("OutMsgs"))
                if (typeof message.OutMsgs === "number")
                    object.OutMsgs = options.longs === String ? String(message.OutMsgs) : message.OutMsgs;
                else
                    object.OutMsgs = options.longs === String ? $util.Long.prototype.toString.call(message.OutMsgs) : options.longs === Number ? new $util.LongBits(message.OutMsgs.low >>> 0, message.OutMsgs.high >>> 0).toNumber() : message.OutMsgs;
            if (message.OutErrors != null && message.hasOwnProperty("OutErrors"))
                if (typeof message.OutErrors === "number")
                    object.OutErrors = options.longs === String ? String(message.OutErrors) : message.OutErrors;
                else
                    object.OutErrors = options.longs === String ? $util.Long.prototype.toString.call(message.OutErrors) : options.longs === Number ? new $util.LongBits(message.OutErrors.low >>> 0, message.OutErrors.high >>> 0).toNumber() : message.OutErrors;
            if (message.OutDestUnreachs != null && message.hasOwnProperty("OutDestUnreachs"))
                if (typeof message.OutDestUnreachs === "number")
                    object.OutDestUnreachs = options.longs === String ? String(message.OutDestUnreachs) : message.OutDestUnreachs;
                else
                    object.OutDestUnreachs = options.longs === String ? $util.Long.prototype.toString.call(message.OutDestUnreachs) : options.longs === Number ? new $util.LongBits(message.OutDestUnreachs.low >>> 0, message.OutDestUnreachs.high >>> 0).toNumber() : message.OutDestUnreachs;
            if (message.OutTimeExcds != null && message.hasOwnProperty("OutTimeExcds"))
                if (typeof message.OutTimeExcds === "number")
                    object.OutTimeExcds = options.longs === String ? String(message.OutTimeExcds) : message.OutTimeExcds;
                else
                    object.OutTimeExcds = options.longs === String ? $util.Long.prototype.toString.call(message.OutTimeExcds) : options.longs === Number ? new $util.LongBits(message.OutTimeExcds.low >>> 0, message.OutTimeExcds.high >>> 0).toNumber() : message.OutTimeExcds;
            if (message.OutParmProbs != null && message.hasOwnProperty("OutParmProbs"))
                if (typeof message.OutParmProbs === "number")
                    object.OutParmProbs = options.longs === String ? String(message.OutParmProbs) : message.OutParmProbs;
                else
                    object.OutParmProbs = options.longs === String ? $util.Long.prototype.toString.call(message.OutParmProbs) : options.longs === Number ? new $util.LongBits(message.OutParmProbs.low >>> 0, message.OutParmProbs.high >>> 0).toNumber() : message.OutParmProbs;
            if (message.OutSrcQuenchs != null && message.hasOwnProperty("OutSrcQuenchs"))
                if (typeof message.OutSrcQuenchs === "number")
                    object.OutSrcQuenchs = options.longs === String ? String(message.OutSrcQuenchs) : message.OutSrcQuenchs;
                else
                    object.OutSrcQuenchs = options.longs === String ? $util.Long.prototype.toString.call(message.OutSrcQuenchs) : options.longs === Number ? new $util.LongBits(message.OutSrcQuenchs.low >>> 0, message.OutSrcQuenchs.high >>> 0).toNumber() : message.OutSrcQuenchs;
            if (message.OutRedirects != null && message.hasOwnProperty("OutRedirects"))
                if (typeof message.OutRedirects === "number")
                    object.OutRedirects = options.longs === String ? String(message.OutRedirects) : message.OutRedirects;
                else
                    object.OutRedirects = options.longs === String ? $util.Long.prototype.toString.call(message.OutRedirects) : options.longs === Number ? new $util.LongBits(message.OutRedirects.low >>> 0, message.OutRedirects.high >>> 0).toNumber() : message.OutRedirects;
            if (message.OutEchos != null && message.hasOwnProperty("OutEchos"))
                if (typeof message.OutEchos === "number")
                    object.OutEchos = options.longs === String ? String(message.OutEchos) : message.OutEchos;
                else
                    object.OutEchos = options.longs === String ? $util.Long.prototype.toString.call(message.OutEchos) : options.longs === Number ? new $util.LongBits(message.OutEchos.low >>> 0, message.OutEchos.high >>> 0).toNumber() : message.OutEchos;
            if (message.OutEchoReps != null && message.hasOwnProperty("OutEchoReps"))
                if (typeof message.OutEchoReps === "number")
                    object.OutEchoReps = options.longs === String ? String(message.OutEchoReps) : message.OutEchoReps;
                else
                    object.OutEchoReps = options.longs === String ? $util.Long.prototype.toString.call(message.OutEchoReps) : options.longs === Number ? new $util.LongBits(message.OutEchoReps.low >>> 0, message.OutEchoReps.high >>> 0).toNumber() : message.OutEchoReps;
            if (message.OutTimestamps != null && message.hasOwnProperty("OutTimestamps"))
                if (typeof message.OutTimestamps === "number")
                    object.OutTimestamps = options.longs === String ? String(message.OutTimestamps) : message.OutTimestamps;
                else
                    object.OutTimestamps = options.longs === String ? $util.Long.prototype.toString.call(message.OutTimestamps) : options.longs === Number ? new $util.LongBits(message.OutTimestamps.low >>> 0, message.OutTimestamps.high >>> 0).toNumber() : message.OutTimestamps;
            if (message.OutTimestampReps != null && message.hasOwnProperty("OutTimestampReps"))
                if (typeof message.OutTimestampReps === "number")
                    object.OutTimestampReps = options.longs === String ? String(message.OutTimestampReps) : message.OutTimestampReps;
                else
                    object.OutTimestampReps = options.longs === String ? $util.Long.prototype.toString.call(message.OutTimestampReps) : options.longs === Number ? new $util.LongBits(message.OutTimestampReps.low >>> 0, message.OutTimestampReps.high >>> 0).toNumber() : message.OutTimestampReps;
            if (message.OutAddrMasks != null && message.hasOwnProperty("OutAddrMasks"))
                if (typeof message.OutAddrMasks === "number")
                    object.OutAddrMasks = options.longs === String ? String(message.OutAddrMasks) : message.OutAddrMasks;
                else
                    object.OutAddrMasks = options.longs === String ? $util.Long.prototype.toString.call(message.OutAddrMasks) : options.longs === Number ? new $util.LongBits(message.OutAddrMasks.low >>> 0, message.OutAddrMasks.high >>> 0).toNumber() : message.OutAddrMasks;
            if (message.OutAddrMaskReps != null && message.hasOwnProperty("OutAddrMaskReps"))
                if (typeof message.OutAddrMaskReps === "number")
                    object.OutAddrMaskReps = options.longs === String ? String(message.OutAddrMaskReps) : message.OutAddrMaskReps;
                else
                    object.OutAddrMaskReps = options.longs === String ? $util.Long.prototype.toString.call(message.OutAddrMaskReps) : options.longs === Number ? new $util.LongBits(message.OutAddrMaskReps.low >>> 0, message.OutAddrMaskReps.high >>> 0).toNumber() : message.OutAddrMaskReps;
            return object;
        };

        /**
         * Converts this IcmpStatistics to JSON.
         * @function toJSON
         * @memberof mesos.IcmpStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IcmpStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IcmpStatistics;
    })();

    mesos.TcpStatistics = (function() {

        /**
         * Properties of a TcpStatistics.
         * @memberof mesos
         * @interface ITcpStatistics
         * @property {number|Long} [RtoAlgorithm] TcpStatistics RtoAlgorithm
         * @property {number|Long} [RtoMin] TcpStatistics RtoMin
         * @property {number|Long} [RtoMax] TcpStatistics RtoMax
         * @property {number|Long} [MaxConn] TcpStatistics MaxConn
         * @property {number|Long} [ActiveOpens] TcpStatistics ActiveOpens
         * @property {number|Long} [PassiveOpens] TcpStatistics PassiveOpens
         * @property {number|Long} [AttemptFails] TcpStatistics AttemptFails
         * @property {number|Long} [EstabResets] TcpStatistics EstabResets
         * @property {number|Long} [CurrEstab] TcpStatistics CurrEstab
         * @property {number|Long} [InSegs] TcpStatistics InSegs
         * @property {number|Long} [OutSegs] TcpStatistics OutSegs
         * @property {number|Long} [RetransSegs] TcpStatistics RetransSegs
         * @property {number|Long} [InErrs] TcpStatistics InErrs
         * @property {number|Long} [OutRsts] TcpStatistics OutRsts
         * @property {number|Long} [InCsumErrors] TcpStatistics InCsumErrors
         */

        /**
         * Constructs a new TcpStatistics.
         * @memberof mesos
         * @classdesc Represents a TcpStatistics.
         * @constructor
         * @param {mesos.ITcpStatistics=} [properties] Properties to set
         */
        function TcpStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TcpStatistics RtoAlgorithm.
         * @member {number|Long}RtoAlgorithm
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.RtoAlgorithm = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics RtoMin.
         * @member {number|Long}RtoMin
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.RtoMin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics RtoMax.
         * @member {number|Long}RtoMax
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.RtoMax = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics MaxConn.
         * @member {number|Long}MaxConn
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.MaxConn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics ActiveOpens.
         * @member {number|Long}ActiveOpens
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.ActiveOpens = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics PassiveOpens.
         * @member {number|Long}PassiveOpens
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.PassiveOpens = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics AttemptFails.
         * @member {number|Long}AttemptFails
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.AttemptFails = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics EstabResets.
         * @member {number|Long}EstabResets
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.EstabResets = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics CurrEstab.
         * @member {number|Long}CurrEstab
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.CurrEstab = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics InSegs.
         * @member {number|Long}InSegs
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.InSegs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics OutSegs.
         * @member {number|Long}OutSegs
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.OutSegs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics RetransSegs.
         * @member {number|Long}RetransSegs
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.RetransSegs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics InErrs.
         * @member {number|Long}InErrs
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.InErrs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics OutRsts.
         * @member {number|Long}OutRsts
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.OutRsts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TcpStatistics InCsumErrors.
         * @member {number|Long}InCsumErrors
         * @memberof mesos.TcpStatistics
         * @instance
         */
        TcpStatistics.prototype.InCsumErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TcpStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.TcpStatistics
         * @static
         * @param {mesos.ITcpStatistics=} [properties] Properties to set
         * @returns {mesos.TcpStatistics} TcpStatistics instance
         */
        TcpStatistics.create = function create(properties) {
            return new TcpStatistics(properties);
        };

        /**
         * Encodes the specified TcpStatistics message. Does not implicitly {@link mesos.TcpStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.TcpStatistics
         * @static
         * @param {mesos.ITcpStatistics} message TcpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RtoAlgorithm != null && message.hasOwnProperty("RtoAlgorithm"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.RtoAlgorithm);
            if (message.RtoMin != null && message.hasOwnProperty("RtoMin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.RtoMin);
            if (message.RtoMax != null && message.hasOwnProperty("RtoMax"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.RtoMax);
            if (message.MaxConn != null && message.hasOwnProperty("MaxConn"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.MaxConn);
            if (message.ActiveOpens != null && message.hasOwnProperty("ActiveOpens"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ActiveOpens);
            if (message.PassiveOpens != null && message.hasOwnProperty("PassiveOpens"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.PassiveOpens);
            if (message.AttemptFails != null && message.hasOwnProperty("AttemptFails"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.AttemptFails);
            if (message.EstabResets != null && message.hasOwnProperty("EstabResets"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.EstabResets);
            if (message.CurrEstab != null && message.hasOwnProperty("CurrEstab"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.CurrEstab);
            if (message.InSegs != null && message.hasOwnProperty("InSegs"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.InSegs);
            if (message.OutSegs != null && message.hasOwnProperty("OutSegs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.OutSegs);
            if (message.RetransSegs != null && message.hasOwnProperty("RetransSegs"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.RetransSegs);
            if (message.InErrs != null && message.hasOwnProperty("InErrs"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.InErrs);
            if (message.OutRsts != null && message.hasOwnProperty("OutRsts"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.OutRsts);
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.InCsumErrors);
            return writer;
        };

        /**
         * Encodes the specified TcpStatistics message, length delimited. Does not implicitly {@link mesos.TcpStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TcpStatistics
         * @static
         * @param {mesos.ITcpStatistics} message TcpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TcpStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TcpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TcpStatistics} TcpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TcpStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RtoAlgorithm = reader.int64();
                    break;
                case 2:
                    message.RtoMin = reader.int64();
                    break;
                case 3:
                    message.RtoMax = reader.int64();
                    break;
                case 4:
                    message.MaxConn = reader.int64();
                    break;
                case 5:
                    message.ActiveOpens = reader.int64();
                    break;
                case 6:
                    message.PassiveOpens = reader.int64();
                    break;
                case 7:
                    message.AttemptFails = reader.int64();
                    break;
                case 8:
                    message.EstabResets = reader.int64();
                    break;
                case 9:
                    message.CurrEstab = reader.int64();
                    break;
                case 10:
                    message.InSegs = reader.int64();
                    break;
                case 11:
                    message.OutSegs = reader.int64();
                    break;
                case 12:
                    message.RetransSegs = reader.int64();
                    break;
                case 13:
                    message.InErrs = reader.int64();
                    break;
                case 14:
                    message.OutRsts = reader.int64();
                    break;
                case 15:
                    message.InCsumErrors = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TcpStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TcpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TcpStatistics} TcpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TcpStatistics message.
         * @function verify
         * @memberof mesos.TcpStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TcpStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RtoAlgorithm != null && message.hasOwnProperty("RtoAlgorithm"))
                if (!$util.isInteger(message.RtoAlgorithm) && !(message.RtoAlgorithm && $util.isInteger(message.RtoAlgorithm.low) && $util.isInteger(message.RtoAlgorithm.high)))
                    return "RtoAlgorithm: integer|Long expected";
            if (message.RtoMin != null && message.hasOwnProperty("RtoMin"))
                if (!$util.isInteger(message.RtoMin) && !(message.RtoMin && $util.isInteger(message.RtoMin.low) && $util.isInteger(message.RtoMin.high)))
                    return "RtoMin: integer|Long expected";
            if (message.RtoMax != null && message.hasOwnProperty("RtoMax"))
                if (!$util.isInteger(message.RtoMax) && !(message.RtoMax && $util.isInteger(message.RtoMax.low) && $util.isInteger(message.RtoMax.high)))
                    return "RtoMax: integer|Long expected";
            if (message.MaxConn != null && message.hasOwnProperty("MaxConn"))
                if (!$util.isInteger(message.MaxConn) && !(message.MaxConn && $util.isInteger(message.MaxConn.low) && $util.isInteger(message.MaxConn.high)))
                    return "MaxConn: integer|Long expected";
            if (message.ActiveOpens != null && message.hasOwnProperty("ActiveOpens"))
                if (!$util.isInteger(message.ActiveOpens) && !(message.ActiveOpens && $util.isInteger(message.ActiveOpens.low) && $util.isInteger(message.ActiveOpens.high)))
                    return "ActiveOpens: integer|Long expected";
            if (message.PassiveOpens != null && message.hasOwnProperty("PassiveOpens"))
                if (!$util.isInteger(message.PassiveOpens) && !(message.PassiveOpens && $util.isInteger(message.PassiveOpens.low) && $util.isInteger(message.PassiveOpens.high)))
                    return "PassiveOpens: integer|Long expected";
            if (message.AttemptFails != null && message.hasOwnProperty("AttemptFails"))
                if (!$util.isInteger(message.AttemptFails) && !(message.AttemptFails && $util.isInteger(message.AttemptFails.low) && $util.isInteger(message.AttemptFails.high)))
                    return "AttemptFails: integer|Long expected";
            if (message.EstabResets != null && message.hasOwnProperty("EstabResets"))
                if (!$util.isInteger(message.EstabResets) && !(message.EstabResets && $util.isInteger(message.EstabResets.low) && $util.isInteger(message.EstabResets.high)))
                    return "EstabResets: integer|Long expected";
            if (message.CurrEstab != null && message.hasOwnProperty("CurrEstab"))
                if (!$util.isInteger(message.CurrEstab) && !(message.CurrEstab && $util.isInteger(message.CurrEstab.low) && $util.isInteger(message.CurrEstab.high)))
                    return "CurrEstab: integer|Long expected";
            if (message.InSegs != null && message.hasOwnProperty("InSegs"))
                if (!$util.isInteger(message.InSegs) && !(message.InSegs && $util.isInteger(message.InSegs.low) && $util.isInteger(message.InSegs.high)))
                    return "InSegs: integer|Long expected";
            if (message.OutSegs != null && message.hasOwnProperty("OutSegs"))
                if (!$util.isInteger(message.OutSegs) && !(message.OutSegs && $util.isInteger(message.OutSegs.low) && $util.isInteger(message.OutSegs.high)))
                    return "OutSegs: integer|Long expected";
            if (message.RetransSegs != null && message.hasOwnProperty("RetransSegs"))
                if (!$util.isInteger(message.RetransSegs) && !(message.RetransSegs && $util.isInteger(message.RetransSegs.low) && $util.isInteger(message.RetransSegs.high)))
                    return "RetransSegs: integer|Long expected";
            if (message.InErrs != null && message.hasOwnProperty("InErrs"))
                if (!$util.isInteger(message.InErrs) && !(message.InErrs && $util.isInteger(message.InErrs.low) && $util.isInteger(message.InErrs.high)))
                    return "InErrs: integer|Long expected";
            if (message.OutRsts != null && message.hasOwnProperty("OutRsts"))
                if (!$util.isInteger(message.OutRsts) && !(message.OutRsts && $util.isInteger(message.OutRsts.low) && $util.isInteger(message.OutRsts.high)))
                    return "OutRsts: integer|Long expected";
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (!$util.isInteger(message.InCsumErrors) && !(message.InCsumErrors && $util.isInteger(message.InCsumErrors.low) && $util.isInteger(message.InCsumErrors.high)))
                    return "InCsumErrors: integer|Long expected";
            return null;
        };

        /**
         * Creates a TcpStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TcpStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TcpStatistics} TcpStatistics
         */
        TcpStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TcpStatistics)
                return object;
            let message = new $root.mesos.TcpStatistics();
            if (object.RtoAlgorithm != null)
                if ($util.Long)
                    (message.RtoAlgorithm = $util.Long.fromValue(object.RtoAlgorithm)).unsigned = false;
                else if (typeof object.RtoAlgorithm === "string")
                    message.RtoAlgorithm = parseInt(object.RtoAlgorithm, 10);
                else if (typeof object.RtoAlgorithm === "number")
                    message.RtoAlgorithm = object.RtoAlgorithm;
                else if (typeof object.RtoAlgorithm === "object")
                    message.RtoAlgorithm = new $util.LongBits(object.RtoAlgorithm.low >>> 0, object.RtoAlgorithm.high >>> 0).toNumber();
            if (object.RtoMin != null)
                if ($util.Long)
                    (message.RtoMin = $util.Long.fromValue(object.RtoMin)).unsigned = false;
                else if (typeof object.RtoMin === "string")
                    message.RtoMin = parseInt(object.RtoMin, 10);
                else if (typeof object.RtoMin === "number")
                    message.RtoMin = object.RtoMin;
                else if (typeof object.RtoMin === "object")
                    message.RtoMin = new $util.LongBits(object.RtoMin.low >>> 0, object.RtoMin.high >>> 0).toNumber();
            if (object.RtoMax != null)
                if ($util.Long)
                    (message.RtoMax = $util.Long.fromValue(object.RtoMax)).unsigned = false;
                else if (typeof object.RtoMax === "string")
                    message.RtoMax = parseInt(object.RtoMax, 10);
                else if (typeof object.RtoMax === "number")
                    message.RtoMax = object.RtoMax;
                else if (typeof object.RtoMax === "object")
                    message.RtoMax = new $util.LongBits(object.RtoMax.low >>> 0, object.RtoMax.high >>> 0).toNumber();
            if (object.MaxConn != null)
                if ($util.Long)
                    (message.MaxConn = $util.Long.fromValue(object.MaxConn)).unsigned = false;
                else if (typeof object.MaxConn === "string")
                    message.MaxConn = parseInt(object.MaxConn, 10);
                else if (typeof object.MaxConn === "number")
                    message.MaxConn = object.MaxConn;
                else if (typeof object.MaxConn === "object")
                    message.MaxConn = new $util.LongBits(object.MaxConn.low >>> 0, object.MaxConn.high >>> 0).toNumber();
            if (object.ActiveOpens != null)
                if ($util.Long)
                    (message.ActiveOpens = $util.Long.fromValue(object.ActiveOpens)).unsigned = false;
                else if (typeof object.ActiveOpens === "string")
                    message.ActiveOpens = parseInt(object.ActiveOpens, 10);
                else if (typeof object.ActiveOpens === "number")
                    message.ActiveOpens = object.ActiveOpens;
                else if (typeof object.ActiveOpens === "object")
                    message.ActiveOpens = new $util.LongBits(object.ActiveOpens.low >>> 0, object.ActiveOpens.high >>> 0).toNumber();
            if (object.PassiveOpens != null)
                if ($util.Long)
                    (message.PassiveOpens = $util.Long.fromValue(object.PassiveOpens)).unsigned = false;
                else if (typeof object.PassiveOpens === "string")
                    message.PassiveOpens = parseInt(object.PassiveOpens, 10);
                else if (typeof object.PassiveOpens === "number")
                    message.PassiveOpens = object.PassiveOpens;
                else if (typeof object.PassiveOpens === "object")
                    message.PassiveOpens = new $util.LongBits(object.PassiveOpens.low >>> 0, object.PassiveOpens.high >>> 0).toNumber();
            if (object.AttemptFails != null)
                if ($util.Long)
                    (message.AttemptFails = $util.Long.fromValue(object.AttemptFails)).unsigned = false;
                else if (typeof object.AttemptFails === "string")
                    message.AttemptFails = parseInt(object.AttemptFails, 10);
                else if (typeof object.AttemptFails === "number")
                    message.AttemptFails = object.AttemptFails;
                else if (typeof object.AttemptFails === "object")
                    message.AttemptFails = new $util.LongBits(object.AttemptFails.low >>> 0, object.AttemptFails.high >>> 0).toNumber();
            if (object.EstabResets != null)
                if ($util.Long)
                    (message.EstabResets = $util.Long.fromValue(object.EstabResets)).unsigned = false;
                else if (typeof object.EstabResets === "string")
                    message.EstabResets = parseInt(object.EstabResets, 10);
                else if (typeof object.EstabResets === "number")
                    message.EstabResets = object.EstabResets;
                else if (typeof object.EstabResets === "object")
                    message.EstabResets = new $util.LongBits(object.EstabResets.low >>> 0, object.EstabResets.high >>> 0).toNumber();
            if (object.CurrEstab != null)
                if ($util.Long)
                    (message.CurrEstab = $util.Long.fromValue(object.CurrEstab)).unsigned = false;
                else if (typeof object.CurrEstab === "string")
                    message.CurrEstab = parseInt(object.CurrEstab, 10);
                else if (typeof object.CurrEstab === "number")
                    message.CurrEstab = object.CurrEstab;
                else if (typeof object.CurrEstab === "object")
                    message.CurrEstab = new $util.LongBits(object.CurrEstab.low >>> 0, object.CurrEstab.high >>> 0).toNumber();
            if (object.InSegs != null)
                if ($util.Long)
                    (message.InSegs = $util.Long.fromValue(object.InSegs)).unsigned = false;
                else if (typeof object.InSegs === "string")
                    message.InSegs = parseInt(object.InSegs, 10);
                else if (typeof object.InSegs === "number")
                    message.InSegs = object.InSegs;
                else if (typeof object.InSegs === "object")
                    message.InSegs = new $util.LongBits(object.InSegs.low >>> 0, object.InSegs.high >>> 0).toNumber();
            if (object.OutSegs != null)
                if ($util.Long)
                    (message.OutSegs = $util.Long.fromValue(object.OutSegs)).unsigned = false;
                else if (typeof object.OutSegs === "string")
                    message.OutSegs = parseInt(object.OutSegs, 10);
                else if (typeof object.OutSegs === "number")
                    message.OutSegs = object.OutSegs;
                else if (typeof object.OutSegs === "object")
                    message.OutSegs = new $util.LongBits(object.OutSegs.low >>> 0, object.OutSegs.high >>> 0).toNumber();
            if (object.RetransSegs != null)
                if ($util.Long)
                    (message.RetransSegs = $util.Long.fromValue(object.RetransSegs)).unsigned = false;
                else if (typeof object.RetransSegs === "string")
                    message.RetransSegs = parseInt(object.RetransSegs, 10);
                else if (typeof object.RetransSegs === "number")
                    message.RetransSegs = object.RetransSegs;
                else if (typeof object.RetransSegs === "object")
                    message.RetransSegs = new $util.LongBits(object.RetransSegs.low >>> 0, object.RetransSegs.high >>> 0).toNumber();
            if (object.InErrs != null)
                if ($util.Long)
                    (message.InErrs = $util.Long.fromValue(object.InErrs)).unsigned = false;
                else if (typeof object.InErrs === "string")
                    message.InErrs = parseInt(object.InErrs, 10);
                else if (typeof object.InErrs === "number")
                    message.InErrs = object.InErrs;
                else if (typeof object.InErrs === "object")
                    message.InErrs = new $util.LongBits(object.InErrs.low >>> 0, object.InErrs.high >>> 0).toNumber();
            if (object.OutRsts != null)
                if ($util.Long)
                    (message.OutRsts = $util.Long.fromValue(object.OutRsts)).unsigned = false;
                else if (typeof object.OutRsts === "string")
                    message.OutRsts = parseInt(object.OutRsts, 10);
                else if (typeof object.OutRsts === "number")
                    message.OutRsts = object.OutRsts;
                else if (typeof object.OutRsts === "object")
                    message.OutRsts = new $util.LongBits(object.OutRsts.low >>> 0, object.OutRsts.high >>> 0).toNumber();
            if (object.InCsumErrors != null)
                if ($util.Long)
                    (message.InCsumErrors = $util.Long.fromValue(object.InCsumErrors)).unsigned = false;
                else if (typeof object.InCsumErrors === "string")
                    message.InCsumErrors = parseInt(object.InCsumErrors, 10);
                else if (typeof object.InCsumErrors === "number")
                    message.InCsumErrors = object.InCsumErrors;
                else if (typeof object.InCsumErrors === "object")
                    message.InCsumErrors = new $util.LongBits(object.InCsumErrors.low >>> 0, object.InCsumErrors.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TcpStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TcpStatistics
         * @static
         * @param {mesos.TcpStatistics} message TcpStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TcpStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RtoAlgorithm = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RtoAlgorithm = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RtoMin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RtoMin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RtoMax = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RtoMax = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.MaxConn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.MaxConn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ActiveOpens = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ActiveOpens = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PassiveOpens = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PassiveOpens = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AttemptFails = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AttemptFails = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.EstabResets = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.EstabResets = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.CurrEstab = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.CurrEstab = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InSegs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InSegs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutSegs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutSegs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RetransSegs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RetransSegs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InErrs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InErrs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutRsts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutRsts = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InCsumErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InCsumErrors = options.longs === String ? "0" : 0;
            }
            if (message.RtoAlgorithm != null && message.hasOwnProperty("RtoAlgorithm"))
                if (typeof message.RtoAlgorithm === "number")
                    object.RtoAlgorithm = options.longs === String ? String(message.RtoAlgorithm) : message.RtoAlgorithm;
                else
                    object.RtoAlgorithm = options.longs === String ? $util.Long.prototype.toString.call(message.RtoAlgorithm) : options.longs === Number ? new $util.LongBits(message.RtoAlgorithm.low >>> 0, message.RtoAlgorithm.high >>> 0).toNumber() : message.RtoAlgorithm;
            if (message.RtoMin != null && message.hasOwnProperty("RtoMin"))
                if (typeof message.RtoMin === "number")
                    object.RtoMin = options.longs === String ? String(message.RtoMin) : message.RtoMin;
                else
                    object.RtoMin = options.longs === String ? $util.Long.prototype.toString.call(message.RtoMin) : options.longs === Number ? new $util.LongBits(message.RtoMin.low >>> 0, message.RtoMin.high >>> 0).toNumber() : message.RtoMin;
            if (message.RtoMax != null && message.hasOwnProperty("RtoMax"))
                if (typeof message.RtoMax === "number")
                    object.RtoMax = options.longs === String ? String(message.RtoMax) : message.RtoMax;
                else
                    object.RtoMax = options.longs === String ? $util.Long.prototype.toString.call(message.RtoMax) : options.longs === Number ? new $util.LongBits(message.RtoMax.low >>> 0, message.RtoMax.high >>> 0).toNumber() : message.RtoMax;
            if (message.MaxConn != null && message.hasOwnProperty("MaxConn"))
                if (typeof message.MaxConn === "number")
                    object.MaxConn = options.longs === String ? String(message.MaxConn) : message.MaxConn;
                else
                    object.MaxConn = options.longs === String ? $util.Long.prototype.toString.call(message.MaxConn) : options.longs === Number ? new $util.LongBits(message.MaxConn.low >>> 0, message.MaxConn.high >>> 0).toNumber() : message.MaxConn;
            if (message.ActiveOpens != null && message.hasOwnProperty("ActiveOpens"))
                if (typeof message.ActiveOpens === "number")
                    object.ActiveOpens = options.longs === String ? String(message.ActiveOpens) : message.ActiveOpens;
                else
                    object.ActiveOpens = options.longs === String ? $util.Long.prototype.toString.call(message.ActiveOpens) : options.longs === Number ? new $util.LongBits(message.ActiveOpens.low >>> 0, message.ActiveOpens.high >>> 0).toNumber() : message.ActiveOpens;
            if (message.PassiveOpens != null && message.hasOwnProperty("PassiveOpens"))
                if (typeof message.PassiveOpens === "number")
                    object.PassiveOpens = options.longs === String ? String(message.PassiveOpens) : message.PassiveOpens;
                else
                    object.PassiveOpens = options.longs === String ? $util.Long.prototype.toString.call(message.PassiveOpens) : options.longs === Number ? new $util.LongBits(message.PassiveOpens.low >>> 0, message.PassiveOpens.high >>> 0).toNumber() : message.PassiveOpens;
            if (message.AttemptFails != null && message.hasOwnProperty("AttemptFails"))
                if (typeof message.AttemptFails === "number")
                    object.AttemptFails = options.longs === String ? String(message.AttemptFails) : message.AttemptFails;
                else
                    object.AttemptFails = options.longs === String ? $util.Long.prototype.toString.call(message.AttemptFails) : options.longs === Number ? new $util.LongBits(message.AttemptFails.low >>> 0, message.AttemptFails.high >>> 0).toNumber() : message.AttemptFails;
            if (message.EstabResets != null && message.hasOwnProperty("EstabResets"))
                if (typeof message.EstabResets === "number")
                    object.EstabResets = options.longs === String ? String(message.EstabResets) : message.EstabResets;
                else
                    object.EstabResets = options.longs === String ? $util.Long.prototype.toString.call(message.EstabResets) : options.longs === Number ? new $util.LongBits(message.EstabResets.low >>> 0, message.EstabResets.high >>> 0).toNumber() : message.EstabResets;
            if (message.CurrEstab != null && message.hasOwnProperty("CurrEstab"))
                if (typeof message.CurrEstab === "number")
                    object.CurrEstab = options.longs === String ? String(message.CurrEstab) : message.CurrEstab;
                else
                    object.CurrEstab = options.longs === String ? $util.Long.prototype.toString.call(message.CurrEstab) : options.longs === Number ? new $util.LongBits(message.CurrEstab.low >>> 0, message.CurrEstab.high >>> 0).toNumber() : message.CurrEstab;
            if (message.InSegs != null && message.hasOwnProperty("InSegs"))
                if (typeof message.InSegs === "number")
                    object.InSegs = options.longs === String ? String(message.InSegs) : message.InSegs;
                else
                    object.InSegs = options.longs === String ? $util.Long.prototype.toString.call(message.InSegs) : options.longs === Number ? new $util.LongBits(message.InSegs.low >>> 0, message.InSegs.high >>> 0).toNumber() : message.InSegs;
            if (message.OutSegs != null && message.hasOwnProperty("OutSegs"))
                if (typeof message.OutSegs === "number")
                    object.OutSegs = options.longs === String ? String(message.OutSegs) : message.OutSegs;
                else
                    object.OutSegs = options.longs === String ? $util.Long.prototype.toString.call(message.OutSegs) : options.longs === Number ? new $util.LongBits(message.OutSegs.low >>> 0, message.OutSegs.high >>> 0).toNumber() : message.OutSegs;
            if (message.RetransSegs != null && message.hasOwnProperty("RetransSegs"))
                if (typeof message.RetransSegs === "number")
                    object.RetransSegs = options.longs === String ? String(message.RetransSegs) : message.RetransSegs;
                else
                    object.RetransSegs = options.longs === String ? $util.Long.prototype.toString.call(message.RetransSegs) : options.longs === Number ? new $util.LongBits(message.RetransSegs.low >>> 0, message.RetransSegs.high >>> 0).toNumber() : message.RetransSegs;
            if (message.InErrs != null && message.hasOwnProperty("InErrs"))
                if (typeof message.InErrs === "number")
                    object.InErrs = options.longs === String ? String(message.InErrs) : message.InErrs;
                else
                    object.InErrs = options.longs === String ? $util.Long.prototype.toString.call(message.InErrs) : options.longs === Number ? new $util.LongBits(message.InErrs.low >>> 0, message.InErrs.high >>> 0).toNumber() : message.InErrs;
            if (message.OutRsts != null && message.hasOwnProperty("OutRsts"))
                if (typeof message.OutRsts === "number")
                    object.OutRsts = options.longs === String ? String(message.OutRsts) : message.OutRsts;
                else
                    object.OutRsts = options.longs === String ? $util.Long.prototype.toString.call(message.OutRsts) : options.longs === Number ? new $util.LongBits(message.OutRsts.low >>> 0, message.OutRsts.high >>> 0).toNumber() : message.OutRsts;
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (typeof message.InCsumErrors === "number")
                    object.InCsumErrors = options.longs === String ? String(message.InCsumErrors) : message.InCsumErrors;
                else
                    object.InCsumErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InCsumErrors) : options.longs === Number ? new $util.LongBits(message.InCsumErrors.low >>> 0, message.InCsumErrors.high >>> 0).toNumber() : message.InCsumErrors;
            return object;
        };

        /**
         * Converts this TcpStatistics to JSON.
         * @function toJSON
         * @memberof mesos.TcpStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TcpStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TcpStatistics;
    })();

    mesos.UdpStatistics = (function() {

        /**
         * Properties of an UdpStatistics.
         * @memberof mesos
         * @interface IUdpStatistics
         * @property {number|Long} [InDatagrams] UdpStatistics InDatagrams
         * @property {number|Long} [NoPorts] UdpStatistics NoPorts
         * @property {number|Long} [InErrors] UdpStatistics InErrors
         * @property {number|Long} [OutDatagrams] UdpStatistics OutDatagrams
         * @property {number|Long} [RcvbufErrors] UdpStatistics RcvbufErrors
         * @property {number|Long} [SndbufErrors] UdpStatistics SndbufErrors
         * @property {number|Long} [InCsumErrors] UdpStatistics InCsumErrors
         * @property {number|Long} [IgnoredMulti] UdpStatistics IgnoredMulti
         */

        /**
         * Constructs a new UdpStatistics.
         * @memberof mesos
         * @classdesc Represents an UdpStatistics.
         * @constructor
         * @param {mesos.IUdpStatistics=} [properties] Properties to set
         */
        function UdpStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UdpStatistics InDatagrams.
         * @member {number|Long}InDatagrams
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.InDatagrams = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics NoPorts.
         * @member {number|Long}NoPorts
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.NoPorts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics InErrors.
         * @member {number|Long}InErrors
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.InErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics OutDatagrams.
         * @member {number|Long}OutDatagrams
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.OutDatagrams = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics RcvbufErrors.
         * @member {number|Long}RcvbufErrors
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.RcvbufErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics SndbufErrors.
         * @member {number|Long}SndbufErrors
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.SndbufErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics InCsumErrors.
         * @member {number|Long}InCsumErrors
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.InCsumErrors = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UdpStatistics IgnoredMulti.
         * @member {number|Long}IgnoredMulti
         * @memberof mesos.UdpStatistics
         * @instance
         */
        UdpStatistics.prototype.IgnoredMulti = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UdpStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.UdpStatistics
         * @static
         * @param {mesos.IUdpStatistics=} [properties] Properties to set
         * @returns {mesos.UdpStatistics} UdpStatistics instance
         */
        UdpStatistics.create = function create(properties) {
            return new UdpStatistics(properties);
        };

        /**
         * Encodes the specified UdpStatistics message. Does not implicitly {@link mesos.UdpStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.UdpStatistics
         * @static
         * @param {mesos.IUdpStatistics} message UdpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UdpStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.InDatagrams != null && message.hasOwnProperty("InDatagrams"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.InDatagrams);
            if (message.NoPorts != null && message.hasOwnProperty("NoPorts"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.NoPorts);
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.InErrors);
            if (message.OutDatagrams != null && message.hasOwnProperty("OutDatagrams"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.OutDatagrams);
            if (message.RcvbufErrors != null && message.hasOwnProperty("RcvbufErrors"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.RcvbufErrors);
            if (message.SndbufErrors != null && message.hasOwnProperty("SndbufErrors"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.SndbufErrors);
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.InCsumErrors);
            if (message.IgnoredMulti != null && message.hasOwnProperty("IgnoredMulti"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.IgnoredMulti);
            return writer;
        };

        /**
         * Encodes the specified UdpStatistics message, length delimited. Does not implicitly {@link mesos.UdpStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.UdpStatistics
         * @static
         * @param {mesos.IUdpStatistics} message UdpStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UdpStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UdpStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.UdpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.UdpStatistics} UdpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UdpStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.UdpStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.InDatagrams = reader.int64();
                    break;
                case 2:
                    message.NoPorts = reader.int64();
                    break;
                case 3:
                    message.InErrors = reader.int64();
                    break;
                case 4:
                    message.OutDatagrams = reader.int64();
                    break;
                case 5:
                    message.RcvbufErrors = reader.int64();
                    break;
                case 6:
                    message.SndbufErrors = reader.int64();
                    break;
                case 7:
                    message.InCsumErrors = reader.int64();
                    break;
                case 8:
                    message.IgnoredMulti = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UdpStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.UdpStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.UdpStatistics} UdpStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UdpStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UdpStatistics message.
         * @function verify
         * @memberof mesos.UdpStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UdpStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.InDatagrams != null && message.hasOwnProperty("InDatagrams"))
                if (!$util.isInteger(message.InDatagrams) && !(message.InDatagrams && $util.isInteger(message.InDatagrams.low) && $util.isInteger(message.InDatagrams.high)))
                    return "InDatagrams: integer|Long expected";
            if (message.NoPorts != null && message.hasOwnProperty("NoPorts"))
                if (!$util.isInteger(message.NoPorts) && !(message.NoPorts && $util.isInteger(message.NoPorts.low) && $util.isInteger(message.NoPorts.high)))
                    return "NoPorts: integer|Long expected";
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                if (!$util.isInteger(message.InErrors) && !(message.InErrors && $util.isInteger(message.InErrors.low) && $util.isInteger(message.InErrors.high)))
                    return "InErrors: integer|Long expected";
            if (message.OutDatagrams != null && message.hasOwnProperty("OutDatagrams"))
                if (!$util.isInteger(message.OutDatagrams) && !(message.OutDatagrams && $util.isInteger(message.OutDatagrams.low) && $util.isInteger(message.OutDatagrams.high)))
                    return "OutDatagrams: integer|Long expected";
            if (message.RcvbufErrors != null && message.hasOwnProperty("RcvbufErrors"))
                if (!$util.isInteger(message.RcvbufErrors) && !(message.RcvbufErrors && $util.isInteger(message.RcvbufErrors.low) && $util.isInteger(message.RcvbufErrors.high)))
                    return "RcvbufErrors: integer|Long expected";
            if (message.SndbufErrors != null && message.hasOwnProperty("SndbufErrors"))
                if (!$util.isInteger(message.SndbufErrors) && !(message.SndbufErrors && $util.isInteger(message.SndbufErrors.low) && $util.isInteger(message.SndbufErrors.high)))
                    return "SndbufErrors: integer|Long expected";
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (!$util.isInteger(message.InCsumErrors) && !(message.InCsumErrors && $util.isInteger(message.InCsumErrors.low) && $util.isInteger(message.InCsumErrors.high)))
                    return "InCsumErrors: integer|Long expected";
            if (message.IgnoredMulti != null && message.hasOwnProperty("IgnoredMulti"))
                if (!$util.isInteger(message.IgnoredMulti) && !(message.IgnoredMulti && $util.isInteger(message.IgnoredMulti.low) && $util.isInteger(message.IgnoredMulti.high)))
                    return "IgnoredMulti: integer|Long expected";
            return null;
        };

        /**
         * Creates an UdpStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.UdpStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.UdpStatistics} UdpStatistics
         */
        UdpStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.UdpStatistics)
                return object;
            let message = new $root.mesos.UdpStatistics();
            if (object.InDatagrams != null)
                if ($util.Long)
                    (message.InDatagrams = $util.Long.fromValue(object.InDatagrams)).unsigned = false;
                else if (typeof object.InDatagrams === "string")
                    message.InDatagrams = parseInt(object.InDatagrams, 10);
                else if (typeof object.InDatagrams === "number")
                    message.InDatagrams = object.InDatagrams;
                else if (typeof object.InDatagrams === "object")
                    message.InDatagrams = new $util.LongBits(object.InDatagrams.low >>> 0, object.InDatagrams.high >>> 0).toNumber();
            if (object.NoPorts != null)
                if ($util.Long)
                    (message.NoPorts = $util.Long.fromValue(object.NoPorts)).unsigned = false;
                else if (typeof object.NoPorts === "string")
                    message.NoPorts = parseInt(object.NoPorts, 10);
                else if (typeof object.NoPorts === "number")
                    message.NoPorts = object.NoPorts;
                else if (typeof object.NoPorts === "object")
                    message.NoPorts = new $util.LongBits(object.NoPorts.low >>> 0, object.NoPorts.high >>> 0).toNumber();
            if (object.InErrors != null)
                if ($util.Long)
                    (message.InErrors = $util.Long.fromValue(object.InErrors)).unsigned = false;
                else if (typeof object.InErrors === "string")
                    message.InErrors = parseInt(object.InErrors, 10);
                else if (typeof object.InErrors === "number")
                    message.InErrors = object.InErrors;
                else if (typeof object.InErrors === "object")
                    message.InErrors = new $util.LongBits(object.InErrors.low >>> 0, object.InErrors.high >>> 0).toNumber();
            if (object.OutDatagrams != null)
                if ($util.Long)
                    (message.OutDatagrams = $util.Long.fromValue(object.OutDatagrams)).unsigned = false;
                else if (typeof object.OutDatagrams === "string")
                    message.OutDatagrams = parseInt(object.OutDatagrams, 10);
                else if (typeof object.OutDatagrams === "number")
                    message.OutDatagrams = object.OutDatagrams;
                else if (typeof object.OutDatagrams === "object")
                    message.OutDatagrams = new $util.LongBits(object.OutDatagrams.low >>> 0, object.OutDatagrams.high >>> 0).toNumber();
            if (object.RcvbufErrors != null)
                if ($util.Long)
                    (message.RcvbufErrors = $util.Long.fromValue(object.RcvbufErrors)).unsigned = false;
                else if (typeof object.RcvbufErrors === "string")
                    message.RcvbufErrors = parseInt(object.RcvbufErrors, 10);
                else if (typeof object.RcvbufErrors === "number")
                    message.RcvbufErrors = object.RcvbufErrors;
                else if (typeof object.RcvbufErrors === "object")
                    message.RcvbufErrors = new $util.LongBits(object.RcvbufErrors.low >>> 0, object.RcvbufErrors.high >>> 0).toNumber();
            if (object.SndbufErrors != null)
                if ($util.Long)
                    (message.SndbufErrors = $util.Long.fromValue(object.SndbufErrors)).unsigned = false;
                else if (typeof object.SndbufErrors === "string")
                    message.SndbufErrors = parseInt(object.SndbufErrors, 10);
                else if (typeof object.SndbufErrors === "number")
                    message.SndbufErrors = object.SndbufErrors;
                else if (typeof object.SndbufErrors === "object")
                    message.SndbufErrors = new $util.LongBits(object.SndbufErrors.low >>> 0, object.SndbufErrors.high >>> 0).toNumber();
            if (object.InCsumErrors != null)
                if ($util.Long)
                    (message.InCsumErrors = $util.Long.fromValue(object.InCsumErrors)).unsigned = false;
                else if (typeof object.InCsumErrors === "string")
                    message.InCsumErrors = parseInt(object.InCsumErrors, 10);
                else if (typeof object.InCsumErrors === "number")
                    message.InCsumErrors = object.InCsumErrors;
                else if (typeof object.InCsumErrors === "object")
                    message.InCsumErrors = new $util.LongBits(object.InCsumErrors.low >>> 0, object.InCsumErrors.high >>> 0).toNumber();
            if (object.IgnoredMulti != null)
                if ($util.Long)
                    (message.IgnoredMulti = $util.Long.fromValue(object.IgnoredMulti)).unsigned = false;
                else if (typeof object.IgnoredMulti === "string")
                    message.IgnoredMulti = parseInt(object.IgnoredMulti, 10);
                else if (typeof object.IgnoredMulti === "number")
                    message.IgnoredMulti = object.IgnoredMulti;
                else if (typeof object.IgnoredMulti === "object")
                    message.IgnoredMulti = new $util.LongBits(object.IgnoredMulti.low >>> 0, object.IgnoredMulti.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UdpStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.UdpStatistics
         * @static
         * @param {mesos.UdpStatistics} message UdpStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UdpStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InDatagrams = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InDatagrams = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.NoPorts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.NoPorts = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OutDatagrams = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OutDatagrams = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RcvbufErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RcvbufErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SndbufErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SndbufErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InCsumErrors = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InCsumErrors = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.IgnoredMulti = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.IgnoredMulti = options.longs === String ? "0" : 0;
            }
            if (message.InDatagrams != null && message.hasOwnProperty("InDatagrams"))
                if (typeof message.InDatagrams === "number")
                    object.InDatagrams = options.longs === String ? String(message.InDatagrams) : message.InDatagrams;
                else
                    object.InDatagrams = options.longs === String ? $util.Long.prototype.toString.call(message.InDatagrams) : options.longs === Number ? new $util.LongBits(message.InDatagrams.low >>> 0, message.InDatagrams.high >>> 0).toNumber() : message.InDatagrams;
            if (message.NoPorts != null && message.hasOwnProperty("NoPorts"))
                if (typeof message.NoPorts === "number")
                    object.NoPorts = options.longs === String ? String(message.NoPorts) : message.NoPorts;
                else
                    object.NoPorts = options.longs === String ? $util.Long.prototype.toString.call(message.NoPorts) : options.longs === Number ? new $util.LongBits(message.NoPorts.low >>> 0, message.NoPorts.high >>> 0).toNumber() : message.NoPorts;
            if (message.InErrors != null && message.hasOwnProperty("InErrors"))
                if (typeof message.InErrors === "number")
                    object.InErrors = options.longs === String ? String(message.InErrors) : message.InErrors;
                else
                    object.InErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InErrors) : options.longs === Number ? new $util.LongBits(message.InErrors.low >>> 0, message.InErrors.high >>> 0).toNumber() : message.InErrors;
            if (message.OutDatagrams != null && message.hasOwnProperty("OutDatagrams"))
                if (typeof message.OutDatagrams === "number")
                    object.OutDatagrams = options.longs === String ? String(message.OutDatagrams) : message.OutDatagrams;
                else
                    object.OutDatagrams = options.longs === String ? $util.Long.prototype.toString.call(message.OutDatagrams) : options.longs === Number ? new $util.LongBits(message.OutDatagrams.low >>> 0, message.OutDatagrams.high >>> 0).toNumber() : message.OutDatagrams;
            if (message.RcvbufErrors != null && message.hasOwnProperty("RcvbufErrors"))
                if (typeof message.RcvbufErrors === "number")
                    object.RcvbufErrors = options.longs === String ? String(message.RcvbufErrors) : message.RcvbufErrors;
                else
                    object.RcvbufErrors = options.longs === String ? $util.Long.prototype.toString.call(message.RcvbufErrors) : options.longs === Number ? new $util.LongBits(message.RcvbufErrors.low >>> 0, message.RcvbufErrors.high >>> 0).toNumber() : message.RcvbufErrors;
            if (message.SndbufErrors != null && message.hasOwnProperty("SndbufErrors"))
                if (typeof message.SndbufErrors === "number")
                    object.SndbufErrors = options.longs === String ? String(message.SndbufErrors) : message.SndbufErrors;
                else
                    object.SndbufErrors = options.longs === String ? $util.Long.prototype.toString.call(message.SndbufErrors) : options.longs === Number ? new $util.LongBits(message.SndbufErrors.low >>> 0, message.SndbufErrors.high >>> 0).toNumber() : message.SndbufErrors;
            if (message.InCsumErrors != null && message.hasOwnProperty("InCsumErrors"))
                if (typeof message.InCsumErrors === "number")
                    object.InCsumErrors = options.longs === String ? String(message.InCsumErrors) : message.InCsumErrors;
                else
                    object.InCsumErrors = options.longs === String ? $util.Long.prototype.toString.call(message.InCsumErrors) : options.longs === Number ? new $util.LongBits(message.InCsumErrors.low >>> 0, message.InCsumErrors.high >>> 0).toNumber() : message.InCsumErrors;
            if (message.IgnoredMulti != null && message.hasOwnProperty("IgnoredMulti"))
                if (typeof message.IgnoredMulti === "number")
                    object.IgnoredMulti = options.longs === String ? String(message.IgnoredMulti) : message.IgnoredMulti;
                else
                    object.IgnoredMulti = options.longs === String ? $util.Long.prototype.toString.call(message.IgnoredMulti) : options.longs === Number ? new $util.LongBits(message.IgnoredMulti.low >>> 0, message.IgnoredMulti.high >>> 0).toNumber() : message.IgnoredMulti;
            return object;
        };

        /**
         * Converts this UdpStatistics to JSON.
         * @function toJSON
         * @memberof mesos.UdpStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UdpStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UdpStatistics;
    })();

    mesos.SNMPStatistics = (function() {

        /**
         * Properties of a SNMPStatistics.
         * @memberof mesos
         * @interface ISNMPStatistics
         * @property {mesos.IIpStatistics} [ipStats] SNMPStatistics ipStats
         * @property {mesos.IIcmpStatistics} [icmpStats] SNMPStatistics icmpStats
         * @property {mesos.ITcpStatistics} [tcpStats] SNMPStatistics tcpStats
         * @property {mesos.IUdpStatistics} [udpStats] SNMPStatistics udpStats
         */

        /**
         * Constructs a new SNMPStatistics.
         * @memberof mesos
         * @classdesc Represents a SNMPStatistics.
         * @constructor
         * @param {mesos.ISNMPStatistics=} [properties] Properties to set
         */
        function SNMPStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SNMPStatistics ipStats.
         * @member {(mesos.IIpStatistics|null|undefined)}ipStats
         * @memberof mesos.SNMPStatistics
         * @instance
         */
        SNMPStatistics.prototype.ipStats = null;

        /**
         * SNMPStatistics icmpStats.
         * @member {(mesos.IIcmpStatistics|null|undefined)}icmpStats
         * @memberof mesos.SNMPStatistics
         * @instance
         */
        SNMPStatistics.prototype.icmpStats = null;

        /**
         * SNMPStatistics tcpStats.
         * @member {(mesos.ITcpStatistics|null|undefined)}tcpStats
         * @memberof mesos.SNMPStatistics
         * @instance
         */
        SNMPStatistics.prototype.tcpStats = null;

        /**
         * SNMPStatistics udpStats.
         * @member {(mesos.IUdpStatistics|null|undefined)}udpStats
         * @memberof mesos.SNMPStatistics
         * @instance
         */
        SNMPStatistics.prototype.udpStats = null;

        /**
         * Creates a new SNMPStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {mesos.ISNMPStatistics=} [properties] Properties to set
         * @returns {mesos.SNMPStatistics} SNMPStatistics instance
         */
        SNMPStatistics.create = function create(properties) {
            return new SNMPStatistics(properties);
        };

        /**
         * Encodes the specified SNMPStatistics message. Does not implicitly {@link mesos.SNMPStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {mesos.ISNMPStatistics} message SNMPStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SNMPStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ipStats != null && message.hasOwnProperty("ipStats"))
                $root.mesos.IpStatistics.encode(message.ipStats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.icmpStats != null && message.hasOwnProperty("icmpStats"))
                $root.mesos.IcmpStatistics.encode(message.icmpStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.tcpStats != null && message.hasOwnProperty("tcpStats"))
                $root.mesos.TcpStatistics.encode(message.tcpStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.udpStats != null && message.hasOwnProperty("udpStats"))
                $root.mesos.UdpStatistics.encode(message.udpStats, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SNMPStatistics message, length delimited. Does not implicitly {@link mesos.SNMPStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {mesos.ISNMPStatistics} message SNMPStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SNMPStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SNMPStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.SNMPStatistics} SNMPStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SNMPStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.SNMPStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ipStats = $root.mesos.IpStatistics.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.icmpStats = $root.mesos.IcmpStatistics.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.tcpStats = $root.mesos.TcpStatistics.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.udpStats = $root.mesos.UdpStatistics.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SNMPStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.SNMPStatistics} SNMPStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SNMPStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SNMPStatistics message.
         * @function verify
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SNMPStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ipStats != null && message.hasOwnProperty("ipStats")) {
                let error = $root.mesos.IpStatistics.verify(message.ipStats);
                if (error)
                    return "ipStats." + error;
            }
            if (message.icmpStats != null && message.hasOwnProperty("icmpStats")) {
                error = $root.mesos.IcmpStatistics.verify(message.icmpStats);
                if (error)
                    return "icmpStats." + error;
            }
            if (message.tcpStats != null && message.hasOwnProperty("tcpStats")) {
                error = $root.mesos.TcpStatistics.verify(message.tcpStats);
                if (error)
                    return "tcpStats." + error;
            }
            if (message.udpStats != null && message.hasOwnProperty("udpStats")) {
                error = $root.mesos.UdpStatistics.verify(message.udpStats);
                if (error)
                    return "udpStats." + error;
            }
            return null;
        };

        /**
         * Creates a SNMPStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.SNMPStatistics} SNMPStatistics
         */
        SNMPStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.SNMPStatistics)
                return object;
            let message = new $root.mesos.SNMPStatistics();
            if (object.ipStats != null) {
                if (typeof object.ipStats !== "object")
                    throw TypeError(".mesos.SNMPStatistics.ipStats: object expected");
                message.ipStats = $root.mesos.IpStatistics.fromObject(object.ipStats);
            }
            if (object.icmpStats != null) {
                if (typeof object.icmpStats !== "object")
                    throw TypeError(".mesos.SNMPStatistics.icmpStats: object expected");
                message.icmpStats = $root.mesos.IcmpStatistics.fromObject(object.icmpStats);
            }
            if (object.tcpStats != null) {
                if (typeof object.tcpStats !== "object")
                    throw TypeError(".mesos.SNMPStatistics.tcpStats: object expected");
                message.tcpStats = $root.mesos.TcpStatistics.fromObject(object.tcpStats);
            }
            if (object.udpStats != null) {
                if (typeof object.udpStats !== "object")
                    throw TypeError(".mesos.SNMPStatistics.udpStats: object expected");
                message.udpStats = $root.mesos.UdpStatistics.fromObject(object.udpStats);
            }
            return message;
        };

        /**
         * Creates a plain object from a SNMPStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.SNMPStatistics
         * @static
         * @param {mesos.SNMPStatistics} message SNMPStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SNMPStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ipStats = null;
                object.icmpStats = null;
                object.tcpStats = null;
                object.udpStats = null;
            }
            if (message.ipStats != null && message.hasOwnProperty("ipStats"))
                object.ipStats = $root.mesos.IpStatistics.toObject(message.ipStats, options);
            if (message.icmpStats != null && message.hasOwnProperty("icmpStats"))
                object.icmpStats = $root.mesos.IcmpStatistics.toObject(message.icmpStats, options);
            if (message.tcpStats != null && message.hasOwnProperty("tcpStats"))
                object.tcpStats = $root.mesos.TcpStatistics.toObject(message.tcpStats, options);
            if (message.udpStats != null && message.hasOwnProperty("udpStats"))
                object.udpStats = $root.mesos.UdpStatistics.toObject(message.udpStats, options);
            return object;
        };

        /**
         * Converts this SNMPStatistics to JSON.
         * @function toJSON
         * @memberof mesos.SNMPStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SNMPStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SNMPStatistics;
    })();

    mesos.ResourceStatistics = (function() {

        /**
         * Properties of a ResourceStatistics.
         * @memberof mesos
         * @interface IResourceStatistics
         * @property {number} timestamp ResourceStatistics timestamp
         * @property {number} [processes] ResourceStatistics processes
         * @property {number} [threads] ResourceStatistics threads
         * @property {number} [cpusUserTimeSecs] ResourceStatistics cpusUserTimeSecs
         * @property {number} [cpusSystemTimeSecs] ResourceStatistics cpusSystemTimeSecs
         * @property {number} [cpusLimit] ResourceStatistics cpusLimit
         * @property {number} [cpusNrPeriods] ResourceStatistics cpusNrPeriods
         * @property {number} [cpusNrThrottled] ResourceStatistics cpusNrThrottled
         * @property {number} [cpusThrottledTimeSecs] ResourceStatistics cpusThrottledTimeSecs
         * @property {number} [memTotalBytes] ResourceStatistics memTotalBytes
         * @property {number} [memTotalMemswBytes] ResourceStatistics memTotalMemswBytes
         * @property {number} [memLimitBytes] ResourceStatistics memLimitBytes
         * @property {number} [memSoftLimitBytes] ResourceStatistics memSoftLimitBytes
         * @property {number} [memFileBytes] ResourceStatistics memFileBytes
         * @property {number} [memAnonBytes] ResourceStatistics memAnonBytes
         * @property {number} [memCacheBytes] ResourceStatistics memCacheBytes
         * @property {number} [memRssBytes] ResourceStatistics memRssBytes
         * @property {number} [memMappedFileBytes] ResourceStatistics memMappedFileBytes
         * @property {number} [memSwapBytes] ResourceStatistics memSwapBytes
         * @property {number} [memUnevictableBytes] ResourceStatistics memUnevictableBytes
         * @property {number} [memLowPressureCounter] ResourceStatistics memLowPressureCounter
         * @property {number} [memMediumPressureCounter] ResourceStatistics memMediumPressureCounter
         * @property {number} [memCriticalPressureCounter] ResourceStatistics memCriticalPressureCounter
         * @property {number} [diskLimitBytes] ResourceStatistics diskLimitBytes
         * @property {number} [diskUsedBytes] ResourceStatistics diskUsedBytes
         * @property {mesos.IPerfStatistics} [perf] ResourceStatistics perf
         * @property {number} [netRxPackets] ResourceStatistics netRxPackets
         * @property {number} [netRxBytes] ResourceStatistics netRxBytes
         * @property {number} [netRxErrors] ResourceStatistics netRxErrors
         * @property {number} [netRxDropped] ResourceStatistics netRxDropped
         * @property {number} [netTxPackets] ResourceStatistics netTxPackets
         * @property {number} [netTxBytes] ResourceStatistics netTxBytes
         * @property {number} [netTxErrors] ResourceStatistics netTxErrors
         * @property {number} [netTxDropped] ResourceStatistics netTxDropped
         * @property {number} [netTcpRttMicrosecsP50] ResourceStatistics netTcpRttMicrosecsP50
         * @property {number} [netTcpRttMicrosecsP90] ResourceStatistics netTcpRttMicrosecsP90
         * @property {number} [netTcpRttMicrosecsP95] ResourceStatistics netTcpRttMicrosecsP95
         * @property {number} [netTcpRttMicrosecsP99] ResourceStatistics netTcpRttMicrosecsP99
         * @property {number} [netTcpActiveConnections] ResourceStatistics netTcpActiveConnections
         * @property {number} [netTcpTimeWaitConnections] ResourceStatistics netTcpTimeWaitConnections
         * @property {Array.<mesos.ITrafficControlStatistics>} [netTrafficControlStatistics] ResourceStatistics netTrafficControlStatistics
         * @property {mesos.ISNMPStatistics} [netSnmpStatistics] ResourceStatistics netSnmpStatistics
         */

        /**
         * Constructs a new ResourceStatistics.
         * @memberof mesos
         * @classdesc A snapshot of resource usage statistics.
         * @constructor
         * @param {mesos.IResourceStatistics=} [properties] Properties to set
         */
        function ResourceStatistics(properties) {
            this.netTrafficControlStatistics = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceStatistics timestamp.
         * @member {number}timestamp
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.timestamp = 0;

        /**
         * ResourceStatistics processes.
         * @member {number}processes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.processes = 0;

        /**
         * ResourceStatistics threads.
         * @member {number}threads
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.threads = 0;

        /**
         * ResourceStatistics cpusUserTimeSecs.
         * @member {number}cpusUserTimeSecs
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusUserTimeSecs = 0;

        /**
         * ResourceStatistics cpusSystemTimeSecs.
         * @member {number}cpusSystemTimeSecs
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusSystemTimeSecs = 0;

        /**
         * ResourceStatistics cpusLimit.
         * @member {number}cpusLimit
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusLimit = 0;

        /**
         * ResourceStatistics cpusNrPeriods.
         * @member {number}cpusNrPeriods
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusNrPeriods = 0;

        /**
         * ResourceStatistics cpusNrThrottled.
         * @member {number}cpusNrThrottled
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusNrThrottled = 0;

        /**
         * ResourceStatistics cpusThrottledTimeSecs.
         * @member {number}cpusThrottledTimeSecs
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.cpusThrottledTimeSecs = 0;

        /**
         * ResourceStatistics memTotalBytes.
         * @member {number}memTotalBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memTotalBytes = 0;

        /**
         * ResourceStatistics memTotalMemswBytes.
         * @member {number}memTotalMemswBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memTotalMemswBytes = 0;

        /**
         * ResourceStatistics memLimitBytes.
         * @member {number}memLimitBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memLimitBytes = 0;

        /**
         * ResourceStatistics memSoftLimitBytes.
         * @member {number}memSoftLimitBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memSoftLimitBytes = 0;

        /**
         * ResourceStatistics memFileBytes.
         * @member {number}memFileBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memFileBytes = 0;

        /**
         * ResourceStatistics memAnonBytes.
         * @member {number}memAnonBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memAnonBytes = 0;

        /**
         * ResourceStatistics memCacheBytes.
         * @member {number}memCacheBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memCacheBytes = 0;

        /**
         * ResourceStatistics memRssBytes.
         * @member {number}memRssBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memRssBytes = 0;

        /**
         * ResourceStatistics memMappedFileBytes.
         * @member {number}memMappedFileBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memMappedFileBytes = 0;

        /**
         * ResourceStatistics memSwapBytes.
         * @member {number}memSwapBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memSwapBytes = 0;

        /**
         * ResourceStatistics memUnevictableBytes.
         * @member {number}memUnevictableBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memUnevictableBytes = 0;

        /**
         * ResourceStatistics memLowPressureCounter.
         * @member {number}memLowPressureCounter
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memLowPressureCounter = 0;

        /**
         * ResourceStatistics memMediumPressureCounter.
         * @member {number}memMediumPressureCounter
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memMediumPressureCounter = 0;

        /**
         * ResourceStatistics memCriticalPressureCounter.
         * @member {number}memCriticalPressureCounter
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.memCriticalPressureCounter = 0;

        /**
         * ResourceStatistics diskLimitBytes.
         * @member {number}diskLimitBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.diskLimitBytes = 0;

        /**
         * ResourceStatistics diskUsedBytes.
         * @member {number}diskUsedBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.diskUsedBytes = 0;

        /**
         * ResourceStatistics perf.
         * @member {(mesos.IPerfStatistics|null|undefined)}perf
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.perf = null;

        /**
         * ResourceStatistics netRxPackets.
         * @member {number}netRxPackets
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netRxPackets = 0;

        /**
         * ResourceStatistics netRxBytes.
         * @member {number}netRxBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netRxBytes = 0;

        /**
         * ResourceStatistics netRxErrors.
         * @member {number}netRxErrors
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netRxErrors = 0;

        /**
         * ResourceStatistics netRxDropped.
         * @member {number}netRxDropped
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netRxDropped = 0;

        /**
         * ResourceStatistics netTxPackets.
         * @member {number}netTxPackets
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTxPackets = 0;

        /**
         * ResourceStatistics netTxBytes.
         * @member {number}netTxBytes
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTxBytes = 0;

        /**
         * ResourceStatistics netTxErrors.
         * @member {number}netTxErrors
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTxErrors = 0;

        /**
         * ResourceStatistics netTxDropped.
         * @member {number}netTxDropped
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTxDropped = 0;

        /**
         * ResourceStatistics netTcpRttMicrosecsP50.
         * @member {number}netTcpRttMicrosecsP50
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpRttMicrosecsP50 = 0;

        /**
         * ResourceStatistics netTcpRttMicrosecsP90.
         * @member {number}netTcpRttMicrosecsP90
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpRttMicrosecsP90 = 0;

        /**
         * ResourceStatistics netTcpRttMicrosecsP95.
         * @member {number}netTcpRttMicrosecsP95
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpRttMicrosecsP95 = 0;

        /**
         * ResourceStatistics netTcpRttMicrosecsP99.
         * @member {number}netTcpRttMicrosecsP99
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpRttMicrosecsP99 = 0;

        /**
         * ResourceStatistics netTcpActiveConnections.
         * @member {number}netTcpActiveConnections
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpActiveConnections = 0;

        /**
         * ResourceStatistics netTcpTimeWaitConnections.
         * @member {number}netTcpTimeWaitConnections
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTcpTimeWaitConnections = 0;

        /**
         * ResourceStatistics netTrafficControlStatistics.
         * @member {Array.<mesos.ITrafficControlStatistics>}netTrafficControlStatistics
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netTrafficControlStatistics = $util.emptyArray;

        /**
         * ResourceStatistics netSnmpStatistics.
         * @member {(mesos.ISNMPStatistics|null|undefined)}netSnmpStatistics
         * @memberof mesos.ResourceStatistics
         * @instance
         */
        ResourceStatistics.prototype.netSnmpStatistics = null;

        /**
         * Creates a new ResourceStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {mesos.IResourceStatistics=} [properties] Properties to set
         * @returns {mesos.ResourceStatistics} ResourceStatistics instance
         */
        ResourceStatistics.create = function create(properties) {
            return new ResourceStatistics(properties);
        };

        /**
         * Encodes the specified ResourceStatistics message. Does not implicitly {@link mesos.ResourceStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {mesos.IResourceStatistics} message ResourceStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.timestamp);
            if (message.cpusUserTimeSecs != null && message.hasOwnProperty("cpusUserTimeSecs"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.cpusUserTimeSecs);
            if (message.cpusSystemTimeSecs != null && message.hasOwnProperty("cpusSystemTimeSecs"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.cpusSystemTimeSecs);
            if (message.cpusLimit != null && message.hasOwnProperty("cpusLimit"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.cpusLimit);
            if (message.memRssBytes != null && message.hasOwnProperty("memRssBytes"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.memRssBytes);
            if (message.memLimitBytes != null && message.hasOwnProperty("memLimitBytes"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.memLimitBytes);
            if (message.cpusNrPeriods != null && message.hasOwnProperty("cpusNrPeriods"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.cpusNrPeriods);
            if (message.cpusNrThrottled != null && message.hasOwnProperty("cpusNrThrottled"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.cpusNrThrottled);
            if (message.cpusThrottledTimeSecs != null && message.hasOwnProperty("cpusThrottledTimeSecs"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.cpusThrottledTimeSecs);
            if (message.memFileBytes != null && message.hasOwnProperty("memFileBytes"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.memFileBytes);
            if (message.memAnonBytes != null && message.hasOwnProperty("memAnonBytes"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.memAnonBytes);
            if (message.memMappedFileBytes != null && message.hasOwnProperty("memMappedFileBytes"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.memMappedFileBytes);
            if (message.perf != null && message.hasOwnProperty("perf"))
                $root.mesos.PerfStatistics.encode(message.perf, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.netRxPackets != null && message.hasOwnProperty("netRxPackets"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.netRxPackets);
            if (message.netRxBytes != null && message.hasOwnProperty("netRxBytes"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.netRxBytes);
            if (message.netRxErrors != null && message.hasOwnProperty("netRxErrors"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.netRxErrors);
            if (message.netRxDropped != null && message.hasOwnProperty("netRxDropped"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.netRxDropped);
            if (message.netTxPackets != null && message.hasOwnProperty("netTxPackets"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.netTxPackets);
            if (message.netTxBytes != null && message.hasOwnProperty("netTxBytes"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.netTxBytes);
            if (message.netTxErrors != null && message.hasOwnProperty("netTxErrors"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.netTxErrors);
            if (message.netTxDropped != null && message.hasOwnProperty("netTxDropped"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.netTxDropped);
            if (message.netTcpRttMicrosecsP50 != null && message.hasOwnProperty("netTcpRttMicrosecsP50"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.netTcpRttMicrosecsP50);
            if (message.netTcpRttMicrosecsP90 != null && message.hasOwnProperty("netTcpRttMicrosecsP90"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.netTcpRttMicrosecsP90);
            if (message.netTcpRttMicrosecsP95 != null && message.hasOwnProperty("netTcpRttMicrosecsP95"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.netTcpRttMicrosecsP95);
            if (message.netTcpRttMicrosecsP99 != null && message.hasOwnProperty("netTcpRttMicrosecsP99"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.netTcpRttMicrosecsP99);
            if (message.diskLimitBytes != null && message.hasOwnProperty("diskLimitBytes"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.diskLimitBytes);
            if (message.diskUsedBytes != null && message.hasOwnProperty("diskUsedBytes"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.diskUsedBytes);
            if (message.netTcpActiveConnections != null && message.hasOwnProperty("netTcpActiveConnections"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.netTcpActiveConnections);
            if (message.netTcpTimeWaitConnections != null && message.hasOwnProperty("netTcpTimeWaitConnections"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.netTcpTimeWaitConnections);
            if (message.processes != null && message.hasOwnProperty("processes"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.processes);
            if (message.threads != null && message.hasOwnProperty("threads"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.threads);
            if (message.memLowPressureCounter != null && message.hasOwnProperty("memLowPressureCounter"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint32(message.memLowPressureCounter);
            if (message.memMediumPressureCounter != null && message.hasOwnProperty("memMediumPressureCounter"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.memMediumPressureCounter);
            if (message.memCriticalPressureCounter != null && message.hasOwnProperty("memCriticalPressureCounter"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.memCriticalPressureCounter);
            if (message.netTrafficControlStatistics != null && message.netTrafficControlStatistics.length)
                for (let i = 0; i < message.netTrafficControlStatistics.length; ++i)
                    $root.mesos.TrafficControlStatistics.encode(message.netTrafficControlStatistics[i], writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.memTotalBytes != null && message.hasOwnProperty("memTotalBytes"))
                writer.uint32(/* id 36, wireType 0 =*/288).uint32(message.memTotalBytes);
            if (message.memTotalMemswBytes != null && message.hasOwnProperty("memTotalMemswBytes"))
                writer.uint32(/* id 37, wireType 0 =*/296).uint32(message.memTotalMemswBytes);
            if (message.memSoftLimitBytes != null && message.hasOwnProperty("memSoftLimitBytes"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.memSoftLimitBytes);
            if (message.memCacheBytes != null && message.hasOwnProperty("memCacheBytes"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.memCacheBytes);
            if (message.memSwapBytes != null && message.hasOwnProperty("memSwapBytes"))
                writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.memSwapBytes);
            if (message.memUnevictableBytes != null && message.hasOwnProperty("memUnevictableBytes"))
                writer.uint32(/* id 41, wireType 0 =*/328).uint32(message.memUnevictableBytes);
            if (message.netSnmpStatistics != null && message.hasOwnProperty("netSnmpStatistics"))
                $root.mesos.SNMPStatistics.encode(message.netSnmpStatistics, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceStatistics message, length delimited. Does not implicitly {@link mesos.ResourceStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {mesos.IResourceStatistics} message ResourceStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ResourceStatistics} ResourceStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ResourceStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.double();
                    break;
                case 30:
                    message.processes = reader.uint32();
                    break;
                case 31:
                    message.threads = reader.uint32();
                    break;
                case 2:
                    message.cpusUserTimeSecs = reader.double();
                    break;
                case 3:
                    message.cpusSystemTimeSecs = reader.double();
                    break;
                case 4:
                    message.cpusLimit = reader.double();
                    break;
                case 7:
                    message.cpusNrPeriods = reader.uint32();
                    break;
                case 8:
                    message.cpusNrThrottled = reader.uint32();
                    break;
                case 9:
                    message.cpusThrottledTimeSecs = reader.double();
                    break;
                case 36:
                    message.memTotalBytes = reader.uint32();
                    break;
                case 37:
                    message.memTotalMemswBytes = reader.uint32();
                    break;
                case 6:
                    message.memLimitBytes = reader.uint32();
                    break;
                case 38:
                    message.memSoftLimitBytes = reader.uint32();
                    break;
                case 10:
                    message.memFileBytes = reader.uint32();
                    break;
                case 11:
                    message.memAnonBytes = reader.uint32();
                    break;
                case 39:
                    message.memCacheBytes = reader.uint32();
                    break;
                case 5:
                    message.memRssBytes = reader.uint32();
                    break;
                case 12:
                    message.memMappedFileBytes = reader.uint32();
                    break;
                case 40:
                    message.memSwapBytes = reader.uint32();
                    break;
                case 41:
                    message.memUnevictableBytes = reader.uint32();
                    break;
                case 32:
                    message.memLowPressureCounter = reader.uint32();
                    break;
                case 33:
                    message.memMediumPressureCounter = reader.uint32();
                    break;
                case 34:
                    message.memCriticalPressureCounter = reader.uint32();
                    break;
                case 26:
                    message.diskLimitBytes = reader.uint32();
                    break;
                case 27:
                    message.diskUsedBytes = reader.uint32();
                    break;
                case 13:
                    message.perf = $root.mesos.PerfStatistics.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.netRxPackets = reader.uint32();
                    break;
                case 15:
                    message.netRxBytes = reader.uint32();
                    break;
                case 16:
                    message.netRxErrors = reader.uint32();
                    break;
                case 17:
                    message.netRxDropped = reader.uint32();
                    break;
                case 18:
                    message.netTxPackets = reader.uint32();
                    break;
                case 19:
                    message.netTxBytes = reader.uint32();
                    break;
                case 20:
                    message.netTxErrors = reader.uint32();
                    break;
                case 21:
                    message.netTxDropped = reader.uint32();
                    break;
                case 22:
                    message.netTcpRttMicrosecsP50 = reader.double();
                    break;
                case 23:
                    message.netTcpRttMicrosecsP90 = reader.double();
                    break;
                case 24:
                    message.netTcpRttMicrosecsP95 = reader.double();
                    break;
                case 25:
                    message.netTcpRttMicrosecsP99 = reader.double();
                    break;
                case 28:
                    message.netTcpActiveConnections = reader.double();
                    break;
                case 29:
                    message.netTcpTimeWaitConnections = reader.double();
                    break;
                case 35:
                    if (!(message.netTrafficControlStatistics && message.netTrafficControlStatistics.length))
                        message.netTrafficControlStatistics = [];
                    message.netTrafficControlStatistics.push($root.mesos.TrafficControlStatistics.decode(reader, reader.uint32()));
                    break;
                case 42:
                    message.netSnmpStatistics = $root.mesos.SNMPStatistics.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };

        /**
         * Decodes a ResourceStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ResourceStatistics} ResourceStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceStatistics message.
         * @function verify
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (message.processes != null && message.hasOwnProperty("processes"))
                if (!$util.isInteger(message.processes))
                    return "processes: integer expected";
            if (message.threads != null && message.hasOwnProperty("threads"))
                if (!$util.isInteger(message.threads))
                    return "threads: integer expected";
            if (message.cpusUserTimeSecs != null && message.hasOwnProperty("cpusUserTimeSecs"))
                if (typeof message.cpusUserTimeSecs !== "number")
                    return "cpusUserTimeSecs: number expected";
            if (message.cpusSystemTimeSecs != null && message.hasOwnProperty("cpusSystemTimeSecs"))
                if (typeof message.cpusSystemTimeSecs !== "number")
                    return "cpusSystemTimeSecs: number expected";
            if (message.cpusLimit != null && message.hasOwnProperty("cpusLimit"))
                if (typeof message.cpusLimit !== "number")
                    return "cpusLimit: number expected";
            if (message.cpusNrPeriods != null && message.hasOwnProperty("cpusNrPeriods"))
                if (!$util.isInteger(message.cpusNrPeriods))
                    return "cpusNrPeriods: integer expected";
            if (message.cpusNrThrottled != null && message.hasOwnProperty("cpusNrThrottled"))
                if (!$util.isInteger(message.cpusNrThrottled))
                    return "cpusNrThrottled: integer expected";
            if (message.cpusThrottledTimeSecs != null && message.hasOwnProperty("cpusThrottledTimeSecs"))
                if (typeof message.cpusThrottledTimeSecs !== "number")
                    return "cpusThrottledTimeSecs: number expected";
            if (message.memTotalBytes != null && message.hasOwnProperty("memTotalBytes"))
                if (!$util.isInteger(message.memTotalBytes))
                    return "memTotalBytes: integer expected";
            if (message.memTotalMemswBytes != null && message.hasOwnProperty("memTotalMemswBytes"))
                if (!$util.isInteger(message.memTotalMemswBytes))
                    return "memTotalMemswBytes: integer expected";
            if (message.memLimitBytes != null && message.hasOwnProperty("memLimitBytes"))
                if (!$util.isInteger(message.memLimitBytes))
                    return "memLimitBytes: integer expected";
            if (message.memSoftLimitBytes != null && message.hasOwnProperty("memSoftLimitBytes"))
                if (!$util.isInteger(message.memSoftLimitBytes))
                    return "memSoftLimitBytes: integer expected";
            if (message.memFileBytes != null && message.hasOwnProperty("memFileBytes"))
                if (!$util.isInteger(message.memFileBytes))
                    return "memFileBytes: integer expected";
            if (message.memAnonBytes != null && message.hasOwnProperty("memAnonBytes"))
                if (!$util.isInteger(message.memAnonBytes))
                    return "memAnonBytes: integer expected";
            if (message.memCacheBytes != null && message.hasOwnProperty("memCacheBytes"))
                if (!$util.isInteger(message.memCacheBytes))
                    return "memCacheBytes: integer expected";
            if (message.memRssBytes != null && message.hasOwnProperty("memRssBytes"))
                if (!$util.isInteger(message.memRssBytes))
                    return "memRssBytes: integer expected";
            if (message.memMappedFileBytes != null && message.hasOwnProperty("memMappedFileBytes"))
                if (!$util.isInteger(message.memMappedFileBytes))
                    return "memMappedFileBytes: integer expected";
            if (message.memSwapBytes != null && message.hasOwnProperty("memSwapBytes"))
                if (!$util.isInteger(message.memSwapBytes))
                    return "memSwapBytes: integer expected";
            if (message.memUnevictableBytes != null && message.hasOwnProperty("memUnevictableBytes"))
                if (!$util.isInteger(message.memUnevictableBytes))
                    return "memUnevictableBytes: integer expected";
            if (message.memLowPressureCounter != null && message.hasOwnProperty("memLowPressureCounter"))
                if (!$util.isInteger(message.memLowPressureCounter))
                    return "memLowPressureCounter: integer expected";
            if (message.memMediumPressureCounter != null && message.hasOwnProperty("memMediumPressureCounter"))
                if (!$util.isInteger(message.memMediumPressureCounter))
                    return "memMediumPressureCounter: integer expected";
            if (message.memCriticalPressureCounter != null && message.hasOwnProperty("memCriticalPressureCounter"))
                if (!$util.isInteger(message.memCriticalPressureCounter))
                    return "memCriticalPressureCounter: integer expected";
            if (message.diskLimitBytes != null && message.hasOwnProperty("diskLimitBytes"))
                if (!$util.isInteger(message.diskLimitBytes))
                    return "diskLimitBytes: integer expected";
            if (message.diskUsedBytes != null && message.hasOwnProperty("diskUsedBytes"))
                if (!$util.isInteger(message.diskUsedBytes))
                    return "diskUsedBytes: integer expected";
            if (message.perf != null && message.hasOwnProperty("perf")) {
                let error = $root.mesos.PerfStatistics.verify(message.perf);
                if (error)
                    return "perf." + error;
            }
            if (message.netRxPackets != null && message.hasOwnProperty("netRxPackets"))
                if (!$util.isInteger(message.netRxPackets))
                    return "netRxPackets: integer expected";
            if (message.netRxBytes != null && message.hasOwnProperty("netRxBytes"))
                if (!$util.isInteger(message.netRxBytes))
                    return "netRxBytes: integer expected";
            if (message.netRxErrors != null && message.hasOwnProperty("netRxErrors"))
                if (!$util.isInteger(message.netRxErrors))
                    return "netRxErrors: integer expected";
            if (message.netRxDropped != null && message.hasOwnProperty("netRxDropped"))
                if (!$util.isInteger(message.netRxDropped))
                    return "netRxDropped: integer expected";
            if (message.netTxPackets != null && message.hasOwnProperty("netTxPackets"))
                if (!$util.isInteger(message.netTxPackets))
                    return "netTxPackets: integer expected";
            if (message.netTxBytes != null && message.hasOwnProperty("netTxBytes"))
                if (!$util.isInteger(message.netTxBytes))
                    return "netTxBytes: integer expected";
            if (message.netTxErrors != null && message.hasOwnProperty("netTxErrors"))
                if (!$util.isInteger(message.netTxErrors))
                    return "netTxErrors: integer expected";
            if (message.netTxDropped != null && message.hasOwnProperty("netTxDropped"))
                if (!$util.isInteger(message.netTxDropped))
                    return "netTxDropped: integer expected";
            if (message.netTcpRttMicrosecsP50 != null && message.hasOwnProperty("netTcpRttMicrosecsP50"))
                if (typeof message.netTcpRttMicrosecsP50 !== "number")
                    return "netTcpRttMicrosecsP50: number expected";
            if (message.netTcpRttMicrosecsP90 != null && message.hasOwnProperty("netTcpRttMicrosecsP90"))
                if (typeof message.netTcpRttMicrosecsP90 !== "number")
                    return "netTcpRttMicrosecsP90: number expected";
            if (message.netTcpRttMicrosecsP95 != null && message.hasOwnProperty("netTcpRttMicrosecsP95"))
                if (typeof message.netTcpRttMicrosecsP95 !== "number")
                    return "netTcpRttMicrosecsP95: number expected";
            if (message.netTcpRttMicrosecsP99 != null && message.hasOwnProperty("netTcpRttMicrosecsP99"))
                if (typeof message.netTcpRttMicrosecsP99 !== "number")
                    return "netTcpRttMicrosecsP99: number expected";
            if (message.netTcpActiveConnections != null && message.hasOwnProperty("netTcpActiveConnections"))
                if (typeof message.netTcpActiveConnections !== "number")
                    return "netTcpActiveConnections: number expected";
            if (message.netTcpTimeWaitConnections != null && message.hasOwnProperty("netTcpTimeWaitConnections"))
                if (typeof message.netTcpTimeWaitConnections !== "number")
                    return "netTcpTimeWaitConnections: number expected";
            if (message.netTrafficControlStatistics != null && message.hasOwnProperty("netTrafficControlStatistics")) {
                if (!Array.isArray(message.netTrafficControlStatistics))
                    return "netTrafficControlStatistics: array expected";
                for (let i = 0; i < message.netTrafficControlStatistics.length; ++i) {
                    error = $root.mesos.TrafficControlStatistics.verify(message.netTrafficControlStatistics[i]);
                    if (error)
                        return "netTrafficControlStatistics." + error;
                }
            }
            if (message.netSnmpStatistics != null && message.hasOwnProperty("netSnmpStatistics")) {
                error = $root.mesos.SNMPStatistics.verify(message.netSnmpStatistics);
                if (error)
                    return "netSnmpStatistics." + error;
            }
            return null;
        };

        /**
         * Creates a ResourceStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ResourceStatistics} ResourceStatistics
         */
        ResourceStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ResourceStatistics)
                return object;
            let message = new $root.mesos.ResourceStatistics();
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.processes != null)
                message.processes = object.processes >>> 0;
            if (object.threads != null)
                message.threads = object.threads >>> 0;
            if (object.cpusUserTimeSecs != null)
                message.cpusUserTimeSecs = Number(object.cpusUserTimeSecs);
            if (object.cpusSystemTimeSecs != null)
                message.cpusSystemTimeSecs = Number(object.cpusSystemTimeSecs);
            if (object.cpusLimit != null)
                message.cpusLimit = Number(object.cpusLimit);
            if (object.cpusNrPeriods != null)
                message.cpusNrPeriods = object.cpusNrPeriods >>> 0;
            if (object.cpusNrThrottled != null)
                message.cpusNrThrottled = object.cpusNrThrottled >>> 0;
            if (object.cpusThrottledTimeSecs != null)
                message.cpusThrottledTimeSecs = Number(object.cpusThrottledTimeSecs);
            if (object.memTotalBytes != null)
                message.memTotalBytes = object.memTotalBytes >>> 0;
            if (object.memTotalMemswBytes != null)
                message.memTotalMemswBytes = object.memTotalMemswBytes >>> 0;
            if (object.memLimitBytes != null)
                message.memLimitBytes = object.memLimitBytes >>> 0;
            if (object.memSoftLimitBytes != null)
                message.memSoftLimitBytes = object.memSoftLimitBytes >>> 0;
            if (object.memFileBytes != null)
                message.memFileBytes = object.memFileBytes >>> 0;
            if (object.memAnonBytes != null)
                message.memAnonBytes = object.memAnonBytes >>> 0;
            if (object.memCacheBytes != null)
                message.memCacheBytes = object.memCacheBytes >>> 0;
            if (object.memRssBytes != null)
                message.memRssBytes = object.memRssBytes >>> 0;
            if (object.memMappedFileBytes != null)
                message.memMappedFileBytes = object.memMappedFileBytes >>> 0;
            if (object.memSwapBytes != null)
                message.memSwapBytes = object.memSwapBytes >>> 0;
            if (object.memUnevictableBytes != null)
                message.memUnevictableBytes = object.memUnevictableBytes >>> 0;
            if (object.memLowPressureCounter != null)
                message.memLowPressureCounter = object.memLowPressureCounter >>> 0;
            if (object.memMediumPressureCounter != null)
                message.memMediumPressureCounter = object.memMediumPressureCounter >>> 0;
            if (object.memCriticalPressureCounter != null)
                message.memCriticalPressureCounter = object.memCriticalPressureCounter >>> 0;
            if (object.diskLimitBytes != null)
                message.diskLimitBytes = object.diskLimitBytes >>> 0;
            if (object.diskUsedBytes != null)
                message.diskUsedBytes = object.diskUsedBytes >>> 0;
            if (object.perf != null) {
                if (typeof object.perf !== "object")
                    throw TypeError(".mesos.ResourceStatistics.perf: object expected");
                message.perf = $root.mesos.PerfStatistics.fromObject(object.perf);
            }
            if (object.netRxPackets != null)
                message.netRxPackets = object.netRxPackets >>> 0;
            if (object.netRxBytes != null)
                message.netRxBytes = object.netRxBytes >>> 0;
            if (object.netRxErrors != null)
                message.netRxErrors = object.netRxErrors >>> 0;
            if (object.netRxDropped != null)
                message.netRxDropped = object.netRxDropped >>> 0;
            if (object.netTxPackets != null)
                message.netTxPackets = object.netTxPackets >>> 0;
            if (object.netTxBytes != null)
                message.netTxBytes = object.netTxBytes >>> 0;
            if (object.netTxErrors != null)
                message.netTxErrors = object.netTxErrors >>> 0;
            if (object.netTxDropped != null)
                message.netTxDropped = object.netTxDropped >>> 0;
            if (object.netTcpRttMicrosecsP50 != null)
                message.netTcpRttMicrosecsP50 = Number(object.netTcpRttMicrosecsP50);
            if (object.netTcpRttMicrosecsP90 != null)
                message.netTcpRttMicrosecsP90 = Number(object.netTcpRttMicrosecsP90);
            if (object.netTcpRttMicrosecsP95 != null)
                message.netTcpRttMicrosecsP95 = Number(object.netTcpRttMicrosecsP95);
            if (object.netTcpRttMicrosecsP99 != null)
                message.netTcpRttMicrosecsP99 = Number(object.netTcpRttMicrosecsP99);
            if (object.netTcpActiveConnections != null)
                message.netTcpActiveConnections = Number(object.netTcpActiveConnections);
            if (object.netTcpTimeWaitConnections != null)
                message.netTcpTimeWaitConnections = Number(object.netTcpTimeWaitConnections);
            if (object.netTrafficControlStatistics) {
                if (!Array.isArray(object.netTrafficControlStatistics))
                    throw TypeError(".mesos.ResourceStatistics.netTrafficControlStatistics: array expected");
                message.netTrafficControlStatistics = [];
                for (let i = 0; i < object.netTrafficControlStatistics.length; ++i) {
                    if (typeof object.netTrafficControlStatistics[i] !== "object")
                        throw TypeError(".mesos.ResourceStatistics.netTrafficControlStatistics: object expected");
                    message.netTrafficControlStatistics[i] = $root.mesos.TrafficControlStatistics.fromObject(object.netTrafficControlStatistics[i]);
                }
            }
            if (object.netSnmpStatistics != null) {
                if (typeof object.netSnmpStatistics !== "object")
                    throw TypeError(".mesos.ResourceStatistics.netSnmpStatistics: object expected");
                message.netSnmpStatistics = $root.mesos.SNMPStatistics.fromObject(object.netSnmpStatistics);
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ResourceStatistics
         * @static
         * @param {mesos.ResourceStatistics} message ResourceStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.netTrafficControlStatistics = [];
            if (options.defaults) {
                object.timestamp = 0;
                object.cpusUserTimeSecs = 0;
                object.cpusSystemTimeSecs = 0;
                object.cpusLimit = 0;
                object.memRssBytes = 0;
                object.memLimitBytes = 0;
                object.cpusNrPeriods = 0;
                object.cpusNrThrottled = 0;
                object.cpusThrottledTimeSecs = 0;
                object.memFileBytes = 0;
                object.memAnonBytes = 0;
                object.memMappedFileBytes = 0;
                object.perf = null;
                object.netRxPackets = 0;
                object.netRxBytes = 0;
                object.netRxErrors = 0;
                object.netRxDropped = 0;
                object.netTxPackets = 0;
                object.netTxBytes = 0;
                object.netTxErrors = 0;
                object.netTxDropped = 0;
                object.netTcpRttMicrosecsP50 = 0;
                object.netTcpRttMicrosecsP90 = 0;
                object.netTcpRttMicrosecsP95 = 0;
                object.netTcpRttMicrosecsP99 = 0;
                object.diskLimitBytes = 0;
                object.diskUsedBytes = 0;
                object.netTcpActiveConnections = 0;
                object.netTcpTimeWaitConnections = 0;
                object.processes = 0;
                object.threads = 0;
                object.memLowPressureCounter = 0;
                object.memMediumPressureCounter = 0;
                object.memCriticalPressureCounter = 0;
                object.memTotalBytes = 0;
                object.memTotalMemswBytes = 0;
                object.memSoftLimitBytes = 0;
                object.memCacheBytes = 0;
                object.memSwapBytes = 0;
                object.memUnevictableBytes = 0;
                object.netSnmpStatistics = null;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.cpusUserTimeSecs != null && message.hasOwnProperty("cpusUserTimeSecs"))
                object.cpusUserTimeSecs = options.json && !isFinite(message.cpusUserTimeSecs) ? String(message.cpusUserTimeSecs) : message.cpusUserTimeSecs;
            if (message.cpusSystemTimeSecs != null && message.hasOwnProperty("cpusSystemTimeSecs"))
                object.cpusSystemTimeSecs = options.json && !isFinite(message.cpusSystemTimeSecs) ? String(message.cpusSystemTimeSecs) : message.cpusSystemTimeSecs;
            if (message.cpusLimit != null && message.hasOwnProperty("cpusLimit"))
                object.cpusLimit = options.json && !isFinite(message.cpusLimit) ? String(message.cpusLimit) : message.cpusLimit;
            if (message.memRssBytes != null && message.hasOwnProperty("memRssBytes"))
                object.memRssBytes = message.memRssBytes;
            if (message.memLimitBytes != null && message.hasOwnProperty("memLimitBytes"))
                object.memLimitBytes = message.memLimitBytes;
            if (message.cpusNrPeriods != null && message.hasOwnProperty("cpusNrPeriods"))
                object.cpusNrPeriods = message.cpusNrPeriods;
            if (message.cpusNrThrottled != null && message.hasOwnProperty("cpusNrThrottled"))
                object.cpusNrThrottled = message.cpusNrThrottled;
            if (message.cpusThrottledTimeSecs != null && message.hasOwnProperty("cpusThrottledTimeSecs"))
                object.cpusThrottledTimeSecs = options.json && !isFinite(message.cpusThrottledTimeSecs) ? String(message.cpusThrottledTimeSecs) : message.cpusThrottledTimeSecs;
            if (message.memFileBytes != null && message.hasOwnProperty("memFileBytes"))
                object.memFileBytes = message.memFileBytes;
            if (message.memAnonBytes != null && message.hasOwnProperty("memAnonBytes"))
                object.memAnonBytes = message.memAnonBytes;
            if (message.memMappedFileBytes != null && message.hasOwnProperty("memMappedFileBytes"))
                object.memMappedFileBytes = message.memMappedFileBytes;
            if (message.perf != null && message.hasOwnProperty("perf"))
                object.perf = $root.mesos.PerfStatistics.toObject(message.perf, options);
            if (message.netRxPackets != null && message.hasOwnProperty("netRxPackets"))
                object.netRxPackets = message.netRxPackets;
            if (message.netRxBytes != null && message.hasOwnProperty("netRxBytes"))
                object.netRxBytes = message.netRxBytes;
            if (message.netRxErrors != null && message.hasOwnProperty("netRxErrors"))
                object.netRxErrors = message.netRxErrors;
            if (message.netRxDropped != null && message.hasOwnProperty("netRxDropped"))
                object.netRxDropped = message.netRxDropped;
            if (message.netTxPackets != null && message.hasOwnProperty("netTxPackets"))
                object.netTxPackets = message.netTxPackets;
            if (message.netTxBytes != null && message.hasOwnProperty("netTxBytes"))
                object.netTxBytes = message.netTxBytes;
            if (message.netTxErrors != null && message.hasOwnProperty("netTxErrors"))
                object.netTxErrors = message.netTxErrors;
            if (message.netTxDropped != null && message.hasOwnProperty("netTxDropped"))
                object.netTxDropped = message.netTxDropped;
            if (message.netTcpRttMicrosecsP50 != null && message.hasOwnProperty("netTcpRttMicrosecsP50"))
                object.netTcpRttMicrosecsP50 = options.json && !isFinite(message.netTcpRttMicrosecsP50) ? String(message.netTcpRttMicrosecsP50) : message.netTcpRttMicrosecsP50;
            if (message.netTcpRttMicrosecsP90 != null && message.hasOwnProperty("netTcpRttMicrosecsP90"))
                object.netTcpRttMicrosecsP90 = options.json && !isFinite(message.netTcpRttMicrosecsP90) ? String(message.netTcpRttMicrosecsP90) : message.netTcpRttMicrosecsP90;
            if (message.netTcpRttMicrosecsP95 != null && message.hasOwnProperty("netTcpRttMicrosecsP95"))
                object.netTcpRttMicrosecsP95 = options.json && !isFinite(message.netTcpRttMicrosecsP95) ? String(message.netTcpRttMicrosecsP95) : message.netTcpRttMicrosecsP95;
            if (message.netTcpRttMicrosecsP99 != null && message.hasOwnProperty("netTcpRttMicrosecsP99"))
                object.netTcpRttMicrosecsP99 = options.json && !isFinite(message.netTcpRttMicrosecsP99) ? String(message.netTcpRttMicrosecsP99) : message.netTcpRttMicrosecsP99;
            if (message.diskLimitBytes != null && message.hasOwnProperty("diskLimitBytes"))
                object.diskLimitBytes = message.diskLimitBytes;
            if (message.diskUsedBytes != null && message.hasOwnProperty("diskUsedBytes"))
                object.diskUsedBytes = message.diskUsedBytes;
            if (message.netTcpActiveConnections != null && message.hasOwnProperty("netTcpActiveConnections"))
                object.netTcpActiveConnections = options.json && !isFinite(message.netTcpActiveConnections) ? String(message.netTcpActiveConnections) : message.netTcpActiveConnections;
            if (message.netTcpTimeWaitConnections != null && message.hasOwnProperty("netTcpTimeWaitConnections"))
                object.netTcpTimeWaitConnections = options.json && !isFinite(message.netTcpTimeWaitConnections) ? String(message.netTcpTimeWaitConnections) : message.netTcpTimeWaitConnections;
            if (message.processes != null && message.hasOwnProperty("processes"))
                object.processes = message.processes;
            if (message.threads != null && message.hasOwnProperty("threads"))
                object.threads = message.threads;
            if (message.memLowPressureCounter != null && message.hasOwnProperty("memLowPressureCounter"))
                object.memLowPressureCounter = message.memLowPressureCounter;
            if (message.memMediumPressureCounter != null && message.hasOwnProperty("memMediumPressureCounter"))
                object.memMediumPressureCounter = message.memMediumPressureCounter;
            if (message.memCriticalPressureCounter != null && message.hasOwnProperty("memCriticalPressureCounter"))
                object.memCriticalPressureCounter = message.memCriticalPressureCounter;
            if (message.netTrafficControlStatistics && message.netTrafficControlStatistics.length) {
                object.netTrafficControlStatistics = [];
                for (let j = 0; j < message.netTrafficControlStatistics.length; ++j)
                    object.netTrafficControlStatistics[j] = $root.mesos.TrafficControlStatistics.toObject(message.netTrafficControlStatistics[j], options);
            }
            if (message.memTotalBytes != null && message.hasOwnProperty("memTotalBytes"))
                object.memTotalBytes = message.memTotalBytes;
            if (message.memTotalMemswBytes != null && message.hasOwnProperty("memTotalMemswBytes"))
                object.memTotalMemswBytes = message.memTotalMemswBytes;
            if (message.memSoftLimitBytes != null && message.hasOwnProperty("memSoftLimitBytes"))
                object.memSoftLimitBytes = message.memSoftLimitBytes;
            if (message.memCacheBytes != null && message.hasOwnProperty("memCacheBytes"))
                object.memCacheBytes = message.memCacheBytes;
            if (message.memSwapBytes != null && message.hasOwnProperty("memSwapBytes"))
                object.memSwapBytes = message.memSwapBytes;
            if (message.memUnevictableBytes != null && message.hasOwnProperty("memUnevictableBytes"))
                object.memUnevictableBytes = message.memUnevictableBytes;
            if (message.netSnmpStatistics != null && message.hasOwnProperty("netSnmpStatistics"))
                object.netSnmpStatistics = $root.mesos.SNMPStatistics.toObject(message.netSnmpStatistics, options);
            return object;
        };

        /**
         * Converts this ResourceStatistics to JSON.
         * @function toJSON
         * @memberof mesos.ResourceStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceStatistics;
    })();

    mesos.ResourceUsage = (function() {

        /**
         * Properties of a ResourceUsage.
         * @memberof mesos
         * @interface IResourceUsage
         * @property {Array.<mesos.ResourceUsage.IExecutor>} [executors] ResourceUsage executors
         * @property {Array.<mesos.IResource>} [total] ResourceUsage total
         */

        /**
         * Constructs a new ResourceUsage.
         * @memberof mesos
         * @classdesc Describes a snapshot of the resource usage for executors.
         * @constructor
         * @param {mesos.IResourceUsage=} [properties] Properties to set
         */
        function ResourceUsage(properties) {
            this.executors = [];
            this.total = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceUsage executors.
         * @member {Array.<mesos.ResourceUsage.IExecutor>}executors
         * @memberof mesos.ResourceUsage
         * @instance
         */
        ResourceUsage.prototype.executors = $util.emptyArray;

        /**
         * ResourceUsage total.
         * @member {Array.<mesos.IResource>}total
         * @memberof mesos.ResourceUsage
         * @instance
         */
        ResourceUsage.prototype.total = $util.emptyArray;

        /**
         * Creates a new ResourceUsage instance using the specified properties.
         * @function create
         * @memberof mesos.ResourceUsage
         * @static
         * @param {mesos.IResourceUsage=} [properties] Properties to set
         * @returns {mesos.ResourceUsage} ResourceUsage instance
         */
        ResourceUsage.create = function create(properties) {
            return new ResourceUsage(properties);
        };

        /**
         * Encodes the specified ResourceUsage message. Does not implicitly {@link mesos.ResourceUsage.verify|verify} messages.
         * @function encode
         * @memberof mesos.ResourceUsage
         * @static
         * @param {mesos.IResourceUsage} message ResourceUsage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceUsage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.executors != null && message.executors.length)
                for (let i = 0; i < message.executors.length; ++i)
                    $root.mesos.ResourceUsage.Executor.encode(message.executors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.total != null && message.total.length)
                for (let i = 0; i < message.total.length; ++i)
                    $root.mesos.Resource.encode(message.total[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceUsage message, length delimited. Does not implicitly {@link mesos.ResourceUsage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ResourceUsage
         * @static
         * @param {mesos.IResourceUsage} message ResourceUsage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceUsage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceUsage message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ResourceUsage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ResourceUsage} ResourceUsage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceUsage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ResourceUsage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.executors && message.executors.length))
                        message.executors = [];
                    message.executors.push($root.mesos.ResourceUsage.Executor.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.total && message.total.length))
                        message.total = [];
                    message.total.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceUsage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ResourceUsage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ResourceUsage} ResourceUsage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceUsage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceUsage message.
         * @function verify
         * @memberof mesos.ResourceUsage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceUsage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.executors != null && message.hasOwnProperty("executors")) {
                if (!Array.isArray(message.executors))
                    return "executors: array expected";
                for (let i = 0; i < message.executors.length; ++i) {
                    let error = $root.mesos.ResourceUsage.Executor.verify(message.executors[i]);
                    if (error)
                        return "executors." + error;
                }
            }
            if (message.total != null && message.hasOwnProperty("total")) {
                if (!Array.isArray(message.total))
                    return "total: array expected";
                for (let i = 0; i < message.total.length; ++i) {
                    error = $root.mesos.Resource.verify(message.total[i]);
                    if (error)
                        return "total." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResourceUsage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ResourceUsage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ResourceUsage} ResourceUsage
         */
        ResourceUsage.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ResourceUsage)
                return object;
            let message = new $root.mesos.ResourceUsage();
            if (object.executors) {
                if (!Array.isArray(object.executors))
                    throw TypeError(".mesos.ResourceUsage.executors: array expected");
                message.executors = [];
                for (let i = 0; i < object.executors.length; ++i) {
                    if (typeof object.executors[i] !== "object")
                        throw TypeError(".mesos.ResourceUsage.executors: object expected");
                    message.executors[i] = $root.mesos.ResourceUsage.Executor.fromObject(object.executors[i]);
                }
            }
            if (object.total) {
                if (!Array.isArray(object.total))
                    throw TypeError(".mesos.ResourceUsage.total: array expected");
                message.total = [];
                for (let i = 0; i < object.total.length; ++i) {
                    if (typeof object.total[i] !== "object")
                        throw TypeError(".mesos.ResourceUsage.total: object expected");
                    message.total[i] = $root.mesos.Resource.fromObject(object.total[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceUsage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ResourceUsage
         * @static
         * @param {mesos.ResourceUsage} message ResourceUsage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceUsage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.executors = [];
                object.total = [];
            }
            if (message.executors && message.executors.length) {
                object.executors = [];
                for (let j = 0; j < message.executors.length; ++j)
                    object.executors[j] = $root.mesos.ResourceUsage.Executor.toObject(message.executors[j], options);
            }
            if (message.total && message.total.length) {
                object.total = [];
                for (let j = 0; j < message.total.length; ++j)
                    object.total[j] = $root.mesos.Resource.toObject(message.total[j], options);
            }
            return object;
        };

        /**
         * Converts this ResourceUsage to JSON.
         * @function toJSON
         * @memberof mesos.ResourceUsage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceUsage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ResourceUsage.Executor = (function() {

            /**
             * Properties of an Executor.
             * @memberof mesos.ResourceUsage
             * @interface IExecutor
             * @property {mesos.IExecutorInfo} executorInfo Executor executorInfo
             * @property {Array.<mesos.IResource>} [allocated] Executor allocated
             * @property {mesos.IResourceStatistics} [statistics] Executor statistics
             * @property {mesos.IContainerID} containerId Executor containerId
             * @property {Array.<mesos.ResourceUsage.Executor.ITask>} [tasks] Executor tasks
             */

            /**
             * Constructs a new Executor.
             * @memberof mesos.ResourceUsage
             * @classdesc Represents an Executor.
             * @constructor
             * @param {mesos.ResourceUsage.IExecutor=} [properties] Properties to set
             */
            function Executor(properties) {
                this.allocated = [];
                this.tasks = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Executor executorInfo.
             * @member {mesos.IExecutorInfo}executorInfo
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             */
            Executor.prototype.executorInfo = null;

            /**
             * Executor allocated.
             * @member {Array.<mesos.IResource>}allocated
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             */
            Executor.prototype.allocated = $util.emptyArray;

            /**
             * Executor statistics.
             * @member {(mesos.IResourceStatistics|null|undefined)}statistics
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             */
            Executor.prototype.statistics = null;

            /**
             * Executor containerId.
             * @member {mesos.IContainerID}containerId
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             */
            Executor.prototype.containerId = null;

            /**
             * Executor tasks.
             * @member {Array.<mesos.ResourceUsage.Executor.ITask>}tasks
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             */
            Executor.prototype.tasks = $util.emptyArray;

            /**
             * Creates a new Executor instance using the specified properties.
             * @function create
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {mesos.ResourceUsage.IExecutor=} [properties] Properties to set
             * @returns {mesos.ResourceUsage.Executor} Executor instance
             */
            Executor.create = function create(properties) {
                return new Executor(properties);
            };

            /**
             * Encodes the specified Executor message. Does not implicitly {@link mesos.ResourceUsage.Executor.verify|verify} messages.
             * @function encode
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {mesos.ResourceUsage.IExecutor} message Executor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Executor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.mesos.ExecutorInfo.encode(message.executorInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.allocated != null && message.allocated.length)
                    for (let i = 0; i < message.allocated.length; ++i)
                        $root.mesos.Resource.encode(message.allocated[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.statistics != null && message.hasOwnProperty("statistics"))
                    $root.mesos.ResourceStatistics.encode(message.statistics, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                $root.mesos.ContainerID.encode(message.containerId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.mesos.ResourceUsage.Executor.Task.encode(message.tasks[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Executor message, length delimited. Does not implicitly {@link mesos.ResourceUsage.Executor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {mesos.ResourceUsage.IExecutor} message Executor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Executor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Executor message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.ResourceUsage.Executor} Executor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Executor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ResourceUsage.Executor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executorInfo = $root.mesos.ExecutorInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.allocated && message.allocated.length))
                            message.allocated = [];
                        message.allocated.push($root.mesos.Resource.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.statistics = $root.mesos.ResourceStatistics.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.containerId = $root.mesos.ContainerID.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.mesos.ResourceUsage.Executor.Task.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("executorInfo"))
                    throw $util.ProtocolError("missing required 'executorInfo'", { instance: message });
                if (!message.hasOwnProperty("containerId"))
                    throw $util.ProtocolError("missing required 'containerId'", { instance: message });
                return message;
            };

            /**
             * Decodes an Executor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.ResourceUsage.Executor} Executor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Executor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Executor message.
             * @function verify
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Executor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let error = $root.mesos.ExecutorInfo.verify(message.executorInfo);
                if (error)
                    return "executorInfo." + error;
                if (message.allocated != null && message.hasOwnProperty("allocated")) {
                    if (!Array.isArray(message.allocated))
                        return "allocated: array expected";
                    for (let i = 0; i < message.allocated.length; ++i) {
                        error = $root.mesos.Resource.verify(message.allocated[i]);
                        if (error)
                            return "allocated." + error;
                    }
                }
                if (message.statistics != null && message.hasOwnProperty("statistics")) {
                    error = $root.mesos.ResourceStatistics.verify(message.statistics);
                    if (error)
                        return "statistics." + error;
                }
                error = $root.mesos.ContainerID.verify(message.containerId);
                if (error)
                    return "containerId." + error;
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        error = $root.mesos.ResourceUsage.Executor.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Executor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.ResourceUsage.Executor} Executor
             */
            Executor.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.ResourceUsage.Executor)
                    return object;
                let message = new $root.mesos.ResourceUsage.Executor();
                if (object.executorInfo != null) {
                    if (typeof object.executorInfo !== "object")
                        throw TypeError(".mesos.ResourceUsage.Executor.executorInfo: object expected");
                    message.executorInfo = $root.mesos.ExecutorInfo.fromObject(object.executorInfo);
                }
                if (object.allocated) {
                    if (!Array.isArray(object.allocated))
                        throw TypeError(".mesos.ResourceUsage.Executor.allocated: array expected");
                    message.allocated = [];
                    for (let i = 0; i < object.allocated.length; ++i) {
                        if (typeof object.allocated[i] !== "object")
                            throw TypeError(".mesos.ResourceUsage.Executor.allocated: object expected");
                        message.allocated[i] = $root.mesos.Resource.fromObject(object.allocated[i]);
                    }
                }
                if (object.statistics != null) {
                    if (typeof object.statistics !== "object")
                        throw TypeError(".mesos.ResourceUsage.Executor.statistics: object expected");
                    message.statistics = $root.mesos.ResourceStatistics.fromObject(object.statistics);
                }
                if (object.containerId != null) {
                    if (typeof object.containerId !== "object")
                        throw TypeError(".mesos.ResourceUsage.Executor.containerId: object expected");
                    message.containerId = $root.mesos.ContainerID.fromObject(object.containerId);
                }
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".mesos.ResourceUsage.Executor.tasks: array expected");
                    message.tasks = [];
                    for (let i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".mesos.ResourceUsage.Executor.tasks: object expected");
                        message.tasks[i] = $root.mesos.ResourceUsage.Executor.Task.fromObject(object.tasks[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Executor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.ResourceUsage.Executor
             * @static
             * @param {mesos.ResourceUsage.Executor} message Executor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Executor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.allocated = [];
                    object.tasks = [];
                }
                if (options.defaults) {
                    object.executorInfo = null;
                    object.statistics = null;
                    object.containerId = null;
                }
                if (message.executorInfo != null && message.hasOwnProperty("executorInfo"))
                    object.executorInfo = $root.mesos.ExecutorInfo.toObject(message.executorInfo, options);
                if (message.allocated && message.allocated.length) {
                    object.allocated = [];
                    for (let j = 0; j < message.allocated.length; ++j)
                        object.allocated[j] = $root.mesos.Resource.toObject(message.allocated[j], options);
                }
                if (message.statistics != null && message.hasOwnProperty("statistics"))
                    object.statistics = $root.mesos.ResourceStatistics.toObject(message.statistics, options);
                if (message.containerId != null && message.hasOwnProperty("containerId"))
                    object.containerId = $root.mesos.ContainerID.toObject(message.containerId, options);
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (let j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.mesos.ResourceUsage.Executor.Task.toObject(message.tasks[j], options);
                }
                return object;
            };

            /**
             * Converts this Executor to JSON.
             * @function toJSON
             * @memberof mesos.ResourceUsage.Executor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Executor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Executor.Task = (function() {

                /**
                 * Properties of a Task.
                 * @memberof mesos.ResourceUsage.Executor
                 * @interface ITask
                 * @property {string} name Task name
                 * @property {mesos.ITaskID} id Task id
                 * @property {Array.<mesos.IResource>} [resources] Task resources
                 * @property {mesos.ILabels} [labels] Task labels
                 */

                /**
                 * Constructs a new Task.
                 * @memberof mesos.ResourceUsage.Executor
                 * @classdesc Represents a Task.
                 * @constructor
                 * @param {mesos.ResourceUsage.Executor.ITask=} [properties] Properties to set
                 */
                function Task(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Task name.
                 * @member {string}name
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @instance
                 */
                Task.prototype.name = "";

                /**
                 * Task id.
                 * @member {mesos.ITaskID}id
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @instance
                 */
                Task.prototype.id = null;

                /**
                 * Task resources.
                 * @member {Array.<mesos.IResource>}resources
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @instance
                 */
                Task.prototype.resources = $util.emptyArray;

                /**
                 * Task labels.
                 * @member {(mesos.ILabels|null|undefined)}labels
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @instance
                 */
                Task.prototype.labels = null;

                /**
                 * Creates a new Task instance using the specified properties.
                 * @function create
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {mesos.ResourceUsage.Executor.ITask=} [properties] Properties to set
                 * @returns {mesos.ResourceUsage.Executor.Task} Task instance
                 */
                Task.create = function create(properties) {
                    return new Task(properties);
                };

                /**
                 * Encodes the specified Task message. Does not implicitly {@link mesos.ResourceUsage.Executor.Task.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {mesos.ResourceUsage.Executor.ITask} message Task message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Task.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    $root.mesos.TaskID.encode(message.id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.resources != null && message.resources.length)
                        for (let i = 0; i < message.resources.length; ++i)
                            $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Task message, length delimited. Does not implicitly {@link mesos.ResourceUsage.Executor.Task.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {mesos.ResourceUsage.Executor.ITask} message Task message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Task.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Task message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.ResourceUsage.Executor.Task} Task
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Task.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ResourceUsage.Executor.Task();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.id = $root.mesos.TaskID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.resources && message.resources.length))
                                message.resources = [];
                            message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("name"))
                        throw $util.ProtocolError("missing required 'name'", { instance: message });
                    if (!message.hasOwnProperty("id"))
                        throw $util.ProtocolError("missing required 'id'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Task message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.ResourceUsage.Executor.Task} Task
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Task.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Task message.
                 * @function verify
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Task.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.name))
                        return "name: string expected";
                    let error = $root.mesos.TaskID.verify(message.id);
                    if (error)
                        return "id." + error;
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            error = $root.mesos.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        error = $root.mesos.Labels.verify(message.labels);
                        if (error)
                            return "labels." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Task message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.ResourceUsage.Executor.Task} Task
                 */
                Task.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.ResourceUsage.Executor.Task)
                        return object;
                    let message = new $root.mesos.ResourceUsage.Executor.Task();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".mesos.ResourceUsage.Executor.Task.id: object expected");
                        message.id = $root.mesos.TaskID.fromObject(object.id);
                    }
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".mesos.ResourceUsage.Executor.Task.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".mesos.ResourceUsage.Executor.Task.resources: object expected");
                            message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                        }
                    }
                    if (object.labels != null) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".mesos.ResourceUsage.Executor.Task.labels: object expected");
                        message.labels = $root.mesos.Labels.fromObject(object.labels);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Task message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @static
                 * @param {mesos.ResourceUsage.Executor.Task} message Task
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Task.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (options.defaults) {
                        object.name = "";
                        object.id = null;
                        object.labels = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.mesos.TaskID.toObject(message.id, options);
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
                    }
                    if (message.labels != null && message.hasOwnProperty("labels"))
                        object.labels = $root.mesos.Labels.toObject(message.labels, options);
                    return object;
                };

                /**
                 * Converts this Task to JSON.
                 * @function toJSON
                 * @memberof mesos.ResourceUsage.Executor.Task
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Task.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Task;
            })();

            return Executor;
        })();

        return ResourceUsage;
    })();

    mesos.PerfStatistics = (function() {

        /**
         * Properties of a PerfStatistics.
         * @memberof mesos
         * @interface IPerfStatistics
         * @property {number} timestamp PerfStatistics timestamp
         * @property {number} duration PerfStatistics duration
         * @property {number} [cycles] PerfStatistics cycles
         * @property {number} [stalledCyclesFrontend] PerfStatistics stalledCyclesFrontend
         * @property {number} [stalledCyclesBackend] PerfStatistics stalledCyclesBackend
         * @property {number} [instructions] PerfStatistics instructions
         * @property {number} [cacheReferences] PerfStatistics cacheReferences
         * @property {number} [cacheMisses] PerfStatistics cacheMisses
         * @property {number} [branches] PerfStatistics branches
         * @property {number} [branchMisses] PerfStatistics branchMisses
         * @property {number} [busCycles] PerfStatistics busCycles
         * @property {number} [refCycles] PerfStatistics refCycles
         * @property {number} [cpuClock] PerfStatistics cpuClock
         * @property {number} [taskClock] PerfStatistics taskClock
         * @property {number} [pageFaults] PerfStatistics pageFaults
         * @property {number} [minorFaults] PerfStatistics minorFaults
         * @property {number} [majorFaults] PerfStatistics majorFaults
         * @property {number} [contextSwitches] PerfStatistics contextSwitches
         * @property {number} [cpuMigrations] PerfStatistics cpuMigrations
         * @property {number} [alignmentFaults] PerfStatistics alignmentFaults
         * @property {number} [emulationFaults] PerfStatistics emulationFaults
         * @property {number} [l1DcacheLoads] PerfStatistics l1DcacheLoads
         * @property {number} [l1DcacheLoadMisses] PerfStatistics l1DcacheLoadMisses
         * @property {number} [l1DcacheStores] PerfStatistics l1DcacheStores
         * @property {number} [l1DcacheStoreMisses] PerfStatistics l1DcacheStoreMisses
         * @property {number} [l1DcachePrefetches] PerfStatistics l1DcachePrefetches
         * @property {number} [l1DcachePrefetchMisses] PerfStatistics l1DcachePrefetchMisses
         * @property {number} [l1IcacheLoads] PerfStatistics l1IcacheLoads
         * @property {number} [l1IcacheLoadMisses] PerfStatistics l1IcacheLoadMisses
         * @property {number} [l1IcachePrefetches] PerfStatistics l1IcachePrefetches
         * @property {number} [l1IcachePrefetchMisses] PerfStatistics l1IcachePrefetchMisses
         * @property {number} [llcLoads] PerfStatistics llcLoads
         * @property {number} [llcLoadMisses] PerfStatistics llcLoadMisses
         * @property {number} [llcStores] PerfStatistics llcStores
         * @property {number} [llcStoreMisses] PerfStatistics llcStoreMisses
         * @property {number} [llcPrefetches] PerfStatistics llcPrefetches
         * @property {number} [llcPrefetchMisses] PerfStatistics llcPrefetchMisses
         * @property {number} [dtlbLoads] PerfStatistics dtlbLoads
         * @property {number} [dtlbLoadMisses] PerfStatistics dtlbLoadMisses
         * @property {number} [dtlbStores] PerfStatistics dtlbStores
         * @property {number} [dtlbStoreMisses] PerfStatistics dtlbStoreMisses
         * @property {number} [dtlbPrefetches] PerfStatistics dtlbPrefetches
         * @property {number} [dtlbPrefetchMisses] PerfStatistics dtlbPrefetchMisses
         * @property {number} [itlbLoads] PerfStatistics itlbLoads
         * @property {number} [itlbLoadMisses] PerfStatistics itlbLoadMisses
         * @property {number} [branchLoads] PerfStatistics branchLoads
         * @property {number} [branchLoadMisses] PerfStatistics branchLoadMisses
         * @property {number} [nodeLoads] PerfStatistics nodeLoads
         * @property {number} [nodeLoadMisses] PerfStatistics nodeLoadMisses
         * @property {number} [nodeStores] PerfStatistics nodeStores
         * @property {number} [nodeStoreMisses] PerfStatistics nodeStoreMisses
         * @property {number} [nodePrefetches] PerfStatistics nodePrefetches
         * @property {number} [nodePrefetchMisses] PerfStatistics nodePrefetchMisses
         */

        /**
         * Constructs a new PerfStatistics.
         * @memberof mesos
         * @classdesc Describes a sample of events from "perf stat". Only available on
         * Linux.
         * 
         * NOTE: Each optional field matches the name of a perf event (see
         * "perf list") with the following changes:
         * 1. Names are downcased.
         * 2. Hyphens ('-') are replaced with underscores ('_').
         * 3. Events with alternate names use the name "perf stat" returns,
         * e.g., for the event "cycles OR cpu-cycles" perf always returns
         * cycles.
         * @constructor
         * @param {mesos.IPerfStatistics=} [properties] Properties to set
         */
        function PerfStatistics(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PerfStatistics timestamp.
         * @member {number}timestamp
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.timestamp = 0;

        /**
         * PerfStatistics duration.
         * @member {number}duration
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.duration = 0;

        /**
         * PerfStatistics cycles.
         * @member {number}cycles
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.cycles = 0;

        /**
         * PerfStatistics stalledCyclesFrontend.
         * @member {number}stalledCyclesFrontend
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.stalledCyclesFrontend = 0;

        /**
         * PerfStatistics stalledCyclesBackend.
         * @member {number}stalledCyclesBackend
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.stalledCyclesBackend = 0;

        /**
         * PerfStatistics instructions.
         * @member {number}instructions
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.instructions = 0;

        /**
         * PerfStatistics cacheReferences.
         * @member {number}cacheReferences
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.cacheReferences = 0;

        /**
         * PerfStatistics cacheMisses.
         * @member {number}cacheMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.cacheMisses = 0;

        /**
         * PerfStatistics branches.
         * @member {number}branches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.branches = 0;

        /**
         * PerfStatistics branchMisses.
         * @member {number}branchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.branchMisses = 0;

        /**
         * PerfStatistics busCycles.
         * @member {number}busCycles
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.busCycles = 0;

        /**
         * PerfStatistics refCycles.
         * @member {number}refCycles
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.refCycles = 0;

        /**
         * PerfStatistics cpuClock.
         * @member {number}cpuClock
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.cpuClock = 0;

        /**
         * PerfStatistics taskClock.
         * @member {number}taskClock
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.taskClock = 0;

        /**
         * PerfStatistics pageFaults.
         * @member {number}pageFaults
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.pageFaults = 0;

        /**
         * PerfStatistics minorFaults.
         * @member {number}minorFaults
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.minorFaults = 0;

        /**
         * PerfStatistics majorFaults.
         * @member {number}majorFaults
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.majorFaults = 0;

        /**
         * PerfStatistics contextSwitches.
         * @member {number}contextSwitches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.contextSwitches = 0;

        /**
         * PerfStatistics cpuMigrations.
         * @member {number}cpuMigrations
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.cpuMigrations = 0;

        /**
         * PerfStatistics alignmentFaults.
         * @member {number}alignmentFaults
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.alignmentFaults = 0;

        /**
         * PerfStatistics emulationFaults.
         * @member {number}emulationFaults
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.emulationFaults = 0;

        /**
         * PerfStatistics l1DcacheLoads.
         * @member {number}l1DcacheLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcacheLoads = 0;

        /**
         * PerfStatistics l1DcacheLoadMisses.
         * @member {number}l1DcacheLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcacheLoadMisses = 0;

        /**
         * PerfStatistics l1DcacheStores.
         * @member {number}l1DcacheStores
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcacheStores = 0;

        /**
         * PerfStatistics l1DcacheStoreMisses.
         * @member {number}l1DcacheStoreMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcacheStoreMisses = 0;

        /**
         * PerfStatistics l1DcachePrefetches.
         * @member {number}l1DcachePrefetches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcachePrefetches = 0;

        /**
         * PerfStatistics l1DcachePrefetchMisses.
         * @member {number}l1DcachePrefetchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1DcachePrefetchMisses = 0;

        /**
         * PerfStatistics l1IcacheLoads.
         * @member {number}l1IcacheLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1IcacheLoads = 0;

        /**
         * PerfStatistics l1IcacheLoadMisses.
         * @member {number}l1IcacheLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1IcacheLoadMisses = 0;

        /**
         * PerfStatistics l1IcachePrefetches.
         * @member {number}l1IcachePrefetches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1IcachePrefetches = 0;

        /**
         * PerfStatistics l1IcachePrefetchMisses.
         * @member {number}l1IcachePrefetchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.l1IcachePrefetchMisses = 0;

        /**
         * PerfStatistics llcLoads.
         * @member {number}llcLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcLoads = 0;

        /**
         * PerfStatistics llcLoadMisses.
         * @member {number}llcLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcLoadMisses = 0;

        /**
         * PerfStatistics llcStores.
         * @member {number}llcStores
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcStores = 0;

        /**
         * PerfStatistics llcStoreMisses.
         * @member {number}llcStoreMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcStoreMisses = 0;

        /**
         * PerfStatistics llcPrefetches.
         * @member {number}llcPrefetches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcPrefetches = 0;

        /**
         * PerfStatistics llcPrefetchMisses.
         * @member {number}llcPrefetchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.llcPrefetchMisses = 0;

        /**
         * PerfStatistics dtlbLoads.
         * @member {number}dtlbLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbLoads = 0;

        /**
         * PerfStatistics dtlbLoadMisses.
         * @member {number}dtlbLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbLoadMisses = 0;

        /**
         * PerfStatistics dtlbStores.
         * @member {number}dtlbStores
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbStores = 0;

        /**
         * PerfStatistics dtlbStoreMisses.
         * @member {number}dtlbStoreMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbStoreMisses = 0;

        /**
         * PerfStatistics dtlbPrefetches.
         * @member {number}dtlbPrefetches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbPrefetches = 0;

        /**
         * PerfStatistics dtlbPrefetchMisses.
         * @member {number}dtlbPrefetchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.dtlbPrefetchMisses = 0;

        /**
         * PerfStatistics itlbLoads.
         * @member {number}itlbLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.itlbLoads = 0;

        /**
         * PerfStatistics itlbLoadMisses.
         * @member {number}itlbLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.itlbLoadMisses = 0;

        /**
         * PerfStatistics branchLoads.
         * @member {number}branchLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.branchLoads = 0;

        /**
         * PerfStatistics branchLoadMisses.
         * @member {number}branchLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.branchLoadMisses = 0;

        /**
         * PerfStatistics nodeLoads.
         * @member {number}nodeLoads
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodeLoads = 0;

        /**
         * PerfStatistics nodeLoadMisses.
         * @member {number}nodeLoadMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodeLoadMisses = 0;

        /**
         * PerfStatistics nodeStores.
         * @member {number}nodeStores
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodeStores = 0;

        /**
         * PerfStatistics nodeStoreMisses.
         * @member {number}nodeStoreMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodeStoreMisses = 0;

        /**
         * PerfStatistics nodePrefetches.
         * @member {number}nodePrefetches
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodePrefetches = 0;

        /**
         * PerfStatistics nodePrefetchMisses.
         * @member {number}nodePrefetchMisses
         * @memberof mesos.PerfStatistics
         * @instance
         */
        PerfStatistics.prototype.nodePrefetchMisses = 0;

        /**
         * Creates a new PerfStatistics instance using the specified properties.
         * @function create
         * @memberof mesos.PerfStatistics
         * @static
         * @param {mesos.IPerfStatistics=} [properties] Properties to set
         * @returns {mesos.PerfStatistics} PerfStatistics instance
         */
        PerfStatistics.create = function create(properties) {
            return new PerfStatistics(properties);
        };

        /**
         * Encodes the specified PerfStatistics message. Does not implicitly {@link mesos.PerfStatistics.verify|verify} messages.
         * @function encode
         * @memberof mesos.PerfStatistics
         * @static
         * @param {mesos.IPerfStatistics} message PerfStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PerfStatistics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.timestamp);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.duration);
            if (message.cycles != null && message.hasOwnProperty("cycles"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.cycles);
            if (message.stalledCyclesFrontend != null && message.hasOwnProperty("stalledCyclesFrontend"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stalledCyclesFrontend);
            if (message.stalledCyclesBackend != null && message.hasOwnProperty("stalledCyclesBackend"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.stalledCyclesBackend);
            if (message.instructions != null && message.hasOwnProperty("instructions"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.instructions);
            if (message.cacheReferences != null && message.hasOwnProperty("cacheReferences"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.cacheReferences);
            if (message.cacheMisses != null && message.hasOwnProperty("cacheMisses"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.cacheMisses);
            if (message.branches != null && message.hasOwnProperty("branches"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.branches);
            if (message.branchMisses != null && message.hasOwnProperty("branchMisses"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.branchMisses);
            if (message.busCycles != null && message.hasOwnProperty("busCycles"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.busCycles);
            if (message.refCycles != null && message.hasOwnProperty("refCycles"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.refCycles);
            if (message.cpuClock != null && message.hasOwnProperty("cpuClock"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.cpuClock);
            if (message.taskClock != null && message.hasOwnProperty("taskClock"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.taskClock);
            if (message.pageFaults != null && message.hasOwnProperty("pageFaults"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.pageFaults);
            if (message.minorFaults != null && message.hasOwnProperty("minorFaults"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.minorFaults);
            if (message.majorFaults != null && message.hasOwnProperty("majorFaults"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.majorFaults);
            if (message.contextSwitches != null && message.hasOwnProperty("contextSwitches"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.contextSwitches);
            if (message.cpuMigrations != null && message.hasOwnProperty("cpuMigrations"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.cpuMigrations);
            if (message.alignmentFaults != null && message.hasOwnProperty("alignmentFaults"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.alignmentFaults);
            if (message.emulationFaults != null && message.hasOwnProperty("emulationFaults"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.emulationFaults);
            if (message.l1DcacheLoads != null && message.hasOwnProperty("l1DcacheLoads"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.l1DcacheLoads);
            if (message.l1DcacheLoadMisses != null && message.hasOwnProperty("l1DcacheLoadMisses"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.l1DcacheLoadMisses);
            if (message.l1DcacheStores != null && message.hasOwnProperty("l1DcacheStores"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.l1DcacheStores);
            if (message.l1DcacheStoreMisses != null && message.hasOwnProperty("l1DcacheStoreMisses"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.l1DcacheStoreMisses);
            if (message.l1DcachePrefetches != null && message.hasOwnProperty("l1DcachePrefetches"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.l1DcachePrefetches);
            if (message.l1DcachePrefetchMisses != null && message.hasOwnProperty("l1DcachePrefetchMisses"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.l1DcachePrefetchMisses);
            if (message.l1IcacheLoads != null && message.hasOwnProperty("l1IcacheLoads"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.l1IcacheLoads);
            if (message.l1IcacheLoadMisses != null && message.hasOwnProperty("l1IcacheLoadMisses"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.l1IcacheLoadMisses);
            if (message.l1IcachePrefetches != null && message.hasOwnProperty("l1IcachePrefetches"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.l1IcachePrefetches);
            if (message.l1IcachePrefetchMisses != null && message.hasOwnProperty("l1IcachePrefetchMisses"))
                writer.uint32(/* id 31, wireType 0 =*/248).uint32(message.l1IcachePrefetchMisses);
            if (message.llcLoads != null && message.hasOwnProperty("llcLoads"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint32(message.llcLoads);
            if (message.llcLoadMisses != null && message.hasOwnProperty("llcLoadMisses"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.llcLoadMisses);
            if (message.llcStores != null && message.hasOwnProperty("llcStores"))
                writer.uint32(/* id 34, wireType 0 =*/272).uint32(message.llcStores);
            if (message.llcStoreMisses != null && message.hasOwnProperty("llcStoreMisses"))
                writer.uint32(/* id 35, wireType 0 =*/280).uint32(message.llcStoreMisses);
            if (message.llcPrefetches != null && message.hasOwnProperty("llcPrefetches"))
                writer.uint32(/* id 36, wireType 0 =*/288).uint32(message.llcPrefetches);
            if (message.llcPrefetchMisses != null && message.hasOwnProperty("llcPrefetchMisses"))
                writer.uint32(/* id 37, wireType 0 =*/296).uint32(message.llcPrefetchMisses);
            if (message.dtlbLoads != null && message.hasOwnProperty("dtlbLoads"))
                writer.uint32(/* id 38, wireType 0 =*/304).uint32(message.dtlbLoads);
            if (message.dtlbLoadMisses != null && message.hasOwnProperty("dtlbLoadMisses"))
                writer.uint32(/* id 39, wireType 0 =*/312).uint32(message.dtlbLoadMisses);
            if (message.dtlbStores != null && message.hasOwnProperty("dtlbStores"))
                writer.uint32(/* id 40, wireType 0 =*/320).uint32(message.dtlbStores);
            if (message.dtlbStoreMisses != null && message.hasOwnProperty("dtlbStoreMisses"))
                writer.uint32(/* id 41, wireType 0 =*/328).uint32(message.dtlbStoreMisses);
            if (message.dtlbPrefetches != null && message.hasOwnProperty("dtlbPrefetches"))
                writer.uint32(/* id 42, wireType 0 =*/336).uint32(message.dtlbPrefetches);
            if (message.dtlbPrefetchMisses != null && message.hasOwnProperty("dtlbPrefetchMisses"))
                writer.uint32(/* id 43, wireType 0 =*/344).uint32(message.dtlbPrefetchMisses);
            if (message.itlbLoads != null && message.hasOwnProperty("itlbLoads"))
                writer.uint32(/* id 44, wireType 0 =*/352).uint32(message.itlbLoads);
            if (message.itlbLoadMisses != null && message.hasOwnProperty("itlbLoadMisses"))
                writer.uint32(/* id 45, wireType 0 =*/360).uint32(message.itlbLoadMisses);
            if (message.branchLoads != null && message.hasOwnProperty("branchLoads"))
                writer.uint32(/* id 46, wireType 0 =*/368).uint32(message.branchLoads);
            if (message.branchLoadMisses != null && message.hasOwnProperty("branchLoadMisses"))
                writer.uint32(/* id 47, wireType 0 =*/376).uint32(message.branchLoadMisses);
            if (message.nodeLoads != null && message.hasOwnProperty("nodeLoads"))
                writer.uint32(/* id 48, wireType 0 =*/384).uint32(message.nodeLoads);
            if (message.nodeLoadMisses != null && message.hasOwnProperty("nodeLoadMisses"))
                writer.uint32(/* id 49, wireType 0 =*/392).uint32(message.nodeLoadMisses);
            if (message.nodeStores != null && message.hasOwnProperty("nodeStores"))
                writer.uint32(/* id 50, wireType 0 =*/400).uint32(message.nodeStores);
            if (message.nodeStoreMisses != null && message.hasOwnProperty("nodeStoreMisses"))
                writer.uint32(/* id 51, wireType 0 =*/408).uint32(message.nodeStoreMisses);
            if (message.nodePrefetches != null && message.hasOwnProperty("nodePrefetches"))
                writer.uint32(/* id 52, wireType 0 =*/416).uint32(message.nodePrefetches);
            if (message.nodePrefetchMisses != null && message.hasOwnProperty("nodePrefetchMisses"))
                writer.uint32(/* id 53, wireType 0 =*/424).uint32(message.nodePrefetchMisses);
            return writer;
        };

        /**
         * Encodes the specified PerfStatistics message, length delimited. Does not implicitly {@link mesos.PerfStatistics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.PerfStatistics
         * @static
         * @param {mesos.IPerfStatistics} message PerfStatistics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PerfStatistics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PerfStatistics message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.PerfStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.PerfStatistics} PerfStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PerfStatistics.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.PerfStatistics();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.double();
                    break;
                case 2:
                    message.duration = reader.double();
                    break;
                case 3:
                    message.cycles = reader.uint32();
                    break;
                case 4:
                    message.stalledCyclesFrontend = reader.uint32();
                    break;
                case 5:
                    message.stalledCyclesBackend = reader.uint32();
                    break;
                case 6:
                    message.instructions = reader.uint32();
                    break;
                case 7:
                    message.cacheReferences = reader.uint32();
                    break;
                case 8:
                    message.cacheMisses = reader.uint32();
                    break;
                case 9:
                    message.branches = reader.uint32();
                    break;
                case 10:
                    message.branchMisses = reader.uint32();
                    break;
                case 11:
                    message.busCycles = reader.uint32();
                    break;
                case 12:
                    message.refCycles = reader.uint32();
                    break;
                case 13:
                    message.cpuClock = reader.double();
                    break;
                case 14:
                    message.taskClock = reader.double();
                    break;
                case 15:
                    message.pageFaults = reader.uint32();
                    break;
                case 16:
                    message.minorFaults = reader.uint32();
                    break;
                case 17:
                    message.majorFaults = reader.uint32();
                    break;
                case 18:
                    message.contextSwitches = reader.uint32();
                    break;
                case 19:
                    message.cpuMigrations = reader.uint32();
                    break;
                case 20:
                    message.alignmentFaults = reader.uint32();
                    break;
                case 21:
                    message.emulationFaults = reader.uint32();
                    break;
                case 22:
                    message.l1DcacheLoads = reader.uint32();
                    break;
                case 23:
                    message.l1DcacheLoadMisses = reader.uint32();
                    break;
                case 24:
                    message.l1DcacheStores = reader.uint32();
                    break;
                case 25:
                    message.l1DcacheStoreMisses = reader.uint32();
                    break;
                case 26:
                    message.l1DcachePrefetches = reader.uint32();
                    break;
                case 27:
                    message.l1DcachePrefetchMisses = reader.uint32();
                    break;
                case 28:
                    message.l1IcacheLoads = reader.uint32();
                    break;
                case 29:
                    message.l1IcacheLoadMisses = reader.uint32();
                    break;
                case 30:
                    message.l1IcachePrefetches = reader.uint32();
                    break;
                case 31:
                    message.l1IcachePrefetchMisses = reader.uint32();
                    break;
                case 32:
                    message.llcLoads = reader.uint32();
                    break;
                case 33:
                    message.llcLoadMisses = reader.uint32();
                    break;
                case 34:
                    message.llcStores = reader.uint32();
                    break;
                case 35:
                    message.llcStoreMisses = reader.uint32();
                    break;
                case 36:
                    message.llcPrefetches = reader.uint32();
                    break;
                case 37:
                    message.llcPrefetchMisses = reader.uint32();
                    break;
                case 38:
                    message.dtlbLoads = reader.uint32();
                    break;
                case 39:
                    message.dtlbLoadMisses = reader.uint32();
                    break;
                case 40:
                    message.dtlbStores = reader.uint32();
                    break;
                case 41:
                    message.dtlbStoreMisses = reader.uint32();
                    break;
                case 42:
                    message.dtlbPrefetches = reader.uint32();
                    break;
                case 43:
                    message.dtlbPrefetchMisses = reader.uint32();
                    break;
                case 44:
                    message.itlbLoads = reader.uint32();
                    break;
                case 45:
                    message.itlbLoadMisses = reader.uint32();
                    break;
                case 46:
                    message.branchLoads = reader.uint32();
                    break;
                case 47:
                    message.branchLoadMisses = reader.uint32();
                    break;
                case 48:
                    message.nodeLoads = reader.uint32();
                    break;
                case 49:
                    message.nodeLoadMisses = reader.uint32();
                    break;
                case 50:
                    message.nodeStores = reader.uint32();
                    break;
                case 51:
                    message.nodeStoreMisses = reader.uint32();
                    break;
                case 52:
                    message.nodePrefetches = reader.uint32();
                    break;
                case 53:
                    message.nodePrefetchMisses = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            if (!message.hasOwnProperty("duration"))
                throw $util.ProtocolError("missing required 'duration'", { instance: message });
            return message;
        };

        /**
         * Decodes a PerfStatistics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.PerfStatistics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.PerfStatistics} PerfStatistics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PerfStatistics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PerfStatistics message.
         * @function verify
         * @memberof mesos.PerfStatistics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PerfStatistics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (typeof message.duration !== "number")
                return "duration: number expected";
            if (message.cycles != null && message.hasOwnProperty("cycles"))
                if (!$util.isInteger(message.cycles))
                    return "cycles: integer expected";
            if (message.stalledCyclesFrontend != null && message.hasOwnProperty("stalledCyclesFrontend"))
                if (!$util.isInteger(message.stalledCyclesFrontend))
                    return "stalledCyclesFrontend: integer expected";
            if (message.stalledCyclesBackend != null && message.hasOwnProperty("stalledCyclesBackend"))
                if (!$util.isInteger(message.stalledCyclesBackend))
                    return "stalledCyclesBackend: integer expected";
            if (message.instructions != null && message.hasOwnProperty("instructions"))
                if (!$util.isInteger(message.instructions))
                    return "instructions: integer expected";
            if (message.cacheReferences != null && message.hasOwnProperty("cacheReferences"))
                if (!$util.isInteger(message.cacheReferences))
                    return "cacheReferences: integer expected";
            if (message.cacheMisses != null && message.hasOwnProperty("cacheMisses"))
                if (!$util.isInteger(message.cacheMisses))
                    return "cacheMisses: integer expected";
            if (message.branches != null && message.hasOwnProperty("branches"))
                if (!$util.isInteger(message.branches))
                    return "branches: integer expected";
            if (message.branchMisses != null && message.hasOwnProperty("branchMisses"))
                if (!$util.isInteger(message.branchMisses))
                    return "branchMisses: integer expected";
            if (message.busCycles != null && message.hasOwnProperty("busCycles"))
                if (!$util.isInteger(message.busCycles))
                    return "busCycles: integer expected";
            if (message.refCycles != null && message.hasOwnProperty("refCycles"))
                if (!$util.isInteger(message.refCycles))
                    return "refCycles: integer expected";
            if (message.cpuClock != null && message.hasOwnProperty("cpuClock"))
                if (typeof message.cpuClock !== "number")
                    return "cpuClock: number expected";
            if (message.taskClock != null && message.hasOwnProperty("taskClock"))
                if (typeof message.taskClock !== "number")
                    return "taskClock: number expected";
            if (message.pageFaults != null && message.hasOwnProperty("pageFaults"))
                if (!$util.isInteger(message.pageFaults))
                    return "pageFaults: integer expected";
            if (message.minorFaults != null && message.hasOwnProperty("minorFaults"))
                if (!$util.isInteger(message.minorFaults))
                    return "minorFaults: integer expected";
            if (message.majorFaults != null && message.hasOwnProperty("majorFaults"))
                if (!$util.isInteger(message.majorFaults))
                    return "majorFaults: integer expected";
            if (message.contextSwitches != null && message.hasOwnProperty("contextSwitches"))
                if (!$util.isInteger(message.contextSwitches))
                    return "contextSwitches: integer expected";
            if (message.cpuMigrations != null && message.hasOwnProperty("cpuMigrations"))
                if (!$util.isInteger(message.cpuMigrations))
                    return "cpuMigrations: integer expected";
            if (message.alignmentFaults != null && message.hasOwnProperty("alignmentFaults"))
                if (!$util.isInteger(message.alignmentFaults))
                    return "alignmentFaults: integer expected";
            if (message.emulationFaults != null && message.hasOwnProperty("emulationFaults"))
                if (!$util.isInteger(message.emulationFaults))
                    return "emulationFaults: integer expected";
            if (message.l1DcacheLoads != null && message.hasOwnProperty("l1DcacheLoads"))
                if (!$util.isInteger(message.l1DcacheLoads))
                    return "l1DcacheLoads: integer expected";
            if (message.l1DcacheLoadMisses != null && message.hasOwnProperty("l1DcacheLoadMisses"))
                if (!$util.isInteger(message.l1DcacheLoadMisses))
                    return "l1DcacheLoadMisses: integer expected";
            if (message.l1DcacheStores != null && message.hasOwnProperty("l1DcacheStores"))
                if (!$util.isInteger(message.l1DcacheStores))
                    return "l1DcacheStores: integer expected";
            if (message.l1DcacheStoreMisses != null && message.hasOwnProperty("l1DcacheStoreMisses"))
                if (!$util.isInteger(message.l1DcacheStoreMisses))
                    return "l1DcacheStoreMisses: integer expected";
            if (message.l1DcachePrefetches != null && message.hasOwnProperty("l1DcachePrefetches"))
                if (!$util.isInteger(message.l1DcachePrefetches))
                    return "l1DcachePrefetches: integer expected";
            if (message.l1DcachePrefetchMisses != null && message.hasOwnProperty("l1DcachePrefetchMisses"))
                if (!$util.isInteger(message.l1DcachePrefetchMisses))
                    return "l1DcachePrefetchMisses: integer expected";
            if (message.l1IcacheLoads != null && message.hasOwnProperty("l1IcacheLoads"))
                if (!$util.isInteger(message.l1IcacheLoads))
                    return "l1IcacheLoads: integer expected";
            if (message.l1IcacheLoadMisses != null && message.hasOwnProperty("l1IcacheLoadMisses"))
                if (!$util.isInteger(message.l1IcacheLoadMisses))
                    return "l1IcacheLoadMisses: integer expected";
            if (message.l1IcachePrefetches != null && message.hasOwnProperty("l1IcachePrefetches"))
                if (!$util.isInteger(message.l1IcachePrefetches))
                    return "l1IcachePrefetches: integer expected";
            if (message.l1IcachePrefetchMisses != null && message.hasOwnProperty("l1IcachePrefetchMisses"))
                if (!$util.isInteger(message.l1IcachePrefetchMisses))
                    return "l1IcachePrefetchMisses: integer expected";
            if (message.llcLoads != null && message.hasOwnProperty("llcLoads"))
                if (!$util.isInteger(message.llcLoads))
                    return "llcLoads: integer expected";
            if (message.llcLoadMisses != null && message.hasOwnProperty("llcLoadMisses"))
                if (!$util.isInteger(message.llcLoadMisses))
                    return "llcLoadMisses: integer expected";
            if (message.llcStores != null && message.hasOwnProperty("llcStores"))
                if (!$util.isInteger(message.llcStores))
                    return "llcStores: integer expected";
            if (message.llcStoreMisses != null && message.hasOwnProperty("llcStoreMisses"))
                if (!$util.isInteger(message.llcStoreMisses))
                    return "llcStoreMisses: integer expected";
            if (message.llcPrefetches != null && message.hasOwnProperty("llcPrefetches"))
                if (!$util.isInteger(message.llcPrefetches))
                    return "llcPrefetches: integer expected";
            if (message.llcPrefetchMisses != null && message.hasOwnProperty("llcPrefetchMisses"))
                if (!$util.isInteger(message.llcPrefetchMisses))
                    return "llcPrefetchMisses: integer expected";
            if (message.dtlbLoads != null && message.hasOwnProperty("dtlbLoads"))
                if (!$util.isInteger(message.dtlbLoads))
                    return "dtlbLoads: integer expected";
            if (message.dtlbLoadMisses != null && message.hasOwnProperty("dtlbLoadMisses"))
                if (!$util.isInteger(message.dtlbLoadMisses))
                    return "dtlbLoadMisses: integer expected";
            if (message.dtlbStores != null && message.hasOwnProperty("dtlbStores"))
                if (!$util.isInteger(message.dtlbStores))
                    return "dtlbStores: integer expected";
            if (message.dtlbStoreMisses != null && message.hasOwnProperty("dtlbStoreMisses"))
                if (!$util.isInteger(message.dtlbStoreMisses))
                    return "dtlbStoreMisses: integer expected";
            if (message.dtlbPrefetches != null && message.hasOwnProperty("dtlbPrefetches"))
                if (!$util.isInteger(message.dtlbPrefetches))
                    return "dtlbPrefetches: integer expected";
            if (message.dtlbPrefetchMisses != null && message.hasOwnProperty("dtlbPrefetchMisses"))
                if (!$util.isInteger(message.dtlbPrefetchMisses))
                    return "dtlbPrefetchMisses: integer expected";
            if (message.itlbLoads != null && message.hasOwnProperty("itlbLoads"))
                if (!$util.isInteger(message.itlbLoads))
                    return "itlbLoads: integer expected";
            if (message.itlbLoadMisses != null && message.hasOwnProperty("itlbLoadMisses"))
                if (!$util.isInteger(message.itlbLoadMisses))
                    return "itlbLoadMisses: integer expected";
            if (message.branchLoads != null && message.hasOwnProperty("branchLoads"))
                if (!$util.isInteger(message.branchLoads))
                    return "branchLoads: integer expected";
            if (message.branchLoadMisses != null && message.hasOwnProperty("branchLoadMisses"))
                if (!$util.isInteger(message.branchLoadMisses))
                    return "branchLoadMisses: integer expected";
            if (message.nodeLoads != null && message.hasOwnProperty("nodeLoads"))
                if (!$util.isInteger(message.nodeLoads))
                    return "nodeLoads: integer expected";
            if (message.nodeLoadMisses != null && message.hasOwnProperty("nodeLoadMisses"))
                if (!$util.isInteger(message.nodeLoadMisses))
                    return "nodeLoadMisses: integer expected";
            if (message.nodeStores != null && message.hasOwnProperty("nodeStores"))
                if (!$util.isInteger(message.nodeStores))
                    return "nodeStores: integer expected";
            if (message.nodeStoreMisses != null && message.hasOwnProperty("nodeStoreMisses"))
                if (!$util.isInteger(message.nodeStoreMisses))
                    return "nodeStoreMisses: integer expected";
            if (message.nodePrefetches != null && message.hasOwnProperty("nodePrefetches"))
                if (!$util.isInteger(message.nodePrefetches))
                    return "nodePrefetches: integer expected";
            if (message.nodePrefetchMisses != null && message.hasOwnProperty("nodePrefetchMisses"))
                if (!$util.isInteger(message.nodePrefetchMisses))
                    return "nodePrefetchMisses: integer expected";
            return null;
        };

        /**
         * Creates a PerfStatistics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.PerfStatistics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.PerfStatistics} PerfStatistics
         */
        PerfStatistics.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.PerfStatistics)
                return object;
            let message = new $root.mesos.PerfStatistics();
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.duration != null)
                message.duration = Number(object.duration);
            if (object.cycles != null)
                message.cycles = object.cycles >>> 0;
            if (object.stalledCyclesFrontend != null)
                message.stalledCyclesFrontend = object.stalledCyclesFrontend >>> 0;
            if (object.stalledCyclesBackend != null)
                message.stalledCyclesBackend = object.stalledCyclesBackend >>> 0;
            if (object.instructions != null)
                message.instructions = object.instructions >>> 0;
            if (object.cacheReferences != null)
                message.cacheReferences = object.cacheReferences >>> 0;
            if (object.cacheMisses != null)
                message.cacheMisses = object.cacheMisses >>> 0;
            if (object.branches != null)
                message.branches = object.branches >>> 0;
            if (object.branchMisses != null)
                message.branchMisses = object.branchMisses >>> 0;
            if (object.busCycles != null)
                message.busCycles = object.busCycles >>> 0;
            if (object.refCycles != null)
                message.refCycles = object.refCycles >>> 0;
            if (object.cpuClock != null)
                message.cpuClock = Number(object.cpuClock);
            if (object.taskClock != null)
                message.taskClock = Number(object.taskClock);
            if (object.pageFaults != null)
                message.pageFaults = object.pageFaults >>> 0;
            if (object.minorFaults != null)
                message.minorFaults = object.minorFaults >>> 0;
            if (object.majorFaults != null)
                message.majorFaults = object.majorFaults >>> 0;
            if (object.contextSwitches != null)
                message.contextSwitches = object.contextSwitches >>> 0;
            if (object.cpuMigrations != null)
                message.cpuMigrations = object.cpuMigrations >>> 0;
            if (object.alignmentFaults != null)
                message.alignmentFaults = object.alignmentFaults >>> 0;
            if (object.emulationFaults != null)
                message.emulationFaults = object.emulationFaults >>> 0;
            if (object.l1DcacheLoads != null)
                message.l1DcacheLoads = object.l1DcacheLoads >>> 0;
            if (object.l1DcacheLoadMisses != null)
                message.l1DcacheLoadMisses = object.l1DcacheLoadMisses >>> 0;
            if (object.l1DcacheStores != null)
                message.l1DcacheStores = object.l1DcacheStores >>> 0;
            if (object.l1DcacheStoreMisses != null)
                message.l1DcacheStoreMisses = object.l1DcacheStoreMisses >>> 0;
            if (object.l1DcachePrefetches != null)
                message.l1DcachePrefetches = object.l1DcachePrefetches >>> 0;
            if (object.l1DcachePrefetchMisses != null)
                message.l1DcachePrefetchMisses = object.l1DcachePrefetchMisses >>> 0;
            if (object.l1IcacheLoads != null)
                message.l1IcacheLoads = object.l1IcacheLoads >>> 0;
            if (object.l1IcacheLoadMisses != null)
                message.l1IcacheLoadMisses = object.l1IcacheLoadMisses >>> 0;
            if (object.l1IcachePrefetches != null)
                message.l1IcachePrefetches = object.l1IcachePrefetches >>> 0;
            if (object.l1IcachePrefetchMisses != null)
                message.l1IcachePrefetchMisses = object.l1IcachePrefetchMisses >>> 0;
            if (object.llcLoads != null)
                message.llcLoads = object.llcLoads >>> 0;
            if (object.llcLoadMisses != null)
                message.llcLoadMisses = object.llcLoadMisses >>> 0;
            if (object.llcStores != null)
                message.llcStores = object.llcStores >>> 0;
            if (object.llcStoreMisses != null)
                message.llcStoreMisses = object.llcStoreMisses >>> 0;
            if (object.llcPrefetches != null)
                message.llcPrefetches = object.llcPrefetches >>> 0;
            if (object.llcPrefetchMisses != null)
                message.llcPrefetchMisses = object.llcPrefetchMisses >>> 0;
            if (object.dtlbLoads != null)
                message.dtlbLoads = object.dtlbLoads >>> 0;
            if (object.dtlbLoadMisses != null)
                message.dtlbLoadMisses = object.dtlbLoadMisses >>> 0;
            if (object.dtlbStores != null)
                message.dtlbStores = object.dtlbStores >>> 0;
            if (object.dtlbStoreMisses != null)
                message.dtlbStoreMisses = object.dtlbStoreMisses >>> 0;
            if (object.dtlbPrefetches != null)
                message.dtlbPrefetches = object.dtlbPrefetches >>> 0;
            if (object.dtlbPrefetchMisses != null)
                message.dtlbPrefetchMisses = object.dtlbPrefetchMisses >>> 0;
            if (object.itlbLoads != null)
                message.itlbLoads = object.itlbLoads >>> 0;
            if (object.itlbLoadMisses != null)
                message.itlbLoadMisses = object.itlbLoadMisses >>> 0;
            if (object.branchLoads != null)
                message.branchLoads = object.branchLoads >>> 0;
            if (object.branchLoadMisses != null)
                message.branchLoadMisses = object.branchLoadMisses >>> 0;
            if (object.nodeLoads != null)
                message.nodeLoads = object.nodeLoads >>> 0;
            if (object.nodeLoadMisses != null)
                message.nodeLoadMisses = object.nodeLoadMisses >>> 0;
            if (object.nodeStores != null)
                message.nodeStores = object.nodeStores >>> 0;
            if (object.nodeStoreMisses != null)
                message.nodeStoreMisses = object.nodeStoreMisses >>> 0;
            if (object.nodePrefetches != null)
                message.nodePrefetches = object.nodePrefetches >>> 0;
            if (object.nodePrefetchMisses != null)
                message.nodePrefetchMisses = object.nodePrefetchMisses >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PerfStatistics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.PerfStatistics
         * @static
         * @param {mesos.PerfStatistics} message PerfStatistics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PerfStatistics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.timestamp = 0;
                object.duration = 0;
                object.cycles = 0;
                object.stalledCyclesFrontend = 0;
                object.stalledCyclesBackend = 0;
                object.instructions = 0;
                object.cacheReferences = 0;
                object.cacheMisses = 0;
                object.branches = 0;
                object.branchMisses = 0;
                object.busCycles = 0;
                object.refCycles = 0;
                object.cpuClock = 0;
                object.taskClock = 0;
                object.pageFaults = 0;
                object.minorFaults = 0;
                object.majorFaults = 0;
                object.contextSwitches = 0;
                object.cpuMigrations = 0;
                object.alignmentFaults = 0;
                object.emulationFaults = 0;
                object.l1DcacheLoads = 0;
                object.l1DcacheLoadMisses = 0;
                object.l1DcacheStores = 0;
                object.l1DcacheStoreMisses = 0;
                object.l1DcachePrefetches = 0;
                object.l1DcachePrefetchMisses = 0;
                object.l1IcacheLoads = 0;
                object.l1IcacheLoadMisses = 0;
                object.l1IcachePrefetches = 0;
                object.l1IcachePrefetchMisses = 0;
                object.llcLoads = 0;
                object.llcLoadMisses = 0;
                object.llcStores = 0;
                object.llcStoreMisses = 0;
                object.llcPrefetches = 0;
                object.llcPrefetchMisses = 0;
                object.dtlbLoads = 0;
                object.dtlbLoadMisses = 0;
                object.dtlbStores = 0;
                object.dtlbStoreMisses = 0;
                object.dtlbPrefetches = 0;
                object.dtlbPrefetchMisses = 0;
                object.itlbLoads = 0;
                object.itlbLoadMisses = 0;
                object.branchLoads = 0;
                object.branchLoadMisses = 0;
                object.nodeLoads = 0;
                object.nodeLoadMisses = 0;
                object.nodeStores = 0;
                object.nodeStoreMisses = 0;
                object.nodePrefetches = 0;
                object.nodePrefetchMisses = 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
            if (message.cycles != null && message.hasOwnProperty("cycles"))
                object.cycles = message.cycles;
            if (message.stalledCyclesFrontend != null && message.hasOwnProperty("stalledCyclesFrontend"))
                object.stalledCyclesFrontend = message.stalledCyclesFrontend;
            if (message.stalledCyclesBackend != null && message.hasOwnProperty("stalledCyclesBackend"))
                object.stalledCyclesBackend = message.stalledCyclesBackend;
            if (message.instructions != null && message.hasOwnProperty("instructions"))
                object.instructions = message.instructions;
            if (message.cacheReferences != null && message.hasOwnProperty("cacheReferences"))
                object.cacheReferences = message.cacheReferences;
            if (message.cacheMisses != null && message.hasOwnProperty("cacheMisses"))
                object.cacheMisses = message.cacheMisses;
            if (message.branches != null && message.hasOwnProperty("branches"))
                object.branches = message.branches;
            if (message.branchMisses != null && message.hasOwnProperty("branchMisses"))
                object.branchMisses = message.branchMisses;
            if (message.busCycles != null && message.hasOwnProperty("busCycles"))
                object.busCycles = message.busCycles;
            if (message.refCycles != null && message.hasOwnProperty("refCycles"))
                object.refCycles = message.refCycles;
            if (message.cpuClock != null && message.hasOwnProperty("cpuClock"))
                object.cpuClock = options.json && !isFinite(message.cpuClock) ? String(message.cpuClock) : message.cpuClock;
            if (message.taskClock != null && message.hasOwnProperty("taskClock"))
                object.taskClock = options.json && !isFinite(message.taskClock) ? String(message.taskClock) : message.taskClock;
            if (message.pageFaults != null && message.hasOwnProperty("pageFaults"))
                object.pageFaults = message.pageFaults;
            if (message.minorFaults != null && message.hasOwnProperty("minorFaults"))
                object.minorFaults = message.minorFaults;
            if (message.majorFaults != null && message.hasOwnProperty("majorFaults"))
                object.majorFaults = message.majorFaults;
            if (message.contextSwitches != null && message.hasOwnProperty("contextSwitches"))
                object.contextSwitches = message.contextSwitches;
            if (message.cpuMigrations != null && message.hasOwnProperty("cpuMigrations"))
                object.cpuMigrations = message.cpuMigrations;
            if (message.alignmentFaults != null && message.hasOwnProperty("alignmentFaults"))
                object.alignmentFaults = message.alignmentFaults;
            if (message.emulationFaults != null && message.hasOwnProperty("emulationFaults"))
                object.emulationFaults = message.emulationFaults;
            if (message.l1DcacheLoads != null && message.hasOwnProperty("l1DcacheLoads"))
                object.l1DcacheLoads = message.l1DcacheLoads;
            if (message.l1DcacheLoadMisses != null && message.hasOwnProperty("l1DcacheLoadMisses"))
                object.l1DcacheLoadMisses = message.l1DcacheLoadMisses;
            if (message.l1DcacheStores != null && message.hasOwnProperty("l1DcacheStores"))
                object.l1DcacheStores = message.l1DcacheStores;
            if (message.l1DcacheStoreMisses != null && message.hasOwnProperty("l1DcacheStoreMisses"))
                object.l1DcacheStoreMisses = message.l1DcacheStoreMisses;
            if (message.l1DcachePrefetches != null && message.hasOwnProperty("l1DcachePrefetches"))
                object.l1DcachePrefetches = message.l1DcachePrefetches;
            if (message.l1DcachePrefetchMisses != null && message.hasOwnProperty("l1DcachePrefetchMisses"))
                object.l1DcachePrefetchMisses = message.l1DcachePrefetchMisses;
            if (message.l1IcacheLoads != null && message.hasOwnProperty("l1IcacheLoads"))
                object.l1IcacheLoads = message.l1IcacheLoads;
            if (message.l1IcacheLoadMisses != null && message.hasOwnProperty("l1IcacheLoadMisses"))
                object.l1IcacheLoadMisses = message.l1IcacheLoadMisses;
            if (message.l1IcachePrefetches != null && message.hasOwnProperty("l1IcachePrefetches"))
                object.l1IcachePrefetches = message.l1IcachePrefetches;
            if (message.l1IcachePrefetchMisses != null && message.hasOwnProperty("l1IcachePrefetchMisses"))
                object.l1IcachePrefetchMisses = message.l1IcachePrefetchMisses;
            if (message.llcLoads != null && message.hasOwnProperty("llcLoads"))
                object.llcLoads = message.llcLoads;
            if (message.llcLoadMisses != null && message.hasOwnProperty("llcLoadMisses"))
                object.llcLoadMisses = message.llcLoadMisses;
            if (message.llcStores != null && message.hasOwnProperty("llcStores"))
                object.llcStores = message.llcStores;
            if (message.llcStoreMisses != null && message.hasOwnProperty("llcStoreMisses"))
                object.llcStoreMisses = message.llcStoreMisses;
            if (message.llcPrefetches != null && message.hasOwnProperty("llcPrefetches"))
                object.llcPrefetches = message.llcPrefetches;
            if (message.llcPrefetchMisses != null && message.hasOwnProperty("llcPrefetchMisses"))
                object.llcPrefetchMisses = message.llcPrefetchMisses;
            if (message.dtlbLoads != null && message.hasOwnProperty("dtlbLoads"))
                object.dtlbLoads = message.dtlbLoads;
            if (message.dtlbLoadMisses != null && message.hasOwnProperty("dtlbLoadMisses"))
                object.dtlbLoadMisses = message.dtlbLoadMisses;
            if (message.dtlbStores != null && message.hasOwnProperty("dtlbStores"))
                object.dtlbStores = message.dtlbStores;
            if (message.dtlbStoreMisses != null && message.hasOwnProperty("dtlbStoreMisses"))
                object.dtlbStoreMisses = message.dtlbStoreMisses;
            if (message.dtlbPrefetches != null && message.hasOwnProperty("dtlbPrefetches"))
                object.dtlbPrefetches = message.dtlbPrefetches;
            if (message.dtlbPrefetchMisses != null && message.hasOwnProperty("dtlbPrefetchMisses"))
                object.dtlbPrefetchMisses = message.dtlbPrefetchMisses;
            if (message.itlbLoads != null && message.hasOwnProperty("itlbLoads"))
                object.itlbLoads = message.itlbLoads;
            if (message.itlbLoadMisses != null && message.hasOwnProperty("itlbLoadMisses"))
                object.itlbLoadMisses = message.itlbLoadMisses;
            if (message.branchLoads != null && message.hasOwnProperty("branchLoads"))
                object.branchLoads = message.branchLoads;
            if (message.branchLoadMisses != null && message.hasOwnProperty("branchLoadMisses"))
                object.branchLoadMisses = message.branchLoadMisses;
            if (message.nodeLoads != null && message.hasOwnProperty("nodeLoads"))
                object.nodeLoads = message.nodeLoads;
            if (message.nodeLoadMisses != null && message.hasOwnProperty("nodeLoadMisses"))
                object.nodeLoadMisses = message.nodeLoadMisses;
            if (message.nodeStores != null && message.hasOwnProperty("nodeStores"))
                object.nodeStores = message.nodeStores;
            if (message.nodeStoreMisses != null && message.hasOwnProperty("nodeStoreMisses"))
                object.nodeStoreMisses = message.nodeStoreMisses;
            if (message.nodePrefetches != null && message.hasOwnProperty("nodePrefetches"))
                object.nodePrefetches = message.nodePrefetches;
            if (message.nodePrefetchMisses != null && message.hasOwnProperty("nodePrefetchMisses"))
                object.nodePrefetchMisses = message.nodePrefetchMisses;
            return object;
        };

        /**
         * Converts this PerfStatistics to JSON.
         * @function toJSON
         * @memberof mesos.PerfStatistics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PerfStatistics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PerfStatistics;
    })();

    mesos.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof mesos
         * @interface IRequest
         * @property {mesos.IAgentID} [agentId] Request agentId
         * @property {Array.<mesos.IResource>} [resources] Request resources
         */

        /**
         * Constructs a new Request.
         * @memberof mesos
         * @classdesc Describes a request for resources that can be used by a framework
         * to proactively influence the allocator.  If 'agent_id' is provided
         * then this request is assumed to only apply to resources on that
         * agent.
         * @constructor
         * @param {mesos.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            this.resources = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request agentId.
         * @member {(mesos.IAgentID|null|undefined)}agentId
         * @memberof mesos.Request
         * @instance
         */
        Request.prototype.agentId = null;

        /**
         * Request resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.Request
         * @instance
         */
        Request.prototype.resources = $util.emptyArray;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof mesos.Request
         * @static
         * @param {mesos.IRequest=} [properties] Properties to set
         * @returns {mesos.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link mesos.Request.verify|verify} messages.
         * @function encode
         * @memberof mesos.Request
         * @static
         * @param {mesos.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link mesos.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Request
         * @static
         * @param {mesos.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof mesos.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.agentId != null && message.hasOwnProperty("agentId")) {
                let error = $root.mesos.AgentID.verify(message.agentId);
                if (error)
                    return "agentId." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Request)
                return object;
            let message = new $root.mesos.Request();
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.Request.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.Request.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.Request.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Request
         * @static
         * @param {mesos.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (options.defaults)
                object.agentId = null;
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof mesos.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    mesos.Offer = (function() {

        /**
         * Properties of an Offer.
         * @memberof mesos
         * @interface IOffer
         * @property {mesos.IOfferID} id Offer id
         * @property {mesos.IFrameworkID} frameworkId Offer frameworkId
         * @property {mesos.IAgentID} agentId Offer agentId
         * @property {string} hostname Offer hostname
         * @property {mesos.IURL} [url] Offer url
         * @property {Array.<mesos.IResource>} [resources] Offer resources
         * @property {Array.<mesos.IAttribute>} [attributes] Offer attributes
         * @property {Array.<mesos.IExecutorID>} [executorIds] Offer executorIds
         * @property {mesos.IUnavailability} [unavailability] Offer unavailability
         * @property {mesos.Resource.IAllocationInfo} [allocationInfo] Offer allocationInfo
         */

        /**
         * Constructs a new Offer.
         * @memberof mesos
         * @classdesc Describes some resources available on an agent. An offer only
         * contains resources from a single agent.
         * @constructor
         * @param {mesos.IOffer=} [properties] Properties to set
         */
        function Offer(properties) {
            this.resources = [];
            this.attributes = [];
            this.executorIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Offer id.
         * @member {mesos.IOfferID}id
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.id = null;

        /**
         * Offer frameworkId.
         * @member {mesos.IFrameworkID}frameworkId
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.frameworkId = null;

        /**
         * Offer agentId.
         * @member {mesos.IAgentID}agentId
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.agentId = null;

        /**
         * Offer hostname.
         * @member {string}hostname
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.hostname = "";

        /**
         * Offer url.
         * @member {(mesos.IURL|null|undefined)}url
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.url = null;

        /**
         * Offer resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.resources = $util.emptyArray;

        /**
         * Offer attributes.
         * @member {Array.<mesos.IAttribute>}attributes
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.attributes = $util.emptyArray;

        /**
         * Offer executorIds.
         * @member {Array.<mesos.IExecutorID>}executorIds
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.executorIds = $util.emptyArray;

        /**
         * Offer unavailability.
         * @member {(mesos.IUnavailability|null|undefined)}unavailability
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.unavailability = null;

        /**
         * Offer allocationInfo.
         * @member {(mesos.Resource.IAllocationInfo|null|undefined)}allocationInfo
         * @memberof mesos.Offer
         * @instance
         */
        Offer.prototype.allocationInfo = null;

        /**
         * Creates a new Offer instance using the specified properties.
         * @function create
         * @memberof mesos.Offer
         * @static
         * @param {mesos.IOffer=} [properties] Properties to set
         * @returns {mesos.Offer} Offer instance
         */
        Offer.create = function create(properties) {
            return new Offer(properties);
        };

        /**
         * Encodes the specified Offer message. Does not implicitly {@link mesos.Offer.verify|verify} messages.
         * @function encode
         * @memberof mesos.Offer
         * @static
         * @param {mesos.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.OfferID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.hostname);
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.executorIds != null && message.executorIds.length)
                for (let i = 0; i < message.executorIds.length; ++i)
                    $root.mesos.ExecutorID.encode(message.executorIds[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.attributes != null && message.attributes.length)
                for (let i = 0; i < message.attributes.length; ++i)
                    $root.mesos.Attribute.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.url != null && message.hasOwnProperty("url"))
                $root.mesos.URL.encode(message.url, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.unavailability != null && message.hasOwnProperty("unavailability"))
                $root.mesos.Unavailability.encode(message.unavailability, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo"))
                $root.mesos.Resource.AllocationInfo.encode(message.allocationInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Offer message, length delimited. Does not implicitly {@link mesos.Offer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Offer
         * @static
         * @param {mesos.IOffer} message Offer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Offer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Offer message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.mesos.OfferID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.hostname = reader.string();
                    break;
                case 8:
                    message.url = $root.mesos.URL.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                    message.attributes.push($root.mesos.Attribute.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.executorIds && message.executorIds.length))
                        message.executorIds = [];
                    message.executorIds.push($root.mesos.ExecutorID.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.unavailability = $root.mesos.Unavailability.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.allocationInfo = $root.mesos.Resource.AllocationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("frameworkId"))
                throw $util.ProtocolError("missing required 'frameworkId'", { instance: message });
            if (!message.hasOwnProperty("agentId"))
                throw $util.ProtocolError("missing required 'agentId'", { instance: message });
            if (!message.hasOwnProperty("hostname"))
                throw $util.ProtocolError("missing required 'hostname'", { instance: message });
            return message;
        };

        /**
         * Decodes an Offer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Offer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Offer} Offer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Offer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Offer message.
         * @function verify
         * @memberof mesos.Offer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Offer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let error = $root.mesos.OfferID.verify(message.id);
            if (error)
                return "id." + error;
            error = $root.mesos.FrameworkID.verify(message.frameworkId);
            if (error)
                return "frameworkId." + error;
            error = $root.mesos.AgentID.verify(message.agentId);
            if (error)
                return "agentId." + error;
            if (!$util.isString(message.hostname))
                return "hostname: string expected";
            if (message.url != null && message.hasOwnProperty("url")) {
                error = $root.mesos.URL.verify(message.url);
                if (error)
                    return "url." + error;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.attributes != null && message.hasOwnProperty("attributes")) {
                if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                for (let i = 0; i < message.attributes.length; ++i) {
                    error = $root.mesos.Attribute.verify(message.attributes[i]);
                    if (error)
                        return "attributes." + error;
                }
            }
            if (message.executorIds != null && message.hasOwnProperty("executorIds")) {
                if (!Array.isArray(message.executorIds))
                    return "executorIds: array expected";
                for (let i = 0; i < message.executorIds.length; ++i) {
                    error = $root.mesos.ExecutorID.verify(message.executorIds[i]);
                    if (error)
                        return "executorIds." + error;
                }
            }
            if (message.unavailability != null && message.hasOwnProperty("unavailability")) {
                error = $root.mesos.Unavailability.verify(message.unavailability);
                if (error)
                    return "unavailability." + error;
            }
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo")) {
                error = $root.mesos.Resource.AllocationInfo.verify(message.allocationInfo);
                if (error)
                    return "allocationInfo." + error;
            }
            return null;
        };

        /**
         * Creates an Offer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Offer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Offer} Offer
         */
        Offer.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Offer)
                return object;
            let message = new $root.mesos.Offer();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".mesos.Offer.id: object expected");
                message.id = $root.mesos.OfferID.fromObject(object.id);
            }
            if (object.frameworkId != null) {
                if (typeof object.frameworkId !== "object")
                    throw TypeError(".mesos.Offer.frameworkId: object expected");
                message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
            }
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.Offer.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.url != null) {
                if (typeof object.url !== "object")
                    throw TypeError(".mesos.Offer.url: object expected");
                message.url = $root.mesos.URL.fromObject(object.url);
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.Offer.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.Offer.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            if (object.attributes) {
                if (!Array.isArray(object.attributes))
                    throw TypeError(".mesos.Offer.attributes: array expected");
                message.attributes = [];
                for (let i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] !== "object")
                        throw TypeError(".mesos.Offer.attributes: object expected");
                    message.attributes[i] = $root.mesos.Attribute.fromObject(object.attributes[i]);
                }
            }
            if (object.executorIds) {
                if (!Array.isArray(object.executorIds))
                    throw TypeError(".mesos.Offer.executorIds: array expected");
                message.executorIds = [];
                for (let i = 0; i < object.executorIds.length; ++i) {
                    if (typeof object.executorIds[i] !== "object")
                        throw TypeError(".mesos.Offer.executorIds: object expected");
                    message.executorIds[i] = $root.mesos.ExecutorID.fromObject(object.executorIds[i]);
                }
            }
            if (object.unavailability != null) {
                if (typeof object.unavailability !== "object")
                    throw TypeError(".mesos.Offer.unavailability: object expected");
                message.unavailability = $root.mesos.Unavailability.fromObject(object.unavailability);
            }
            if (object.allocationInfo != null) {
                if (typeof object.allocationInfo !== "object")
                    throw TypeError(".mesos.Offer.allocationInfo: object expected");
                message.allocationInfo = $root.mesos.Resource.AllocationInfo.fromObject(object.allocationInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from an Offer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Offer
         * @static
         * @param {mesos.Offer} message Offer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Offer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.resources = [];
                object.executorIds = [];
                object.attributes = [];
            }
            if (options.defaults) {
                object.id = null;
                object.frameworkId = null;
                object.agentId = null;
                object.hostname = "";
                object.url = null;
                object.unavailability = null;
                object.allocationInfo = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.mesos.OfferID.toObject(message.id, options);
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            if (message.executorIds && message.executorIds.length) {
                object.executorIds = [];
                for (let j = 0; j < message.executorIds.length; ++j)
                    object.executorIds[j] = $root.mesos.ExecutorID.toObject(message.executorIds[j], options);
            }
            if (message.attributes && message.attributes.length) {
                object.attributes = [];
                for (let j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.mesos.Attribute.toObject(message.attributes[j], options);
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = $root.mesos.URL.toObject(message.url, options);
            if (message.unavailability != null && message.hasOwnProperty("unavailability"))
                object.unavailability = $root.mesos.Unavailability.toObject(message.unavailability, options);
            if (message.allocationInfo != null && message.hasOwnProperty("allocationInfo"))
                object.allocationInfo = $root.mesos.Resource.AllocationInfo.toObject(message.allocationInfo, options);
            return object;
        };

        /**
         * Converts this Offer to JSON.
         * @function toJSON
         * @memberof mesos.Offer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Offer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Offer.Operation = (function() {

            /**
             * Properties of an Operation.
             * @memberof mesos.Offer
             * @interface IOperation
             * @property {mesos.Offer.Operation.Type} [type] Operation type
             * @property {mesos.Offer.Operation.ILaunch} [launch] Operation launch
             * @property {mesos.Offer.Operation.ILaunchGroup} [launchGroup] Operation launchGroup
             * @property {mesos.Offer.Operation.IReserve} [reserve] Operation reserve
             * @property {mesos.Offer.Operation.IUnreserve} [unreserve] Operation unreserve
             * @property {mesos.Offer.Operation.ICreate} [create] Operation create
             * @property {mesos.Offer.Operation.IDestroy} [destroy] Operation destroy
             */

            /**
             * Constructs a new Operation.
             * @memberof mesos.Offer
             * @classdesc Represents an Operation.
             * @constructor
             * @param {mesos.Offer.IOperation=} [properties] Properties to set
             */
            function Operation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operation type.
             * @member {mesos.Offer.Operation.Type}type
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.type = 0;

            /**
             * Operation launch.
             * @member {(mesos.Offer.Operation.ILaunch|null|undefined)}launch
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.launch = null;

            /**
             * Operation launchGroup.
             * @member {(mesos.Offer.Operation.ILaunchGroup|null|undefined)}launchGroup
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.launchGroup = null;

            /**
             * Operation reserve.
             * @member {(mesos.Offer.Operation.IReserve|null|undefined)}reserve
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.reserve = null;

            /**
             * Operation unreserve.
             * @member {(mesos.Offer.Operation.IUnreserve|null|undefined)}unreserve
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.unreserve = null;

            /**
             * Operation create.
             * @member {(mesos.Offer.Operation.ICreate|null|undefined)}create
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.create = null;

            /**
             * Operation destroy.
             * @member {(mesos.Offer.Operation.IDestroy|null|undefined)}destroy
             * @memberof mesos.Offer.Operation
             * @instance
             */
            Operation.prototype.destroy = null;

            /**
             * Creates a new Operation instance using the specified properties.
             * @function create
             * @memberof mesos.Offer.Operation
             * @static
             * @param {mesos.Offer.IOperation=} [properties] Properties to set
             * @returns {mesos.Offer.Operation} Operation instance
             */
            Operation.create = function create(properties) {
                return new Operation(properties);
            };

            /**
             * Encodes the specified Operation message. Does not implicitly {@link mesos.Offer.Operation.verify|verify} messages.
             * @function encode
             * @memberof mesos.Offer.Operation
             * @static
             * @param {mesos.Offer.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.launch != null && message.hasOwnProperty("launch"))
                    $root.mesos.Offer.Operation.Launch.encode(message.launch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.reserve != null && message.hasOwnProperty("reserve"))
                    $root.mesos.Offer.Operation.Reserve.encode(message.reserve, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.unreserve != null && message.hasOwnProperty("unreserve"))
                    $root.mesos.Offer.Operation.Unreserve.encode(message.unreserve, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.create != null && message.hasOwnProperty("create"))
                    $root.mesos.Offer.Operation.Create.encode(message.create, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.destroy != null && message.hasOwnProperty("destroy"))
                    $root.mesos.Offer.Operation.Destroy.encode(message.destroy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup"))
                    $root.mesos.Offer.Operation.LaunchGroup.encode(message.launchGroup, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Operation message, length delimited. Does not implicitly {@link mesos.Offer.Operation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Offer.Operation
             * @static
             * @param {mesos.Offer.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Operation message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Offer.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Offer.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.launch = $root.mesos.Offer.Operation.Launch.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.launchGroup = $root.mesos.Offer.Operation.LaunchGroup.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.reserve = $root.mesos.Offer.Operation.Reserve.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.unreserve = $root.mesos.Offer.Operation.Unreserve.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.create = $root.mesos.Offer.Operation.Create.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.destroy = $root.mesos.Offer.Operation.Destroy.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Operation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Offer.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Offer.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Operation message.
             * @function verify
             * @memberof mesos.Offer.Operation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 6:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.launch != null && message.hasOwnProperty("launch")) {
                    let error = $root.mesos.Offer.Operation.Launch.verify(message.launch);
                    if (error)
                        return "launch." + error;
                }
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup")) {
                    error = $root.mesos.Offer.Operation.LaunchGroup.verify(message.launchGroup);
                    if (error)
                        return "launchGroup." + error;
                }
                if (message.reserve != null && message.hasOwnProperty("reserve")) {
                    error = $root.mesos.Offer.Operation.Reserve.verify(message.reserve);
                    if (error)
                        return "reserve." + error;
                }
                if (message.unreserve != null && message.hasOwnProperty("unreserve")) {
                    error = $root.mesos.Offer.Operation.Unreserve.verify(message.unreserve);
                    if (error)
                        return "unreserve." + error;
                }
                if (message.create != null && message.hasOwnProperty("create")) {
                    error = $root.mesos.Offer.Operation.Create.verify(message.create);
                    if (error)
                        return "create." + error;
                }
                if (message.destroy != null && message.hasOwnProperty("destroy")) {
                    error = $root.mesos.Offer.Operation.Destroy.verify(message.destroy);
                    if (error)
                        return "destroy." + error;
                }
                return null;
            };

            /**
             * Creates an Operation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Offer.Operation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Offer.Operation} Operation
             */
            Operation.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Offer.Operation)
                    return object;
                let message = new $root.mesos.Offer.Operation();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "LAUNCH":
                case 1:
                    message.type = 1;
                    break;
                case "LAUNCH_GROUP":
                case 6:
                    message.type = 6;
                    break;
                case "RESERVE":
                case 2:
                    message.type = 2;
                    break;
                case "UNRESERVE":
                case 3:
                    message.type = 3;
                    break;
                case "CREATE":
                case 4:
                    message.type = 4;
                    break;
                case "DESTROY":
                case 5:
                    message.type = 5;
                    break;
                }
                if (object.launch != null) {
                    if (typeof object.launch !== "object")
                        throw TypeError(".mesos.Offer.Operation.launch: object expected");
                    message.launch = $root.mesos.Offer.Operation.Launch.fromObject(object.launch);
                }
                if (object.launchGroup != null) {
                    if (typeof object.launchGroup !== "object")
                        throw TypeError(".mesos.Offer.Operation.launchGroup: object expected");
                    message.launchGroup = $root.mesos.Offer.Operation.LaunchGroup.fromObject(object.launchGroup);
                }
                if (object.reserve != null) {
                    if (typeof object.reserve !== "object")
                        throw TypeError(".mesos.Offer.Operation.reserve: object expected");
                    message.reserve = $root.mesos.Offer.Operation.Reserve.fromObject(object.reserve);
                }
                if (object.unreserve != null) {
                    if (typeof object.unreserve !== "object")
                        throw TypeError(".mesos.Offer.Operation.unreserve: object expected");
                    message.unreserve = $root.mesos.Offer.Operation.Unreserve.fromObject(object.unreserve);
                }
                if (object.create != null) {
                    if (typeof object.create !== "object")
                        throw TypeError(".mesos.Offer.Operation.create: object expected");
                    message.create = $root.mesos.Offer.Operation.Create.fromObject(object.create);
                }
                if (object.destroy != null) {
                    if (typeof object.destroy !== "object")
                        throw TypeError(".mesos.Offer.Operation.destroy: object expected");
                    message.destroy = $root.mesos.Offer.Operation.Destroy.fromObject(object.destroy);
                }
                return message;
            };

            /**
             * Creates a plain object from an Operation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Offer.Operation
             * @static
             * @param {mesos.Offer.Operation} message Operation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.launch = null;
                    object.reserve = null;
                    object.unreserve = null;
                    object.create = null;
                    object.destroy = null;
                    object.launchGroup = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.Offer.Operation.Type[message.type] : message.type;
                if (message.launch != null && message.hasOwnProperty("launch"))
                    object.launch = $root.mesos.Offer.Operation.Launch.toObject(message.launch, options);
                if (message.reserve != null && message.hasOwnProperty("reserve"))
                    object.reserve = $root.mesos.Offer.Operation.Reserve.toObject(message.reserve, options);
                if (message.unreserve != null && message.hasOwnProperty("unreserve"))
                    object.unreserve = $root.mesos.Offer.Operation.Unreserve.toObject(message.unreserve, options);
                if (message.create != null && message.hasOwnProperty("create"))
                    object.create = $root.mesos.Offer.Operation.Create.toObject(message.create, options);
                if (message.destroy != null && message.hasOwnProperty("destroy"))
                    object.destroy = $root.mesos.Offer.Operation.Destroy.toObject(message.destroy, options);
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup"))
                    object.launchGroup = $root.mesos.Offer.Operation.LaunchGroup.toObject(message.launchGroup, options);
                return object;
            };

            /**
             * Converts this Operation to JSON.
             * @function toJSON
             * @memberof mesos.Offer.Operation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} LAUNCH=1 LAUNCH value
             * @property {number} LAUNCH_GROUP=6 LAUNCH_GROUP value
             * @property {number} RESERVE=2 RESERVE value
             * @property {number} UNRESERVE=3 UNRESERVE value
             * @property {number} CREATE=4 CREATE value
             * @property {number} DESTROY=5 DESTROY value
             */
            Operation.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "LAUNCH"] = 1;
                values[valuesById[6] = "LAUNCH_GROUP"] = 6;
                values[valuesById[2] = "RESERVE"] = 2;
                values[valuesById[3] = "UNRESERVE"] = 3;
                values[valuesById[4] = "CREATE"] = 4;
                values[valuesById[5] = "DESTROY"] = 5;
                return values;
            })();

            Operation.Launch = (function() {

                /**
                 * Properties of a Launch.
                 * @memberof mesos.Offer.Operation
                 * @interface ILaunch
                 * @property {Array.<mesos.ITaskInfo>} [taskInfos] Launch taskInfos
                 */

                /**
                 * Constructs a new Launch.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents a Launch.
                 * @constructor
                 * @param {mesos.Offer.Operation.ILaunch=} [properties] Properties to set
                 */
                function Launch(properties) {
                    this.taskInfos = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Launch taskInfos.
                 * @member {Array.<mesos.ITaskInfo>}taskInfos
                 * @memberof mesos.Offer.Operation.Launch
                 * @instance
                 */
                Launch.prototype.taskInfos = $util.emptyArray;

                /**
                 * Creates a new Launch instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {mesos.Offer.Operation.ILaunch=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.Launch} Launch instance
                 */
                Launch.create = function create(properties) {
                    return new Launch(properties);
                };

                /**
                 * Encodes the specified Launch message. Does not implicitly {@link mesos.Offer.Operation.Launch.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {mesos.Offer.Operation.ILaunch} message Launch message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Launch.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.taskInfos != null && message.taskInfos.length)
                        for (let i = 0; i < message.taskInfos.length; ++i)
                            $root.mesos.TaskInfo.encode(message.taskInfos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Launch message, length delimited. Does not implicitly {@link mesos.Offer.Operation.Launch.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {mesos.Offer.Operation.ILaunch} message Launch message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Launch.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Launch message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.Launch} Launch
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Launch.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.Launch();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.taskInfos && message.taskInfos.length))
                                message.taskInfos = [];
                            message.taskInfos.push($root.mesos.TaskInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Launch message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.Launch} Launch
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Launch.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Launch message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Launch.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.taskInfos != null && message.hasOwnProperty("taskInfos")) {
                        if (!Array.isArray(message.taskInfos))
                            return "taskInfos: array expected";
                        for (let i = 0; i < message.taskInfos.length; ++i) {
                            let error = $root.mesos.TaskInfo.verify(message.taskInfos[i]);
                            if (error)
                                return "taskInfos." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Launch message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.Launch} Launch
                 */
                Launch.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.Launch)
                        return object;
                    let message = new $root.mesos.Offer.Operation.Launch();
                    if (object.taskInfos) {
                        if (!Array.isArray(object.taskInfos))
                            throw TypeError(".mesos.Offer.Operation.Launch.taskInfos: array expected");
                        message.taskInfos = [];
                        for (let i = 0; i < object.taskInfos.length; ++i) {
                            if (typeof object.taskInfos[i] !== "object")
                                throw TypeError(".mesos.Offer.Operation.Launch.taskInfos: object expected");
                            message.taskInfos[i] = $root.mesos.TaskInfo.fromObject(object.taskInfos[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Launch message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.Launch
                 * @static
                 * @param {mesos.Offer.Operation.Launch} message Launch
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Launch.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.taskInfos = [];
                    if (message.taskInfos && message.taskInfos.length) {
                        object.taskInfos = [];
                        for (let j = 0; j < message.taskInfos.length; ++j)
                            object.taskInfos[j] = $root.mesos.TaskInfo.toObject(message.taskInfos[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Launch to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.Launch
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Launch.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Launch;
            })();

            Operation.LaunchGroup = (function() {

                /**
                 * Properties of a LaunchGroup.
                 * @memberof mesos.Offer.Operation
                 * @interface ILaunchGroup
                 * @property {mesos.IExecutorInfo} executor LaunchGroup executor
                 * @property {mesos.ITaskGroupInfo} taskGroup LaunchGroup taskGroup
                 */

                /**
                 * Constructs a new LaunchGroup.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents a LaunchGroup.
                 * @constructor
                 * @param {mesos.Offer.Operation.ILaunchGroup=} [properties] Properties to set
                 */
                function LaunchGroup(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LaunchGroup executor.
                 * @member {mesos.IExecutorInfo}executor
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @instance
                 */
                LaunchGroup.prototype.executor = null;

                /**
                 * LaunchGroup taskGroup.
                 * @member {mesos.ITaskGroupInfo}taskGroup
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @instance
                 */
                LaunchGroup.prototype.taskGroup = null;

                /**
                 * Creates a new LaunchGroup instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {mesos.Offer.Operation.ILaunchGroup=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.LaunchGroup} LaunchGroup instance
                 */
                LaunchGroup.create = function create(properties) {
                    return new LaunchGroup(properties);
                };

                /**
                 * Encodes the specified LaunchGroup message. Does not implicitly {@link mesos.Offer.Operation.LaunchGroup.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {mesos.Offer.Operation.ILaunchGroup} message LaunchGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchGroup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.ExecutorInfo.encode(message.executor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.TaskGroupInfo.encode(message.taskGroup, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LaunchGroup message, length delimited. Does not implicitly {@link mesos.Offer.Operation.LaunchGroup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {mesos.Offer.Operation.ILaunchGroup} message LaunchGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchGroup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LaunchGroup message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.LaunchGroup} LaunchGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchGroup.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.LaunchGroup();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executor = $root.mesos.ExecutorInfo.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.taskGroup = $root.mesos.TaskGroupInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("executor"))
                        throw $util.ProtocolError("missing required 'executor'", { instance: message });
                    if (!message.hasOwnProperty("taskGroup"))
                        throw $util.ProtocolError("missing required 'taskGroup'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a LaunchGroup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.LaunchGroup} LaunchGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchGroup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LaunchGroup message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchGroup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.ExecutorInfo.verify(message.executor);
                    if (error)
                        return "executor." + error;
                    error = $root.mesos.TaskGroupInfo.verify(message.taskGroup);
                    if (error)
                        return "taskGroup." + error;
                    return null;
                };

                /**
                 * Creates a LaunchGroup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.LaunchGroup} LaunchGroup
                 */
                LaunchGroup.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.LaunchGroup)
                        return object;
                    let message = new $root.mesos.Offer.Operation.LaunchGroup();
                    if (object.executor != null) {
                        if (typeof object.executor !== "object")
                            throw TypeError(".mesos.Offer.Operation.LaunchGroup.executor: object expected");
                        message.executor = $root.mesos.ExecutorInfo.fromObject(object.executor);
                    }
                    if (object.taskGroup != null) {
                        if (typeof object.taskGroup !== "object")
                            throw TypeError(".mesos.Offer.Operation.LaunchGroup.taskGroup: object expected");
                        message.taskGroup = $root.mesos.TaskGroupInfo.fromObject(object.taskGroup);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LaunchGroup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @static
                 * @param {mesos.Offer.Operation.LaunchGroup} message LaunchGroup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LaunchGroup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.executor = null;
                        object.taskGroup = null;
                    }
                    if (message.executor != null && message.hasOwnProperty("executor"))
                        object.executor = $root.mesos.ExecutorInfo.toObject(message.executor, options);
                    if (message.taskGroup != null && message.hasOwnProperty("taskGroup"))
                        object.taskGroup = $root.mesos.TaskGroupInfo.toObject(message.taskGroup, options);
                    return object;
                };

                /**
                 * Converts this LaunchGroup to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.LaunchGroup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LaunchGroup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LaunchGroup;
            })();

            Operation.Reserve = (function() {

                /**
                 * Properties of a Reserve.
                 * @memberof mesos.Offer.Operation
                 * @interface IReserve
                 * @property {Array.<mesos.IResource>} [resources] Reserve resources
                 */

                /**
                 * Constructs a new Reserve.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents a Reserve.
                 * @constructor
                 * @param {mesos.Offer.Operation.IReserve=} [properties] Properties to set
                 */
                function Reserve(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reserve resources.
                 * @member {Array.<mesos.IResource>}resources
                 * @memberof mesos.Offer.Operation.Reserve
                 * @instance
                 */
                Reserve.prototype.resources = $util.emptyArray;

                /**
                 * Creates a new Reserve instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {mesos.Offer.Operation.IReserve=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.Reserve} Reserve instance
                 */
                Reserve.create = function create(properties) {
                    return new Reserve(properties);
                };

                /**
                 * Encodes the specified Reserve message. Does not implicitly {@link mesos.Offer.Operation.Reserve.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {mesos.Offer.Operation.IReserve} message Reserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reserve.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resources != null && message.resources.length)
                        for (let i = 0; i < message.resources.length; ++i)
                            $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Reserve message, length delimited. Does not implicitly {@link mesos.Offer.Operation.Reserve.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {mesos.Offer.Operation.IReserve} message Reserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reserve.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Reserve message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.Reserve} Reserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reserve.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.Reserve();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.resources && message.resources.length))
                                message.resources = [];
                            message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Reserve message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.Reserve} Reserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reserve.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Reserve message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reserve.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            let error = $root.mesos.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Reserve message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.Reserve} Reserve
                 */
                Reserve.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.Reserve)
                        return object;
                    let message = new $root.mesos.Offer.Operation.Reserve();
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".mesos.Offer.Operation.Reserve.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".mesos.Offer.Operation.Reserve.resources: object expected");
                            message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Reserve message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.Reserve
                 * @static
                 * @param {mesos.Offer.Operation.Reserve} message Reserve
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reserve.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Reserve to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.Reserve
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reserve.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Reserve;
            })();

            Operation.Unreserve = (function() {

                /**
                 * Properties of an Unreserve.
                 * @memberof mesos.Offer.Operation
                 * @interface IUnreserve
                 * @property {Array.<mesos.IResource>} [resources] Unreserve resources
                 */

                /**
                 * Constructs a new Unreserve.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents an Unreserve.
                 * @constructor
                 * @param {mesos.Offer.Operation.IUnreserve=} [properties] Properties to set
                 */
                function Unreserve(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Unreserve resources.
                 * @member {Array.<mesos.IResource>}resources
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @instance
                 */
                Unreserve.prototype.resources = $util.emptyArray;

                /**
                 * Creates a new Unreserve instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {mesos.Offer.Operation.IUnreserve=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.Unreserve} Unreserve instance
                 */
                Unreserve.create = function create(properties) {
                    return new Unreserve(properties);
                };

                /**
                 * Encodes the specified Unreserve message. Does not implicitly {@link mesos.Offer.Operation.Unreserve.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {mesos.Offer.Operation.IUnreserve} message Unreserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unreserve.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resources != null && message.resources.length)
                        for (let i = 0; i < message.resources.length; ++i)
                            $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Unreserve message, length delimited. Does not implicitly {@link mesos.Offer.Operation.Unreserve.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {mesos.Offer.Operation.IUnreserve} message Unreserve message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unreserve.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Unreserve message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.Unreserve} Unreserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unreserve.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.Unreserve();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.resources && message.resources.length))
                                message.resources = [];
                            message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Unreserve message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.Unreserve} Unreserve
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unreserve.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Unreserve message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Unreserve.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            let error = $root.mesos.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Unreserve message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.Unreserve} Unreserve
                 */
                Unreserve.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.Unreserve)
                        return object;
                    let message = new $root.mesos.Offer.Operation.Unreserve();
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".mesos.Offer.Operation.Unreserve.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".mesos.Offer.Operation.Unreserve.resources: object expected");
                            message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Unreserve message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @static
                 * @param {mesos.Offer.Operation.Unreserve} message Unreserve
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unreserve.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Unreserve to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.Unreserve
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Unreserve.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Unreserve;
            })();

            Operation.Create = (function() {

                /**
                 * Properties of a Create.
                 * @memberof mesos.Offer.Operation
                 * @interface ICreate
                 * @property {Array.<mesos.IResource>} [volumes] Create volumes
                 */

                /**
                 * Constructs a new Create.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents a Create.
                 * @constructor
                 * @param {mesos.Offer.Operation.ICreate=} [properties] Properties to set
                 */
                function Create(properties) {
                    this.volumes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Create volumes.
                 * @member {Array.<mesos.IResource>}volumes
                 * @memberof mesos.Offer.Operation.Create
                 * @instance
                 */
                Create.prototype.volumes = $util.emptyArray;

                /**
                 * Creates a new Create instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {mesos.Offer.Operation.ICreate=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.Create} Create instance
                 */
                Create.create = function create(properties) {
                    return new Create(properties);
                };

                /**
                 * Encodes the specified Create message. Does not implicitly {@link mesos.Offer.Operation.Create.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {mesos.Offer.Operation.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.volumes != null && message.volumes.length)
                        for (let i = 0; i < message.volumes.length; ++i)
                            $root.mesos.Resource.encode(message.volumes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Create message, length delimited. Does not implicitly {@link mesos.Offer.Operation.Create.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {mesos.Offer.Operation.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Create message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.Create();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.volumes && message.volumes.length))
                                message.volumes = [];
                            message.volumes.push($root.mesos.Resource.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Create message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Create message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Create.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.volumes != null && message.hasOwnProperty("volumes")) {
                        if (!Array.isArray(message.volumes))
                            return "volumes: array expected";
                        for (let i = 0; i < message.volumes.length; ++i) {
                            let error = $root.mesos.Resource.verify(message.volumes[i]);
                            if (error)
                                return "volumes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Create message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.Create} Create
                 */
                Create.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.Create)
                        return object;
                    let message = new $root.mesos.Offer.Operation.Create();
                    if (object.volumes) {
                        if (!Array.isArray(object.volumes))
                            throw TypeError(".mesos.Offer.Operation.Create.volumes: array expected");
                        message.volumes = [];
                        for (let i = 0; i < object.volumes.length; ++i) {
                            if (typeof object.volumes[i] !== "object")
                                throw TypeError(".mesos.Offer.Operation.Create.volumes: object expected");
                            message.volumes[i] = $root.mesos.Resource.fromObject(object.volumes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Create message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.Create
                 * @static
                 * @param {mesos.Offer.Operation.Create} message Create
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Create.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.volumes = [];
                    if (message.volumes && message.volumes.length) {
                        object.volumes = [];
                        for (let j = 0; j < message.volumes.length; ++j)
                            object.volumes[j] = $root.mesos.Resource.toObject(message.volumes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Create to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.Create
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Create.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Create;
            })();

            Operation.Destroy = (function() {

                /**
                 * Properties of a Destroy.
                 * @memberof mesos.Offer.Operation
                 * @interface IDestroy
                 * @property {Array.<mesos.IResource>} [volumes] Destroy volumes
                 */

                /**
                 * Constructs a new Destroy.
                 * @memberof mesos.Offer.Operation
                 * @classdesc Represents a Destroy.
                 * @constructor
                 * @param {mesos.Offer.Operation.IDestroy=} [properties] Properties to set
                 */
                function Destroy(properties) {
                    this.volumes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Destroy volumes.
                 * @member {Array.<mesos.IResource>}volumes
                 * @memberof mesos.Offer.Operation.Destroy
                 * @instance
                 */
                Destroy.prototype.volumes = $util.emptyArray;

                /**
                 * Creates a new Destroy instance using the specified properties.
                 * @function create
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {mesos.Offer.Operation.IDestroy=} [properties] Properties to set
                 * @returns {mesos.Offer.Operation.Destroy} Destroy instance
                 */
                Destroy.create = function create(properties) {
                    return new Destroy(properties);
                };

                /**
                 * Encodes the specified Destroy message. Does not implicitly {@link mesos.Offer.Operation.Destroy.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {mesos.Offer.Operation.IDestroy} message Destroy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Destroy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.volumes != null && message.volumes.length)
                        for (let i = 0; i < message.volumes.length; ++i)
                            $root.mesos.Resource.encode(message.volumes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Destroy message, length delimited. Does not implicitly {@link mesos.Offer.Operation.Destroy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {mesos.Offer.Operation.IDestroy} message Destroy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Destroy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Destroy message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Offer.Operation.Destroy} Destroy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Destroy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Offer.Operation.Destroy();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.volumes && message.volumes.length))
                                message.volumes = [];
                            message.volumes.push($root.mesos.Resource.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Destroy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Offer.Operation.Destroy} Destroy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Destroy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Destroy message.
                 * @function verify
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Destroy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.volumes != null && message.hasOwnProperty("volumes")) {
                        if (!Array.isArray(message.volumes))
                            return "volumes: array expected";
                        for (let i = 0; i < message.volumes.length; ++i) {
                            let error = $root.mesos.Resource.verify(message.volumes[i]);
                            if (error)
                                return "volumes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Destroy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Offer.Operation.Destroy} Destroy
                 */
                Destroy.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Offer.Operation.Destroy)
                        return object;
                    let message = new $root.mesos.Offer.Operation.Destroy();
                    if (object.volumes) {
                        if (!Array.isArray(object.volumes))
                            throw TypeError(".mesos.Offer.Operation.Destroy.volumes: array expected");
                        message.volumes = [];
                        for (let i = 0; i < object.volumes.length; ++i) {
                            if (typeof object.volumes[i] !== "object")
                                throw TypeError(".mesos.Offer.Operation.Destroy.volumes: object expected");
                            message.volumes[i] = $root.mesos.Resource.fromObject(object.volumes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Destroy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Offer.Operation.Destroy
                 * @static
                 * @param {mesos.Offer.Operation.Destroy} message Destroy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Destroy.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.volumes = [];
                    if (message.volumes && message.volumes.length) {
                        object.volumes = [];
                        for (let j = 0; j < message.volumes.length; ++j)
                            object.volumes[j] = $root.mesos.Resource.toObject(message.volumes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Destroy to JSON.
                 * @function toJSON
                 * @memberof mesos.Offer.Operation.Destroy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Destroy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Destroy;
            })();

            return Operation;
        })();

        return Offer;
    })();

    mesos.InverseOffer = (function() {

        /**
         * Properties of an InverseOffer.
         * @memberof mesos
         * @interface IInverseOffer
         * @property {mesos.IOfferID} id InverseOffer id
         * @property {mesos.IURL} [url] InverseOffer url
         * @property {mesos.IFrameworkID} frameworkId InverseOffer frameworkId
         * @property {mesos.IAgentID} [agentId] InverseOffer agentId
         * @property {mesos.IUnavailability} unavailability InverseOffer unavailability
         * @property {Array.<mesos.IResource>} [resources] InverseOffer resources
         */

        /**
         * Constructs a new InverseOffer.
         * @memberof mesos
         * @classdesc A request to return some resources occupied by a framework.
         * @constructor
         * @param {mesos.IInverseOffer=} [properties] Properties to set
         */
        function InverseOffer(properties) {
            this.resources = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InverseOffer id.
         * @member {mesos.IOfferID}id
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.id = null;

        /**
         * InverseOffer url.
         * @member {(mesos.IURL|null|undefined)}url
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.url = null;

        /**
         * InverseOffer frameworkId.
         * @member {mesos.IFrameworkID}frameworkId
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.frameworkId = null;

        /**
         * InverseOffer agentId.
         * @member {(mesos.IAgentID|null|undefined)}agentId
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.agentId = null;

        /**
         * InverseOffer unavailability.
         * @member {mesos.IUnavailability}unavailability
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.unavailability = null;

        /**
         * InverseOffer resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.InverseOffer
         * @instance
         */
        InverseOffer.prototype.resources = $util.emptyArray;

        /**
         * Creates a new InverseOffer instance using the specified properties.
         * @function create
         * @memberof mesos.InverseOffer
         * @static
         * @param {mesos.IInverseOffer=} [properties] Properties to set
         * @returns {mesos.InverseOffer} InverseOffer instance
         */
        InverseOffer.create = function create(properties) {
            return new InverseOffer(properties);
        };

        /**
         * Encodes the specified InverseOffer message. Does not implicitly {@link mesos.InverseOffer.verify|verify} messages.
         * @function encode
         * @memberof mesos.InverseOffer
         * @static
         * @param {mesos.IInverseOffer} message InverseOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InverseOffer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.OfferID.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.url != null && message.hasOwnProperty("url"))
                $root.mesos.URL.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            $root.mesos.Unavailability.encode(message.unavailability, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InverseOffer message, length delimited. Does not implicitly {@link mesos.InverseOffer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.InverseOffer
         * @static
         * @param {mesos.IInverseOffer} message InverseOffer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InverseOffer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InverseOffer message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.InverseOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.InverseOffer} InverseOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InverseOffer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.InverseOffer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = $root.mesos.OfferID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.url = $root.mesos.URL.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.unavailability = $root.mesos.Unavailability.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("frameworkId"))
                throw $util.ProtocolError("missing required 'frameworkId'", { instance: message });
            if (!message.hasOwnProperty("unavailability"))
                throw $util.ProtocolError("missing required 'unavailability'", { instance: message });
            return message;
        };

        /**
         * Decodes an InverseOffer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.InverseOffer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.InverseOffer} InverseOffer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InverseOffer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InverseOffer message.
         * @function verify
         * @memberof mesos.InverseOffer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InverseOffer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let error = $root.mesos.OfferID.verify(message.id);
            if (error)
                return "id." + error;
            if (message.url != null && message.hasOwnProperty("url")) {
                error = $root.mesos.URL.verify(message.url);
                if (error)
                    return "url." + error;
            }
            error = $root.mesos.FrameworkID.verify(message.frameworkId);
            if (error)
                return "frameworkId." + error;
            if (message.agentId != null && message.hasOwnProperty("agentId")) {
                error = $root.mesos.AgentID.verify(message.agentId);
                if (error)
                    return "agentId." + error;
            }
            error = $root.mesos.Unavailability.verify(message.unavailability);
            if (error)
                return "unavailability." + error;
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InverseOffer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.InverseOffer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.InverseOffer} InverseOffer
         */
        InverseOffer.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.InverseOffer)
                return object;
            let message = new $root.mesos.InverseOffer();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".mesos.InverseOffer.id: object expected");
                message.id = $root.mesos.OfferID.fromObject(object.id);
            }
            if (object.url != null) {
                if (typeof object.url !== "object")
                    throw TypeError(".mesos.InverseOffer.url: object expected");
                message.url = $root.mesos.URL.fromObject(object.url);
            }
            if (object.frameworkId != null) {
                if (typeof object.frameworkId !== "object")
                    throw TypeError(".mesos.InverseOffer.frameworkId: object expected");
                message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
            }
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.InverseOffer.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            if (object.unavailability != null) {
                if (typeof object.unavailability !== "object")
                    throw TypeError(".mesos.InverseOffer.unavailability: object expected");
                message.unavailability = $root.mesos.Unavailability.fromObject(object.unavailability);
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.InverseOffer.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.InverseOffer.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InverseOffer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.InverseOffer
         * @static
         * @param {mesos.InverseOffer} message InverseOffer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InverseOffer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (options.defaults) {
                object.id = null;
                object.url = null;
                object.frameworkId = null;
                object.agentId = null;
                object.unavailability = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.mesos.OfferID.toObject(message.id, options);
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = $root.mesos.URL.toObject(message.url, options);
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.unavailability != null && message.hasOwnProperty("unavailability"))
                object.unavailability = $root.mesos.Unavailability.toObject(message.unavailability, options);
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this InverseOffer to JSON.
         * @function toJSON
         * @memberof mesos.InverseOffer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InverseOffer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InverseOffer;
    })();

    mesos.TaskInfo = (function() {

        /**
         * Properties of a TaskInfo.
         * @memberof mesos
         * @interface ITaskInfo
         * @property {string} name TaskInfo name
         * @property {mesos.ITaskID} taskId TaskInfo taskId
         * @property {mesos.IAgentID} agentId TaskInfo agentId
         * @property {Array.<mesos.IResource>} [resources] TaskInfo resources
         * @property {mesos.IExecutorInfo} [executor] TaskInfo executor
         * @property {mesos.ICommandInfo} [command] TaskInfo command
         * @property {mesos.IContainerInfo} [container] TaskInfo container
         * @property {mesos.IHealthCheck} [healthCheck] TaskInfo healthCheck
         * @property {mesos.ICheckInfo} [check] TaskInfo check
         * @property {mesos.IKillPolicy} [killPolicy] TaskInfo killPolicy
         * @property {Uint8Array} [data] TaskInfo data
         * @property {mesos.ILabels} [labels] TaskInfo labels
         * @property {mesos.IDiscoveryInfo} [discovery] TaskInfo discovery
         */

        /**
         * Constructs a new TaskInfo.
         * @memberof mesos
         * @classdesc Describes a task. Passed from the scheduler all the way to an
         * executor (see SchedulerDriver::launchTasks and
         * Executor::launchTask). Either ExecutorInfo or CommandInfo should be set.
         * A different executor can be used to launch this task, and subsequent tasks
         * meant for the same executor can reuse the same ExecutorInfo struct.
         * @constructor
         * @param {mesos.ITaskInfo=} [properties] Properties to set
         */
        function TaskInfo(properties) {
            this.resources = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskInfo name.
         * @member {string}name
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.name = "";

        /**
         * TaskInfo taskId.
         * @member {mesos.ITaskID}taskId
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.taskId = null;

        /**
         * TaskInfo agentId.
         * @member {mesos.IAgentID}agentId
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.agentId = null;

        /**
         * TaskInfo resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.resources = $util.emptyArray;

        /**
         * TaskInfo executor.
         * @member {(mesos.IExecutorInfo|null|undefined)}executor
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.executor = null;

        /**
         * TaskInfo command.
         * @member {(mesos.ICommandInfo|null|undefined)}command
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.command = null;

        /**
         * TaskInfo container.
         * @member {(mesos.IContainerInfo|null|undefined)}container
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.container = null;

        /**
         * TaskInfo healthCheck.
         * @member {(mesos.IHealthCheck|null|undefined)}healthCheck
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.healthCheck = null;

        /**
         * TaskInfo check.
         * @member {(mesos.ICheckInfo|null|undefined)}check
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.check = null;

        /**
         * TaskInfo killPolicy.
         * @member {(mesos.IKillPolicy|null|undefined)}killPolicy
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.killPolicy = null;

        /**
         * TaskInfo data.
         * @member {Uint8Array}data
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.data = $util.newBuffer([]);

        /**
         * TaskInfo labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.labels = null;

        /**
         * TaskInfo discovery.
         * @member {(mesos.IDiscoveryInfo|null|undefined)}discovery
         * @memberof mesos.TaskInfo
         * @instance
         */
        TaskInfo.prototype.discovery = null;

        /**
         * Creates a new TaskInfo instance using the specified properties.
         * @function create
         * @memberof mesos.TaskInfo
         * @static
         * @param {mesos.ITaskInfo=} [properties] Properties to set
         * @returns {mesos.TaskInfo} TaskInfo instance
         */
        TaskInfo.create = function create(properties) {
            return new TaskInfo(properties);
        };

        /**
         * Encodes the specified TaskInfo message. Does not implicitly {@link mesos.TaskInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.TaskInfo
         * @static
         * @param {mesos.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.executor != null && message.hasOwnProperty("executor"))
                $root.mesos.ExecutorInfo.encode(message.executor, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.data);
            if (message.command != null && message.hasOwnProperty("command"))
                $root.mesos.CommandInfo.encode(message.command, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.healthCheck != null && message.hasOwnProperty("healthCheck"))
                $root.mesos.HealthCheck.encode(message.healthCheck, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.container != null && message.hasOwnProperty("container"))
                $root.mesos.ContainerInfo.encode(message.container, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                $root.mesos.DiscoveryInfo.encode(message.discovery, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                $root.mesos.KillPolicy.encode(message.killPolicy, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.check != null && message.hasOwnProperty("check"))
                $root.mesos.CheckInfo.encode(message.check, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskInfo message, length delimited. Does not implicitly {@link mesos.TaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TaskInfo
         * @static
         * @param {mesos.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TaskInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.executor = $root.mesos.ExecutorInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.command = $root.mesos.CommandInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.container = $root.mesos.ContainerInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.healthCheck = $root.mesos.HealthCheck.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.check = $root.mesos.CheckInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.killPolicy = $root.mesos.KillPolicy.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.data = reader.bytes();
                    break;
                case 10:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.discovery = $root.mesos.DiscoveryInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("taskId"))
                throw $util.ProtocolError("missing required 'taskId'", { instance: message });
            if (!message.hasOwnProperty("agentId"))
                throw $util.ProtocolError("missing required 'agentId'", { instance: message });
            return message;
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskInfo message.
         * @function verify
         * @memberof mesos.TaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            let error = $root.mesos.TaskID.verify(message.taskId);
            if (error)
                return "taskId." + error;
            error = $root.mesos.AgentID.verify(message.agentId);
            if (error)
                return "agentId." + error;
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.executor != null && message.hasOwnProperty("executor")) {
                error = $root.mesos.ExecutorInfo.verify(message.executor);
                if (error)
                    return "executor." + error;
            }
            if (message.command != null && message.hasOwnProperty("command")) {
                error = $root.mesos.CommandInfo.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.container != null && message.hasOwnProperty("container")) {
                error = $root.mesos.ContainerInfo.verify(message.container);
                if (error)
                    return "container." + error;
            }
            if (message.healthCheck != null && message.hasOwnProperty("healthCheck")) {
                error = $root.mesos.HealthCheck.verify(message.healthCheck);
                if (error)
                    return "healthCheck." + error;
            }
            if (message.check != null && message.hasOwnProperty("check")) {
                error = $root.mesos.CheckInfo.verify(message.check);
                if (error)
                    return "check." + error;
            }
            if (message.killPolicy != null && message.hasOwnProperty("killPolicy")) {
                error = $root.mesos.KillPolicy.verify(message.killPolicy);
                if (error)
                    return "killPolicy." + error;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            if (message.discovery != null && message.hasOwnProperty("discovery")) {
                error = $root.mesos.DiscoveryInfo.verify(message.discovery);
                if (error)
                    return "discovery." + error;
            }
            return null;
        };

        /**
         * Creates a TaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TaskInfo} TaskInfo
         */
        TaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TaskInfo)
                return object;
            let message = new $root.mesos.TaskInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.taskId != null) {
                if (typeof object.taskId !== "object")
                    throw TypeError(".mesos.TaskInfo.taskId: object expected");
                message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
            }
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.TaskInfo.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.TaskInfo.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.TaskInfo.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            if (object.executor != null) {
                if (typeof object.executor !== "object")
                    throw TypeError(".mesos.TaskInfo.executor: object expected");
                message.executor = $root.mesos.ExecutorInfo.fromObject(object.executor);
            }
            if (object.command != null) {
                if (typeof object.command !== "object")
                    throw TypeError(".mesos.TaskInfo.command: object expected");
                message.command = $root.mesos.CommandInfo.fromObject(object.command);
            }
            if (object.container != null) {
                if (typeof object.container !== "object")
                    throw TypeError(".mesos.TaskInfo.container: object expected");
                message.container = $root.mesos.ContainerInfo.fromObject(object.container);
            }
            if (object.healthCheck != null) {
                if (typeof object.healthCheck !== "object")
                    throw TypeError(".mesos.TaskInfo.healthCheck: object expected");
                message.healthCheck = $root.mesos.HealthCheck.fromObject(object.healthCheck);
            }
            if (object.check != null) {
                if (typeof object.check !== "object")
                    throw TypeError(".mesos.TaskInfo.check: object expected");
                message.check = $root.mesos.CheckInfo.fromObject(object.check);
            }
            if (object.killPolicy != null) {
                if (typeof object.killPolicy !== "object")
                    throw TypeError(".mesos.TaskInfo.killPolicy: object expected");
                message.killPolicy = $root.mesos.KillPolicy.fromObject(object.killPolicy);
            }
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.TaskInfo.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            if (object.discovery != null) {
                if (typeof object.discovery !== "object")
                    throw TypeError(".mesos.TaskInfo.discovery: object expected");
                message.discovery = $root.mesos.DiscoveryInfo.fromObject(object.discovery);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TaskInfo
         * @static
         * @param {mesos.TaskInfo} message TaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resources = [];
            if (options.defaults) {
                object.name = "";
                object.taskId = null;
                object.agentId = null;
                object.executor = null;
                object.data = options.bytes === String ? "" : [];
                object.command = null;
                object.healthCheck = null;
                object.container = null;
                object.labels = null;
                object.discovery = null;
                object.killPolicy = null;
                object.check = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            if (message.executor != null && message.hasOwnProperty("executor"))
                object.executor = $root.mesos.ExecutorInfo.toObject(message.executor, options);
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = $root.mesos.CommandInfo.toObject(message.command, options);
            if (message.healthCheck != null && message.hasOwnProperty("healthCheck"))
                object.healthCheck = $root.mesos.HealthCheck.toObject(message.healthCheck, options);
            if (message.container != null && message.hasOwnProperty("container"))
                object.container = $root.mesos.ContainerInfo.toObject(message.container, options);
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                object.discovery = $root.mesos.DiscoveryInfo.toObject(message.discovery, options);
            if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                object.killPolicy = $root.mesos.KillPolicy.toObject(message.killPolicy, options);
            if (message.check != null && message.hasOwnProperty("check"))
                object.check = $root.mesos.CheckInfo.toObject(message.check, options);
            return object;
        };

        /**
         * Converts this TaskInfo to JSON.
         * @function toJSON
         * @memberof mesos.TaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskInfo;
    })();

    mesos.TaskGroupInfo = (function() {

        /**
         * Properties of a TaskGroupInfo.
         * @memberof mesos
         * @interface ITaskGroupInfo
         * @property {Array.<mesos.ITaskInfo>} [tasks] TaskGroupInfo tasks
         */

        /**
         * Constructs a new TaskGroupInfo.
         * @memberof mesos
         * @classdesc Describes a group of tasks that belong to an executor. The
         * executor will receive the task group in a single message to
         * allow the group to be launched "atomically".
         * 
         * NOTES:
         * 1) `NetworkInfo` must not be set inside task's `ContainerInfo`.
         * 2) `TaskInfo.executor` doesn't need to set. If set, it should match
         * `LaunchGroup.executor`.
         * @constructor
         * @param {mesos.ITaskGroupInfo=} [properties] Properties to set
         */
        function TaskGroupInfo(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskGroupInfo tasks.
         * @member {Array.<mesos.ITaskInfo>}tasks
         * @memberof mesos.TaskGroupInfo
         * @instance
         */
        TaskGroupInfo.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new TaskGroupInfo instance using the specified properties.
         * @function create
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {mesos.ITaskGroupInfo=} [properties] Properties to set
         * @returns {mesos.TaskGroupInfo} TaskGroupInfo instance
         */
        TaskGroupInfo.create = function create(properties) {
            return new TaskGroupInfo(properties);
        };

        /**
         * Encodes the specified TaskGroupInfo message. Does not implicitly {@link mesos.TaskGroupInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {mesos.ITaskGroupInfo} message TaskGroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGroupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.mesos.TaskInfo.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskGroupInfo message, length delimited. Does not implicitly {@link mesos.TaskGroupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {mesos.ITaskGroupInfo} message TaskGroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskGroupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TaskGroupInfo} TaskGroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGroupInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TaskGroupInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.mesos.TaskInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskGroupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TaskGroupInfo} TaskGroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskGroupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskGroupInfo message.
         * @function verify
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskGroupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.mesos.TaskInfo.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TaskGroupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TaskGroupInfo} TaskGroupInfo
         */
        TaskGroupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TaskGroupInfo)
                return object;
            let message = new $root.mesos.TaskGroupInfo();
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".mesos.TaskGroupInfo.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".mesos.TaskGroupInfo.tasks: object expected");
                    message.tasks[i] = $root.mesos.TaskInfo.fromObject(object.tasks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskGroupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TaskGroupInfo
         * @static
         * @param {mesos.TaskGroupInfo} message TaskGroupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskGroupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.mesos.TaskInfo.toObject(message.tasks[j], options);
            }
            return object;
        };

        /**
         * Converts this TaskGroupInfo to JSON.
         * @function toJSON
         * @memberof mesos.TaskGroupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskGroupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskGroupInfo;
    })();

    mesos.Task = (function() {

        /**
         * Properties of a Task.
         * @memberof mesos
         * @interface ITask
         * @property {string} name Task name
         * @property {mesos.ITaskID} taskId Task taskId
         * @property {mesos.IFrameworkID} frameworkId Task frameworkId
         * @property {mesos.IExecutorID} [executorId] Task executorId
         * @property {mesos.IAgentID} agentId Task agentId
         * @property {mesos.TaskState} state Task state
         * @property {Array.<mesos.IResource>} [resources] Task resources
         * @property {Array.<mesos.ITaskStatus>} [statuses] Task statuses
         * @property {mesos.TaskState} [statusUpdateState] Task statusUpdateState
         * @property {Uint8Array} [statusUpdateUuid] Task statusUpdateUuid
         * @property {mesos.ILabels} [labels] Task labels
         * @property {mesos.IDiscoveryInfo} [discovery] Task discovery
         * @property {mesos.IContainerInfo} [container] Task container
         * @property {string} [user] Task user
         */

        /**
         * Constructs a new Task.
         * @memberof mesos
         * @classdesc Describes a task, similar to `TaskInfo`.
         * 
         * `Task` is used in some of the Mesos messages found below.
         * `Task` is used instead of `TaskInfo` if:
         * 1) we need additional IDs, such as a specific
         * framework, executor, or agent; or
         * 2) we do not need the additional data, such as the command run by the
         * task or the health checks.  These additional fields may be large and
         * unnecessary for some Mesos messages.
         * 
         * `Task` is generally constructed from a `TaskInfo`.  See protobuf::createTask.
         * @constructor
         * @param {mesos.ITask=} [properties] Properties to set
         */
        function Task(properties) {
            this.resources = [];
            this.statuses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Task name.
         * @member {string}name
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.name = "";

        /**
         * Task taskId.
         * @member {mesos.ITaskID}taskId
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.taskId = null;

        /**
         * Task frameworkId.
         * @member {mesos.IFrameworkID}frameworkId
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.frameworkId = null;

        /**
         * Task executorId.
         * @member {(mesos.IExecutorID|null|undefined)}executorId
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.executorId = null;

        /**
         * Task agentId.
         * @member {mesos.IAgentID}agentId
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.agentId = null;

        /**
         * Task state.
         * @member {mesos.TaskState}state
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.state = 6;

        /**
         * Task resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.resources = $util.emptyArray;

        /**
         * Task statuses.
         * @member {Array.<mesos.ITaskStatus>}statuses
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.statuses = $util.emptyArray;

        /**
         * Task statusUpdateState.
         * @member {mesos.TaskState}statusUpdateState
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.statusUpdateState = 6;

        /**
         * Task statusUpdateUuid.
         * @member {Uint8Array}statusUpdateUuid
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.statusUpdateUuid = $util.newBuffer([]);

        /**
         * Task labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.labels = null;

        /**
         * Task discovery.
         * @member {(mesos.IDiscoveryInfo|null|undefined)}discovery
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.discovery = null;

        /**
         * Task container.
         * @member {(mesos.IContainerInfo|null|undefined)}container
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.container = null;

        /**
         * Task user.
         * @member {string}user
         * @memberof mesos.Task
         * @instance
         */
        Task.prototype.user = "";

        /**
         * Creates a new Task instance using the specified properties.
         * @function create
         * @memberof mesos.Task
         * @static
         * @param {mesos.ITask=} [properties] Properties to set
         * @returns {mesos.Task} Task instance
         */
        Task.create = function create(properties) {
            return new Task(properties);
        };

        /**
         * Encodes the specified Task message. Does not implicitly {@link mesos.Task.verify|verify} messages.
         * @function encode
         * @memberof mesos.Task
         * @static
         * @param {mesos.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.executorId != null && message.hasOwnProperty("executorId"))
                $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.statuses != null && message.statuses.length)
                for (let i = 0; i < message.statuses.length; ++i)
                    $root.mesos.TaskStatus.encode(message.statuses[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.statusUpdateState != null && message.hasOwnProperty("statusUpdateState"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.statusUpdateState);
            if (message.statusUpdateUuid != null && message.hasOwnProperty("statusUpdateUuid"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.statusUpdateUuid);
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                $root.mesos.DiscoveryInfo.encode(message.discovery, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.container != null && message.hasOwnProperty("container"))
                $root.mesos.ContainerInfo.encode(message.container, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.user);
            return writer;
        };

        /**
         * Encodes the specified Task message, length delimited. Does not implicitly {@link mesos.Task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Task
         * @static
         * @param {mesos.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Task message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Task();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.state = reader.int32();
                    break;
                case 7:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.statuses && message.statuses.length))
                        message.statuses = [];
                    message.statuses.push($root.mesos.TaskStatus.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.statusUpdateState = reader.int32();
                    break;
                case 10:
                    message.statusUpdateUuid = reader.bytes();
                    break;
                case 11:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.discovery = $root.mesos.DiscoveryInfo.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.container = $root.mesos.ContainerInfo.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("taskId"))
                throw $util.ProtocolError("missing required 'taskId'", { instance: message });
            if (!message.hasOwnProperty("frameworkId"))
                throw $util.ProtocolError("missing required 'frameworkId'", { instance: message });
            if (!message.hasOwnProperty("agentId"))
                throw $util.ProtocolError("missing required 'agentId'", { instance: message });
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a Task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Task message.
         * @function verify
         * @memberof mesos.Task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            let error = $root.mesos.TaskID.verify(message.taskId);
            if (error)
                return "taskId." + error;
            error = $root.mesos.FrameworkID.verify(message.frameworkId);
            if (error)
                return "frameworkId." + error;
            if (message.executorId != null && message.hasOwnProperty("executorId")) {
                error = $root.mesos.ExecutorID.verify(message.executorId);
                if (error)
                    return "executorId." + error;
            }
            error = $root.mesos.AgentID.verify(message.agentId);
            if (error)
                return "agentId." + error;
            switch (message.state) {
            default:
                return "state: enum value expected";
            case 6:
            case 0:
            case 1:
            case 8:
            case 2:
            case 3:
            case 4:
            case 7:
            case 5:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            if (message.statuses != null && message.hasOwnProperty("statuses")) {
                if (!Array.isArray(message.statuses))
                    return "statuses: array expected";
                for (let i = 0; i < message.statuses.length; ++i) {
                    error = $root.mesos.TaskStatus.verify(message.statuses[i]);
                    if (error)
                        return "statuses." + error;
                }
            }
            if (message.statusUpdateState != null && message.hasOwnProperty("statusUpdateState"))
                switch (message.statusUpdateState) {
                default:
                    return "statusUpdateState: enum value expected";
                case 6:
                case 0:
                case 1:
                case 8:
                case 2:
                case 3:
                case 4:
                case 7:
                case 5:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    break;
                }
            if (message.statusUpdateUuid != null && message.hasOwnProperty("statusUpdateUuid"))
                if (!(message.statusUpdateUuid && typeof message.statusUpdateUuid.length === "number" || $util.isString(message.statusUpdateUuid)))
                    return "statusUpdateUuid: buffer expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            if (message.discovery != null && message.hasOwnProperty("discovery")) {
                error = $root.mesos.DiscoveryInfo.verify(message.discovery);
                if (error)
                    return "discovery." + error;
            }
            if (message.container != null && message.hasOwnProperty("container")) {
                error = $root.mesos.ContainerInfo.verify(message.container);
                if (error)
                    return "container." + error;
            }
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            return null;
        };

        /**
         * Creates a Task message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Task
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Task} Task
         */
        Task.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Task)
                return object;
            let message = new $root.mesos.Task();
            if (object.name != null)
                message.name = String(object.name);
            if (object.taskId != null) {
                if (typeof object.taskId !== "object")
                    throw TypeError(".mesos.Task.taskId: object expected");
                message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
            }
            if (object.frameworkId != null) {
                if (typeof object.frameworkId !== "object")
                    throw TypeError(".mesos.Task.frameworkId: object expected");
                message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
            }
            if (object.executorId != null) {
                if (typeof object.executorId !== "object")
                    throw TypeError(".mesos.Task.executorId: object expected");
                message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
            }
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.Task.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            switch (object.state) {
            case "TASK_STAGING":
            case 6:
                message.state = 6;
                break;
            case "TASK_STARTING":
            case 0:
                message.state = 0;
                break;
            case "TASK_RUNNING":
            case 1:
                message.state = 1;
                break;
            case "TASK_KILLING":
            case 8:
                message.state = 8;
                break;
            case "TASK_FINISHED":
            case 2:
                message.state = 2;
                break;
            case "TASK_FAILED":
            case 3:
                message.state = 3;
                break;
            case "TASK_KILLED":
            case 4:
                message.state = 4;
                break;
            case "TASK_ERROR":
            case 7:
                message.state = 7;
                break;
            case "TASK_LOST":
            case 5:
                message.state = 5;
                break;
            case "TASK_DROPPED":
            case 9:
                message.state = 9;
                break;
            case "TASK_UNREACHABLE":
            case 10:
                message.state = 10;
                break;
            case "TASK_GONE":
            case 11:
                message.state = 11;
                break;
            case "TASK_GONE_BY_OPERATOR":
            case 12:
                message.state = 12;
                break;
            case "TASK_UNKNOWN":
            case 13:
                message.state = 13;
                break;
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.Task.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.Task.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            if (object.statuses) {
                if (!Array.isArray(object.statuses))
                    throw TypeError(".mesos.Task.statuses: array expected");
                message.statuses = [];
                for (let i = 0; i < object.statuses.length; ++i) {
                    if (typeof object.statuses[i] !== "object")
                        throw TypeError(".mesos.Task.statuses: object expected");
                    message.statuses[i] = $root.mesos.TaskStatus.fromObject(object.statuses[i]);
                }
            }
            switch (object.statusUpdateState) {
            case "TASK_STAGING":
            case 6:
                message.statusUpdateState = 6;
                break;
            case "TASK_STARTING":
            case 0:
                message.statusUpdateState = 0;
                break;
            case "TASK_RUNNING":
            case 1:
                message.statusUpdateState = 1;
                break;
            case "TASK_KILLING":
            case 8:
                message.statusUpdateState = 8;
                break;
            case "TASK_FINISHED":
            case 2:
                message.statusUpdateState = 2;
                break;
            case "TASK_FAILED":
            case 3:
                message.statusUpdateState = 3;
                break;
            case "TASK_KILLED":
            case 4:
                message.statusUpdateState = 4;
                break;
            case "TASK_ERROR":
            case 7:
                message.statusUpdateState = 7;
                break;
            case "TASK_LOST":
            case 5:
                message.statusUpdateState = 5;
                break;
            case "TASK_DROPPED":
            case 9:
                message.statusUpdateState = 9;
                break;
            case "TASK_UNREACHABLE":
            case 10:
                message.statusUpdateState = 10;
                break;
            case "TASK_GONE":
            case 11:
                message.statusUpdateState = 11;
                break;
            case "TASK_GONE_BY_OPERATOR":
            case 12:
                message.statusUpdateState = 12;
                break;
            case "TASK_UNKNOWN":
            case 13:
                message.statusUpdateState = 13;
                break;
            }
            if (object.statusUpdateUuid != null)
                if (typeof object.statusUpdateUuid === "string")
                    $util.base64.decode(object.statusUpdateUuid, message.statusUpdateUuid = $util.newBuffer($util.base64.length(object.statusUpdateUuid)), 0);
                else if (object.statusUpdateUuid.length)
                    message.statusUpdateUuid = object.statusUpdateUuid;
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.Task.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            if (object.discovery != null) {
                if (typeof object.discovery !== "object")
                    throw TypeError(".mesos.Task.discovery: object expected");
                message.discovery = $root.mesos.DiscoveryInfo.fromObject(object.discovery);
            }
            if (object.container != null) {
                if (typeof object.container !== "object")
                    throw TypeError(".mesos.Task.container: object expected");
                message.container = $root.mesos.ContainerInfo.fromObject(object.container);
            }
            if (object.user != null)
                message.user = String(object.user);
            return message;
        };

        /**
         * Creates a plain object from a Task message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Task
         * @static
         * @param {mesos.Task} message Task
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Task.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.resources = [];
                object.statuses = [];
            }
            if (options.defaults) {
                object.name = "";
                object.taskId = null;
                object.frameworkId = null;
                object.executorId = null;
                object.agentId = null;
                object.state = options.enums === String ? "TASK_STAGING" : 6;
                object.statusUpdateState = options.enums === String ? "TASK_STAGING" : 6;
                object.statusUpdateUuid = options.bytes === String ? "" : [];
                object.labels = null;
                object.discovery = null;
                object.container = null;
                object.user = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
            if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
            if (message.executorId != null && message.hasOwnProperty("executorId"))
                object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.mesos.TaskState[message.state] : message.state;
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            if (message.statuses && message.statuses.length) {
                object.statuses = [];
                for (let j = 0; j < message.statuses.length; ++j)
                    object.statuses[j] = $root.mesos.TaskStatus.toObject(message.statuses[j], options);
            }
            if (message.statusUpdateState != null && message.hasOwnProperty("statusUpdateState"))
                object.statusUpdateState = options.enums === String ? $root.mesos.TaskState[message.statusUpdateState] : message.statusUpdateState;
            if (message.statusUpdateUuid != null && message.hasOwnProperty("statusUpdateUuid"))
                object.statusUpdateUuid = options.bytes === String ? $util.base64.encode(message.statusUpdateUuid, 0, message.statusUpdateUuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.statusUpdateUuid) : message.statusUpdateUuid;
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.discovery != null && message.hasOwnProperty("discovery"))
                object.discovery = $root.mesos.DiscoveryInfo.toObject(message.discovery, options);
            if (message.container != null && message.hasOwnProperty("container"))
                object.container = $root.mesos.ContainerInfo.toObject(message.container, options);
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            return object;
        };

        /**
         * Converts this Task to JSON.
         * @function toJSON
         * @memberof mesos.Task
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Task.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Task;
    })();

    /**
     * Describes possible task states. IMPORTANT: Mesos assumes tasks that
     * enter terminal states (see below) imply the task is no longer
     * running and thus clean up any thing associated with the task
     * (ultimately offering any resources being consumed by that task to
     * another task).
     * @enum {string}
     * @property {number} TASK_STAGING=6 TASK_STAGING value
     * @property {number} TASK_STARTING=0 TASK_STARTING value
     * @property {number} TASK_RUNNING=1 TASK_RUNNING value
     * @property {number} TASK_KILLING=8 TASK_KILLING value
     * @property {number} TASK_FINISHED=2 TASK_FINISHED value
     * @property {number} TASK_FAILED=3 TASK_FAILED value
     * @property {number} TASK_KILLED=4 TASK_KILLED value
     * @property {number} TASK_ERROR=7 TASK_ERROR value
     * @property {number} TASK_LOST=5 TASK_LOST value
     * @property {number} TASK_DROPPED=9 TASK_DROPPED value
     * @property {number} TASK_UNREACHABLE=10 TASK_UNREACHABLE value
     * @property {number} TASK_GONE=11 TASK_GONE value
     * @property {number} TASK_GONE_BY_OPERATOR=12 TASK_GONE_BY_OPERATOR value
     * @property {number} TASK_UNKNOWN=13 TASK_UNKNOWN value
     */
    mesos.TaskState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[6] = "TASK_STAGING"] = 6;
        values[valuesById[0] = "TASK_STARTING"] = 0;
        values[valuesById[1] = "TASK_RUNNING"] = 1;
        values[valuesById[8] = "TASK_KILLING"] = 8;
        values[valuesById[2] = "TASK_FINISHED"] = 2;
        values[valuesById[3] = "TASK_FAILED"] = 3;
        values[valuesById[4] = "TASK_KILLED"] = 4;
        values[valuesById[7] = "TASK_ERROR"] = 7;
        values[valuesById[5] = "TASK_LOST"] = 5;
        values[valuesById[9] = "TASK_DROPPED"] = 9;
        values[valuesById[10] = "TASK_UNREACHABLE"] = 10;
        values[valuesById[11] = "TASK_GONE"] = 11;
        values[valuesById[12] = "TASK_GONE_BY_OPERATOR"] = 12;
        values[valuesById[13] = "TASK_UNKNOWN"] = 13;
        return values;
    })();

    mesos.CheckStatusInfo = (function() {

        /**
         * Properties of a CheckStatusInfo.
         * @memberof mesos
         * @interface ICheckStatusInfo
         * @property {mesos.CheckInfo.Type} [type] CheckStatusInfo type
         * @property {mesos.CheckStatusInfo.ICommand} [command] CheckStatusInfo command
         * @property {mesos.CheckStatusInfo.IHttp} [http] CheckStatusInfo http
         */

        /**
         * Constructs a new CheckStatusInfo.
         * @memberof mesos
         * @classdesc Describes the status of a check. Type and the corresponding field, i.e.,
         * `command` or `http` must be set. If the result of the check is not available
         * (e.g., the check timed out), these fields must contain empty messages, i.e.,
         * `exit_code` or `status_code` will be unset.
         * 
         * NOTE: This API is unstable and the related feature is experimental.
         * @constructor
         * @param {mesos.ICheckStatusInfo=} [properties] Properties to set
         */
        function CheckStatusInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckStatusInfo type.
         * @member {mesos.CheckInfo.Type}type
         * @memberof mesos.CheckStatusInfo
         * @instance
         */
        CheckStatusInfo.prototype.type = 0;

        /**
         * CheckStatusInfo command.
         * @member {(mesos.CheckStatusInfo.ICommand|null|undefined)}command
         * @memberof mesos.CheckStatusInfo
         * @instance
         */
        CheckStatusInfo.prototype.command = null;

        /**
         * CheckStatusInfo http.
         * @member {(mesos.CheckStatusInfo.IHttp|null|undefined)}http
         * @memberof mesos.CheckStatusInfo
         * @instance
         */
        CheckStatusInfo.prototype.http = null;

        /**
         * Creates a new CheckStatusInfo instance using the specified properties.
         * @function create
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {mesos.ICheckStatusInfo=} [properties] Properties to set
         * @returns {mesos.CheckStatusInfo} CheckStatusInfo instance
         */
        CheckStatusInfo.create = function create(properties) {
            return new CheckStatusInfo(properties);
        };

        /**
         * Encodes the specified CheckStatusInfo message. Does not implicitly {@link mesos.CheckStatusInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {mesos.ICheckStatusInfo} message CheckStatusInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckStatusInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.command != null && message.hasOwnProperty("command"))
                $root.mesos.CheckStatusInfo.Command.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.http != null && message.hasOwnProperty("http"))
                $root.mesos.CheckStatusInfo.Http.encode(message.http, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CheckStatusInfo message, length delimited. Does not implicitly {@link mesos.CheckStatusInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {mesos.ICheckStatusInfo} message CheckStatusInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckStatusInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckStatusInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.CheckStatusInfo} CheckStatusInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckStatusInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckStatusInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.command = $root.mesos.CheckStatusInfo.Command.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.http = $root.mesos.CheckStatusInfo.Http.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckStatusInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.CheckStatusInfo} CheckStatusInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckStatusInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckStatusInfo message.
         * @function verify
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckStatusInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.command != null && message.hasOwnProperty("command")) {
                let error = $root.mesos.CheckStatusInfo.Command.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.http != null && message.hasOwnProperty("http")) {
                error = $root.mesos.CheckStatusInfo.Http.verify(message.http);
                if (error)
                    return "http." + error;
            }
            return null;
        };

        /**
         * Creates a CheckStatusInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.CheckStatusInfo} CheckStatusInfo
         */
        CheckStatusInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.CheckStatusInfo)
                return object;
            let message = new $root.mesos.CheckStatusInfo();
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "COMMAND":
            case 1:
                message.type = 1;
                break;
            case "HTTP":
            case 2:
                message.type = 2;
                break;
            }
            if (object.command != null) {
                if (typeof object.command !== "object")
                    throw TypeError(".mesos.CheckStatusInfo.command: object expected");
                message.command = $root.mesos.CheckStatusInfo.Command.fromObject(object.command);
            }
            if (object.http != null) {
                if (typeof object.http !== "object")
                    throw TypeError(".mesos.CheckStatusInfo.http: object expected");
                message.http = $root.mesos.CheckStatusInfo.Http.fromObject(object.http);
            }
            return message;
        };

        /**
         * Creates a plain object from a CheckStatusInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.CheckStatusInfo
         * @static
         * @param {mesos.CheckStatusInfo} message CheckStatusInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckStatusInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.command = null;
                object.http = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.CheckInfo.Type[message.type] : message.type;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = $root.mesos.CheckStatusInfo.Command.toObject(message.command, options);
            if (message.http != null && message.hasOwnProperty("http"))
                object.http = $root.mesos.CheckStatusInfo.Http.toObject(message.http, options);
            return object;
        };

        /**
         * Converts this CheckStatusInfo to JSON.
         * @function toJSON
         * @memberof mesos.CheckStatusInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckStatusInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CheckStatusInfo.Command = (function() {

            /**
             * Properties of a Command.
             * @memberof mesos.CheckStatusInfo
             * @interface ICommand
             * @property {number} [exitCode] Command exitCode
             */

            /**
             * Constructs a new Command.
             * @memberof mesos.CheckStatusInfo
             * @classdesc Represents a Command.
             * @constructor
             * @param {mesos.CheckStatusInfo.ICommand=} [properties] Properties to set
             */
            function Command(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Command exitCode.
             * @member {number}exitCode
             * @memberof mesos.CheckStatusInfo.Command
             * @instance
             */
            Command.prototype.exitCode = 0;

            /**
             * Creates a new Command instance using the specified properties.
             * @function create
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {mesos.CheckStatusInfo.ICommand=} [properties] Properties to set
             * @returns {mesos.CheckStatusInfo.Command} Command instance
             */
            Command.create = function create(properties) {
                return new Command(properties);
            };

            /**
             * Encodes the specified Command message. Does not implicitly {@link mesos.CheckStatusInfo.Command.verify|verify} messages.
             * @function encode
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {mesos.CheckStatusInfo.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.exitCode);
                return writer;
            };

            /**
             * Encodes the specified Command message, length delimited. Does not implicitly {@link mesos.CheckStatusInfo.Command.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {mesos.CheckStatusInfo.ICommand} message Command message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Command.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Command message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CheckStatusInfo.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckStatusInfo.Command();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exitCode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Command message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CheckStatusInfo.Command} Command
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Command.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Command message.
             * @function verify
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Command.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    if (!$util.isInteger(message.exitCode))
                        return "exitCode: integer expected";
                return null;
            };

            /**
             * Creates a Command message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CheckStatusInfo.Command} Command
             */
            Command.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CheckStatusInfo.Command)
                    return object;
                let message = new $root.mesos.CheckStatusInfo.Command();
                if (object.exitCode != null)
                    message.exitCode = object.exitCode | 0;
                return message;
            };

            /**
             * Creates a plain object from a Command message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CheckStatusInfo.Command
             * @static
             * @param {mesos.CheckStatusInfo.Command} message Command
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Command.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.exitCode = 0;
                if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                    object.exitCode = message.exitCode;
                return object;
            };

            /**
             * Converts this Command to JSON.
             * @function toJSON
             * @memberof mesos.CheckStatusInfo.Command
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Command.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Command;
        })();

        CheckStatusInfo.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof mesos.CheckStatusInfo
             * @interface IHttp
             * @property {number} [statusCode] Http statusCode
             */

            /**
             * Constructs a new Http.
             * @memberof mesos.CheckStatusInfo
             * @classdesc Represents a Http.
             * @constructor
             * @param {mesos.CheckStatusInfo.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http statusCode.
             * @member {number}statusCode
             * @memberof mesos.CheckStatusInfo.Http
             * @instance
             */
            Http.prototype.statusCode = 0;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {mesos.CheckStatusInfo.IHttp=} [properties] Properties to set
             * @returns {mesos.CheckStatusInfo.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link mesos.CheckStatusInfo.Http.verify|verify} messages.
             * @function encode
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {mesos.CheckStatusInfo.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.statusCode);
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link mesos.CheckStatusInfo.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {mesos.CheckStatusInfo.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CheckStatusInfo.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CheckStatusInfo.Http();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.statusCode = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CheckStatusInfo.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                    if (!$util.isInteger(message.statusCode))
                        return "statusCode: integer expected";
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CheckStatusInfo.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CheckStatusInfo.Http)
                    return object;
                let message = new $root.mesos.CheckStatusInfo.Http();
                if (object.statusCode != null)
                    message.statusCode = object.statusCode >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CheckStatusInfo.Http
             * @static
             * @param {mesos.CheckStatusInfo.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.statusCode = 0;
                if (message.statusCode != null && message.hasOwnProperty("statusCode"))
                    object.statusCode = message.statusCode;
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof mesos.CheckStatusInfo.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        return CheckStatusInfo;
    })();

    mesos.TaskStatus = (function() {

        /**
         * Properties of a TaskStatus.
         * @memberof mesos
         * @interface ITaskStatus
         * @property {mesos.ITaskID} taskId TaskStatus taskId
         * @property {mesos.TaskState} state TaskStatus state
         * @property {string} [message] TaskStatus message
         * @property {mesos.TaskStatus.Source} [source] TaskStatus source
         * @property {mesos.TaskStatus.Reason} [reason] TaskStatus reason
         * @property {Uint8Array} [data] TaskStatus data
         * @property {mesos.IAgentID} [agentId] TaskStatus agentId
         * @property {mesos.IExecutorID} [executorId] TaskStatus executorId
         * @property {number} [timestamp] TaskStatus timestamp
         * @property {Uint8Array} [uuid] TaskStatus uuid
         * @property {boolean} [healthy] TaskStatus healthy
         * @property {mesos.ICheckStatusInfo} [checkStatus] TaskStatus checkStatus
         * @property {mesos.ILabels} [labels] TaskStatus labels
         * @property {mesos.IContainerStatus} [containerStatus] TaskStatus containerStatus
         * @property {mesos.ITimeInfo} [unreachableTime] TaskStatus unreachableTime
         */

        /**
         * Constructs a new TaskStatus.
         * @memberof mesos
         * @classdesc Describes the current status of a task.
         * @constructor
         * @param {mesos.ITaskStatus=} [properties] Properties to set
         */
        function TaskStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskStatus taskId.
         * @member {mesos.ITaskID}taskId
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.taskId = null;

        /**
         * TaskStatus state.
         * @member {mesos.TaskState}state
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.state = 6;

        /**
         * TaskStatus message.
         * @member {string}message
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.message = "";

        /**
         * TaskStatus source.
         * @member {mesos.TaskStatus.Source}source
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.source = 0;

        /**
         * TaskStatus reason.
         * @member {mesos.TaskStatus.Reason}reason
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.reason = 0;

        /**
         * TaskStatus data.
         * @member {Uint8Array}data
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.data = $util.newBuffer([]);

        /**
         * TaskStatus agentId.
         * @member {(mesos.IAgentID|null|undefined)}agentId
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.agentId = null;

        /**
         * TaskStatus executorId.
         * @member {(mesos.IExecutorID|null|undefined)}executorId
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.executorId = null;

        /**
         * TaskStatus timestamp.
         * @member {number}timestamp
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.timestamp = 0;

        /**
         * TaskStatus uuid.
         * @member {Uint8Array}uuid
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.uuid = $util.newBuffer([]);

        /**
         * TaskStatus healthy.
         * @member {boolean}healthy
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.healthy = false;

        /**
         * TaskStatus checkStatus.
         * @member {(mesos.ICheckStatusInfo|null|undefined)}checkStatus
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.checkStatus = null;

        /**
         * TaskStatus labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.labels = null;

        /**
         * TaskStatus containerStatus.
         * @member {(mesos.IContainerStatus|null|undefined)}containerStatus
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.containerStatus = null;

        /**
         * TaskStatus unreachableTime.
         * @member {(mesos.ITimeInfo|null|undefined)}unreachableTime
         * @memberof mesos.TaskStatus
         * @instance
         */
        TaskStatus.prototype.unreachableTime = null;

        /**
         * Creates a new TaskStatus instance using the specified properties.
         * @function create
         * @memberof mesos.TaskStatus
         * @static
         * @param {mesos.ITaskStatus=} [properties] Properties to set
         * @returns {mesos.TaskStatus} TaskStatus instance
         */
        TaskStatus.create = function create(properties) {
            return new TaskStatus(properties);
        };

        /**
         * Encodes the specified TaskStatus message. Does not implicitly {@link mesos.TaskStatus.verify|verify} messages.
         * @function encode
         * @memberof mesos.TaskStatus
         * @static
         * @param {mesos.ITaskStatus} message TaskStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.timestamp);
            if (message.executorId != null && message.hasOwnProperty("executorId"))
                $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.healthy != null && message.hasOwnProperty("healthy"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.healthy);
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.source);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.reason);
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.uuid);
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.containerStatus != null && message.hasOwnProperty("containerStatus"))
                $root.mesos.ContainerStatus.encode(message.containerStatus, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.unreachableTime != null && message.hasOwnProperty("unreachableTime"))
                $root.mesos.TimeInfo.encode(message.unreachableTime, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.checkStatus != null && message.hasOwnProperty("checkStatus"))
                $root.mesos.CheckStatusInfo.encode(message.checkStatus, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskStatus message, length delimited. Does not implicitly {@link mesos.TaskStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TaskStatus
         * @static
         * @param {mesos.ITaskStatus} message TaskStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskStatus message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TaskStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TaskStatus} TaskStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TaskStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.message = reader.string();
                    break;
                case 9:
                    message.source = reader.int32();
                    break;
                case 10:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timestamp = reader.double();
                    break;
                case 11:
                    message.uuid = reader.bytes();
                    break;
                case 8:
                    message.healthy = reader.bool();
                    break;
                case 15:
                    message.checkStatus = $root.mesos.CheckStatusInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.containerStatus = $root.mesos.ContainerStatus.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.unreachableTime = $root.mesos.TimeInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("taskId"))
                throw $util.ProtocolError("missing required 'taskId'", { instance: message });
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };

        /**
         * Decodes a TaskStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TaskStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TaskStatus} TaskStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskStatus message.
         * @function verify
         * @memberof mesos.TaskStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let error = $root.mesos.TaskID.verify(message.taskId);
            if (error)
                return "taskId." + error;
            switch (message.state) {
            default:
                return "state: enum value expected";
            case 6:
            case 0:
            case 1:
            case 8:
            case 2:
            case 3:
            case 4:
            case 7:
            case 5:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                switch (message.source) {
                default:
                    return "source: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 21:
                case 19:
                case 20:
                case 8:
                case 17:
                case 22:
                case 23:
                case 24:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 27:
                case 7:
                case 9:
                case 18:
                case 10:
                case 11:
                case 12:
                case 13:
                case 28:
                case 25:
                case 26:
                case 14:
                case 15:
                case 16:
                    break;
                }
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.agentId != null && message.hasOwnProperty("agentId")) {
                error = $root.mesos.AgentID.verify(message.agentId);
                if (error)
                    return "agentId." + error;
            }
            if (message.executorId != null && message.hasOwnProperty("executorId")) {
                error = $root.mesos.ExecutorID.verify(message.executorId);
                if (error)
                    return "executorId." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                if (!(message.uuid && typeof message.uuid.length === "number" || $util.isString(message.uuid)))
                    return "uuid: buffer expected";
            if (message.healthy != null && message.hasOwnProperty("healthy"))
                if (typeof message.healthy !== "boolean")
                    return "healthy: boolean expected";
            if (message.checkStatus != null && message.hasOwnProperty("checkStatus")) {
                error = $root.mesos.CheckStatusInfo.verify(message.checkStatus);
                if (error)
                    return "checkStatus." + error;
            }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            if (message.containerStatus != null && message.hasOwnProperty("containerStatus")) {
                error = $root.mesos.ContainerStatus.verify(message.containerStatus);
                if (error)
                    return "containerStatus." + error;
            }
            if (message.unreachableTime != null && message.hasOwnProperty("unreachableTime")) {
                error = $root.mesos.TimeInfo.verify(message.unreachableTime);
                if (error)
                    return "unreachableTime." + error;
            }
            return null;
        };

        /**
         * Creates a TaskStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TaskStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TaskStatus} TaskStatus
         */
        TaskStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TaskStatus)
                return object;
            let message = new $root.mesos.TaskStatus();
            if (object.taskId != null) {
                if (typeof object.taskId !== "object")
                    throw TypeError(".mesos.TaskStatus.taskId: object expected");
                message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
            }
            switch (object.state) {
            case "TASK_STAGING":
            case 6:
                message.state = 6;
                break;
            case "TASK_STARTING":
            case 0:
                message.state = 0;
                break;
            case "TASK_RUNNING":
            case 1:
                message.state = 1;
                break;
            case "TASK_KILLING":
            case 8:
                message.state = 8;
                break;
            case "TASK_FINISHED":
            case 2:
                message.state = 2;
                break;
            case "TASK_FAILED":
            case 3:
                message.state = 3;
                break;
            case "TASK_KILLED":
            case 4:
                message.state = 4;
                break;
            case "TASK_ERROR":
            case 7:
                message.state = 7;
                break;
            case "TASK_LOST":
            case 5:
                message.state = 5;
                break;
            case "TASK_DROPPED":
            case 9:
                message.state = 9;
                break;
            case "TASK_UNREACHABLE":
            case 10:
                message.state = 10;
                break;
            case "TASK_GONE":
            case 11:
                message.state = 11;
                break;
            case "TASK_GONE_BY_OPERATOR":
            case 12:
                message.state = 12;
                break;
            case "TASK_UNKNOWN":
            case 13:
                message.state = 13;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            switch (object.source) {
            case "SOURCE_MASTER":
            case 0:
                message.source = 0;
                break;
            case "SOURCE_AGENT":
            case 1:
                message.source = 1;
                break;
            case "SOURCE_EXECUTOR":
            case 2:
                message.source = 2;
                break;
            }
            switch (object.reason) {
            case "REASON_COMMAND_EXECUTOR_FAILED":
            case 0:
                message.reason = 0;
                break;
            case "REASON_CONTAINER_LAUNCH_FAILED":
            case 21:
                message.reason = 21;
                break;
            case "REASON_CONTAINER_LIMITATION":
            case 19:
                message.reason = 19;
                break;
            case "REASON_CONTAINER_LIMITATION_DISK":
            case 20:
                message.reason = 20;
                break;
            case "REASON_CONTAINER_LIMITATION_MEMORY":
            case 8:
                message.reason = 8;
                break;
            case "REASON_CONTAINER_PREEMPTED":
            case 17:
                message.reason = 17;
                break;
            case "REASON_CONTAINER_UPDATE_FAILED":
            case 22:
                message.reason = 22;
                break;
            case "REASON_EXECUTOR_REGISTRATION_TIMEOUT":
            case 23:
                message.reason = 23;
                break;
            case "REASON_EXECUTOR_REREGISTRATION_TIMEOUT":
            case 24:
                message.reason = 24;
                break;
            case "REASON_EXECUTOR_TERMINATED":
            case 1:
                message.reason = 1;
                break;
            case "REASON_EXECUTOR_UNREGISTERED":
            case 2:
                message.reason = 2;
                break;
            case "REASON_FRAMEWORK_REMOVED":
            case 3:
                message.reason = 3;
                break;
            case "REASON_GC_ERROR":
            case 4:
                message.reason = 4;
                break;
            case "REASON_INVALID_FRAMEWORKID":
            case 5:
                message.reason = 5;
                break;
            case "REASON_INVALID_OFFERS":
            case 6:
                message.reason = 6;
                break;
            case "REASON_IO_SWITCHBOARD_EXITED":
            case 27:
                message.reason = 27;
                break;
            case "REASON_MASTER_DISCONNECTED":
            case 7:
                message.reason = 7;
                break;
            case "REASON_RECONCILIATION":
            case 9:
                message.reason = 9;
                break;
            case "REASON_RESOURCES_UNKNOWN":
            case 18:
                message.reason = 18;
                break;
            case "REASON_AGENT_DISCONNECTED":
            case 10:
                message.reason = 10;
                break;
            case "REASON_AGENT_REMOVED":
            case 11:
                message.reason = 11;
                break;
            case "REASON_AGENT_RESTARTED":
            case 12:
                message.reason = 12;
                break;
            case "REASON_AGENT_UNKNOWN":
            case 13:
                message.reason = 13;
                break;
            case "REASON_TASK_CHECK_STATUS_UPDATED":
            case 28:
                message.reason = 28;
                break;
            case "REASON_TASK_GROUP_INVALID":
            case 25:
                message.reason = 25;
                break;
            case "REASON_TASK_GROUP_UNAUTHORIZED":
            case 26:
                message.reason = 26;
                break;
            case "REASON_TASK_INVALID":
            case 14:
                message.reason = 14;
                break;
            case "REASON_TASK_UNAUTHORIZED":
            case 15:
                message.reason = 15;
                break;
            case "REASON_TASK_UNKNOWN":
            case 16:
                message.reason = 16;
                break;
            }
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.agentId != null) {
                if (typeof object.agentId !== "object")
                    throw TypeError(".mesos.TaskStatus.agentId: object expected");
                message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
            }
            if (object.executorId != null) {
                if (typeof object.executorId !== "object")
                    throw TypeError(".mesos.TaskStatus.executorId: object expected");
                message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
            }
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.uuid != null)
                if (typeof object.uuid === "string")
                    $util.base64.decode(object.uuid, message.uuid = $util.newBuffer($util.base64.length(object.uuid)), 0);
                else if (object.uuid.length)
                    message.uuid = object.uuid;
            if (object.healthy != null)
                message.healthy = Boolean(object.healthy);
            if (object.checkStatus != null) {
                if (typeof object.checkStatus !== "object")
                    throw TypeError(".mesos.TaskStatus.checkStatus: object expected");
                message.checkStatus = $root.mesos.CheckStatusInfo.fromObject(object.checkStatus);
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.TaskStatus.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            if (object.containerStatus != null) {
                if (typeof object.containerStatus !== "object")
                    throw TypeError(".mesos.TaskStatus.containerStatus: object expected");
                message.containerStatus = $root.mesos.ContainerStatus.fromObject(object.containerStatus);
            }
            if (object.unreachableTime != null) {
                if (typeof object.unreachableTime !== "object")
                    throw TypeError(".mesos.TaskStatus.unreachableTime: object expected");
                message.unreachableTime = $root.mesos.TimeInfo.fromObject(object.unreachableTime);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TaskStatus
         * @static
         * @param {mesos.TaskStatus} message TaskStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.taskId = null;
                object.state = options.enums === String ? "TASK_STAGING" : 6;
                object.data = options.bytes === String ? "" : [];
                object.message = "";
                object.agentId = null;
                object.timestamp = 0;
                object.executorId = null;
                object.healthy = false;
                object.source = options.enums === String ? "SOURCE_MASTER" : 0;
                object.reason = options.enums === String ? "REASON_COMMAND_EXECUTOR_FAILED" : 0;
                object.uuid = options.bytes === String ? "" : [];
                object.labels = null;
                object.containerStatus = null;
                object.unreachableTime = null;
                object.checkStatus = null;
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.mesos.TaskState[message.state] : message.state;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.agentId != null && message.hasOwnProperty("agentId"))
                object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.executorId != null && message.hasOwnProperty("executorId"))
                object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
            if (message.healthy != null && message.hasOwnProperty("healthy"))
                object.healthy = message.healthy;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.enums === String ? $root.mesos.TaskStatus.Source[message.source] : message.source;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.mesos.TaskStatus.Reason[message.reason] : message.reason;
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                object.uuid = options.bytes === String ? $util.base64.encode(message.uuid, 0, message.uuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uuid) : message.uuid;
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.containerStatus != null && message.hasOwnProperty("containerStatus"))
                object.containerStatus = $root.mesos.ContainerStatus.toObject(message.containerStatus, options);
            if (message.unreachableTime != null && message.hasOwnProperty("unreachableTime"))
                object.unreachableTime = $root.mesos.TimeInfo.toObject(message.unreachableTime, options);
            if (message.checkStatus != null && message.hasOwnProperty("checkStatus"))
                object.checkStatus = $root.mesos.CheckStatusInfo.toObject(message.checkStatus, options);
            return object;
        };

        /**
         * Converts this TaskStatus to JSON.
         * @function toJSON
         * @memberof mesos.TaskStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Source enum.
         * @enum {string}
         * @property {number} SOURCE_MASTER=0 SOURCE_MASTER value
         * @property {number} SOURCE_AGENT=1 SOURCE_AGENT value
         * @property {number} SOURCE_EXECUTOR=2 SOURCE_EXECUTOR value
         */
        TaskStatus.Source = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SOURCE_MASTER"] = 0;
            values[valuesById[1] = "SOURCE_AGENT"] = 1;
            values[valuesById[2] = "SOURCE_EXECUTOR"] = 2;
            return values;
        })();

        /**
         * Reason enum.
         * @enum {string}
         * @property {number} REASON_COMMAND_EXECUTOR_FAILED=0 REASON_COMMAND_EXECUTOR_FAILED value
         * @property {number} REASON_CONTAINER_LAUNCH_FAILED=21 REASON_CONTAINER_LAUNCH_FAILED value
         * @property {number} REASON_CONTAINER_LIMITATION=19 REASON_CONTAINER_LIMITATION value
         * @property {number} REASON_CONTAINER_LIMITATION_DISK=20 REASON_CONTAINER_LIMITATION_DISK value
         * @property {number} REASON_CONTAINER_LIMITATION_MEMORY=8 REASON_CONTAINER_LIMITATION_MEMORY value
         * @property {number} REASON_CONTAINER_PREEMPTED=17 REASON_CONTAINER_PREEMPTED value
         * @property {number} REASON_CONTAINER_UPDATE_FAILED=22 REASON_CONTAINER_UPDATE_FAILED value
         * @property {number} REASON_EXECUTOR_REGISTRATION_TIMEOUT=23 REASON_EXECUTOR_REGISTRATION_TIMEOUT value
         * @property {number} REASON_EXECUTOR_REREGISTRATION_TIMEOUT=24 REASON_EXECUTOR_REREGISTRATION_TIMEOUT value
         * @property {number} REASON_EXECUTOR_TERMINATED=1 REASON_EXECUTOR_TERMINATED value
         * @property {number} REASON_EXECUTOR_UNREGISTERED=2 REASON_EXECUTOR_UNREGISTERED value
         * @property {number} REASON_FRAMEWORK_REMOVED=3 REASON_FRAMEWORK_REMOVED value
         * @property {number} REASON_GC_ERROR=4 REASON_GC_ERROR value
         * @property {number} REASON_INVALID_FRAMEWORKID=5 REASON_INVALID_FRAMEWORKID value
         * @property {number} REASON_INVALID_OFFERS=6 REASON_INVALID_OFFERS value
         * @property {number} REASON_IO_SWITCHBOARD_EXITED=27 REASON_IO_SWITCHBOARD_EXITED value
         * @property {number} REASON_MASTER_DISCONNECTED=7 REASON_MASTER_DISCONNECTED value
         * @property {number} REASON_RECONCILIATION=9 REASON_RECONCILIATION value
         * @property {number} REASON_RESOURCES_UNKNOWN=18 REASON_RESOURCES_UNKNOWN value
         * @property {number} REASON_AGENT_DISCONNECTED=10 REASON_AGENT_DISCONNECTED value
         * @property {number} REASON_AGENT_REMOVED=11 REASON_AGENT_REMOVED value
         * @property {number} REASON_AGENT_RESTARTED=12 REASON_AGENT_RESTARTED value
         * @property {number} REASON_AGENT_UNKNOWN=13 REASON_AGENT_UNKNOWN value
         * @property {number} REASON_TASK_CHECK_STATUS_UPDATED=28 REASON_TASK_CHECK_STATUS_UPDATED value
         * @property {number} REASON_TASK_GROUP_INVALID=25 REASON_TASK_GROUP_INVALID value
         * @property {number} REASON_TASK_GROUP_UNAUTHORIZED=26 REASON_TASK_GROUP_UNAUTHORIZED value
         * @property {number} REASON_TASK_INVALID=14 REASON_TASK_INVALID value
         * @property {number} REASON_TASK_UNAUTHORIZED=15 REASON_TASK_UNAUTHORIZED value
         * @property {number} REASON_TASK_UNKNOWN=16 REASON_TASK_UNKNOWN value
         */
        TaskStatus.Reason = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REASON_COMMAND_EXECUTOR_FAILED"] = 0;
            values[valuesById[21] = "REASON_CONTAINER_LAUNCH_FAILED"] = 21;
            values[valuesById[19] = "REASON_CONTAINER_LIMITATION"] = 19;
            values[valuesById[20] = "REASON_CONTAINER_LIMITATION_DISK"] = 20;
            values[valuesById[8] = "REASON_CONTAINER_LIMITATION_MEMORY"] = 8;
            values[valuesById[17] = "REASON_CONTAINER_PREEMPTED"] = 17;
            values[valuesById[22] = "REASON_CONTAINER_UPDATE_FAILED"] = 22;
            values[valuesById[23] = "REASON_EXECUTOR_REGISTRATION_TIMEOUT"] = 23;
            values[valuesById[24] = "REASON_EXECUTOR_REREGISTRATION_TIMEOUT"] = 24;
            values[valuesById[1] = "REASON_EXECUTOR_TERMINATED"] = 1;
            values[valuesById[2] = "REASON_EXECUTOR_UNREGISTERED"] = 2;
            values[valuesById[3] = "REASON_FRAMEWORK_REMOVED"] = 3;
            values[valuesById[4] = "REASON_GC_ERROR"] = 4;
            values[valuesById[5] = "REASON_INVALID_FRAMEWORKID"] = 5;
            values[valuesById[6] = "REASON_INVALID_OFFERS"] = 6;
            values[valuesById[27] = "REASON_IO_SWITCHBOARD_EXITED"] = 27;
            values[valuesById[7] = "REASON_MASTER_DISCONNECTED"] = 7;
            values[valuesById[9] = "REASON_RECONCILIATION"] = 9;
            values[valuesById[18] = "REASON_RESOURCES_UNKNOWN"] = 18;
            values[valuesById[10] = "REASON_AGENT_DISCONNECTED"] = 10;
            values[valuesById[11] = "REASON_AGENT_REMOVED"] = 11;
            values[valuesById[12] = "REASON_AGENT_RESTARTED"] = 12;
            values[valuesById[13] = "REASON_AGENT_UNKNOWN"] = 13;
            values[valuesById[28] = "REASON_TASK_CHECK_STATUS_UPDATED"] = 28;
            values[valuesById[25] = "REASON_TASK_GROUP_INVALID"] = 25;
            values[valuesById[26] = "REASON_TASK_GROUP_UNAUTHORIZED"] = 26;
            values[valuesById[14] = "REASON_TASK_INVALID"] = 14;
            values[valuesById[15] = "REASON_TASK_UNAUTHORIZED"] = 15;
            values[valuesById[16] = "REASON_TASK_UNKNOWN"] = 16;
            return values;
        })();

        return TaskStatus;
    })();

    mesos.Filters = (function() {

        /**
         * Properties of a Filters.
         * @memberof mesos
         * @interface IFilters
         * @property {number} [refuseSeconds] Filters refuseSeconds
         */

        /**
         * Constructs a new Filters.
         * @memberof mesos
         * @classdesc Describes possible filters that can be applied to unused resources
         * (see SchedulerDriver::launchTasks) to influence the allocator.
         * @constructor
         * @param {mesos.IFilters=} [properties] Properties to set
         */
        function Filters(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Filters refuseSeconds.
         * @member {number}refuseSeconds
         * @memberof mesos.Filters
         * @instance
         */
        Filters.prototype.refuseSeconds = 5;

        /**
         * Creates a new Filters instance using the specified properties.
         * @function create
         * @memberof mesos.Filters
         * @static
         * @param {mesos.IFilters=} [properties] Properties to set
         * @returns {mesos.Filters} Filters instance
         */
        Filters.create = function create(properties) {
            return new Filters(properties);
        };

        /**
         * Encodes the specified Filters message. Does not implicitly {@link mesos.Filters.verify|verify} messages.
         * @function encode
         * @memberof mesos.Filters
         * @static
         * @param {mesos.IFilters} message Filters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Filters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.refuseSeconds != null && message.hasOwnProperty("refuseSeconds"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.refuseSeconds);
            return writer;
        };

        /**
         * Encodes the specified Filters message, length delimited. Does not implicitly {@link mesos.Filters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Filters
         * @static
         * @param {mesos.IFilters} message Filters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Filters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Filters message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Filters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Filters} Filters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Filters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Filters();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.refuseSeconds = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Filters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Filters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Filters} Filters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Filters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Filters message.
         * @function verify
         * @memberof mesos.Filters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Filters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.refuseSeconds != null && message.hasOwnProperty("refuseSeconds"))
                if (typeof message.refuseSeconds !== "number")
                    return "refuseSeconds: number expected";
            return null;
        };

        /**
         * Creates a Filters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Filters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Filters} Filters
         */
        Filters.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Filters)
                return object;
            let message = new $root.mesos.Filters();
            if (object.refuseSeconds != null)
                message.refuseSeconds = Number(object.refuseSeconds);
            return message;
        };

        /**
         * Creates a plain object from a Filters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Filters
         * @static
         * @param {mesos.Filters} message Filters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Filters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.refuseSeconds = 5;
            if (message.refuseSeconds != null && message.hasOwnProperty("refuseSeconds"))
                object.refuseSeconds = options.json && !isFinite(message.refuseSeconds) ? String(message.refuseSeconds) : message.refuseSeconds;
            return object;
        };

        /**
         * Converts this Filters to JSON.
         * @function toJSON
         * @memberof mesos.Filters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Filters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Filters;
    })();

    mesos.Environment = (function() {

        /**
         * Properties of an Environment.
         * @memberof mesos
         * @interface IEnvironment
         * @property {Array.<mesos.Environment.IVariable>} [variables] Environment variables
         */

        /**
         * Constructs a new Environment.
         * @memberof mesos
         * @classdesc Describes a collection of environment variables. This is used with
         * CommandInfo in order to set environment variables before running a
         * command.
         * @constructor
         * @param {mesos.IEnvironment=} [properties] Properties to set
         */
        function Environment(properties) {
            this.variables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Environment variables.
         * @member {Array.<mesos.Environment.IVariable>}variables
         * @memberof mesos.Environment
         * @instance
         */
        Environment.prototype.variables = $util.emptyArray;

        /**
         * Creates a new Environment instance using the specified properties.
         * @function create
         * @memberof mesos.Environment
         * @static
         * @param {mesos.IEnvironment=} [properties] Properties to set
         * @returns {mesos.Environment} Environment instance
         */
        Environment.create = function create(properties) {
            return new Environment(properties);
        };

        /**
         * Encodes the specified Environment message. Does not implicitly {@link mesos.Environment.verify|verify} messages.
         * @function encode
         * @memberof mesos.Environment
         * @static
         * @param {mesos.IEnvironment} message Environment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.variables != null && message.variables.length)
                for (let i = 0; i < message.variables.length; ++i)
                    $root.mesos.Environment.Variable.encode(message.variables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Environment message, length delimited. Does not implicitly {@link mesos.Environment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Environment
         * @static
         * @param {mesos.IEnvironment} message Environment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Environment message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Environment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Environment} Environment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Environment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.variables && message.variables.length))
                        message.variables = [];
                    message.variables.push($root.mesos.Environment.Variable.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Environment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Environment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Environment} Environment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Environment message.
         * @function verify
         * @memberof mesos.Environment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Environment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.variables != null && message.hasOwnProperty("variables")) {
                if (!Array.isArray(message.variables))
                    return "variables: array expected";
                for (let i = 0; i < message.variables.length; ++i) {
                    let error = $root.mesos.Environment.Variable.verify(message.variables[i]);
                    if (error)
                        return "variables." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Environment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Environment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Environment} Environment
         */
        Environment.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Environment)
                return object;
            let message = new $root.mesos.Environment();
            if (object.variables) {
                if (!Array.isArray(object.variables))
                    throw TypeError(".mesos.Environment.variables: array expected");
                message.variables = [];
                for (let i = 0; i < object.variables.length; ++i) {
                    if (typeof object.variables[i] !== "object")
                        throw TypeError(".mesos.Environment.variables: object expected");
                    message.variables[i] = $root.mesos.Environment.Variable.fromObject(object.variables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Environment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Environment
         * @static
         * @param {mesos.Environment} message Environment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Environment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.variables = [];
            if (message.variables && message.variables.length) {
                object.variables = [];
                for (let j = 0; j < message.variables.length; ++j)
                    object.variables[j] = $root.mesos.Environment.Variable.toObject(message.variables[j], options);
            }
            return object;
        };

        /**
         * Converts this Environment to JSON.
         * @function toJSON
         * @memberof mesos.Environment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Environment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Environment.Variable = (function() {

            /**
             * Properties of a Variable.
             * @memberof mesos.Environment
             * @interface IVariable
             * @property {string} name Variable name
             * @property {string} [value] Variable value
             */

            /**
             * Constructs a new Variable.
             * @memberof mesos.Environment
             * @classdesc Represents a Variable.
             * @constructor
             * @param {mesos.Environment.IVariable=} [properties] Properties to set
             */
            function Variable(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Variable name.
             * @member {string}name
             * @memberof mesos.Environment.Variable
             * @instance
             */
            Variable.prototype.name = "";

            /**
             * Variable value.
             * @member {string}value
             * @memberof mesos.Environment.Variable
             * @instance
             */
            Variable.prototype.value = "";

            /**
             * Creates a new Variable instance using the specified properties.
             * @function create
             * @memberof mesos.Environment.Variable
             * @static
             * @param {mesos.Environment.IVariable=} [properties] Properties to set
             * @returns {mesos.Environment.Variable} Variable instance
             */
            Variable.create = function create(properties) {
                return new Variable(properties);
            };

            /**
             * Encodes the specified Variable message. Does not implicitly {@link mesos.Environment.Variable.verify|verify} messages.
             * @function encode
             * @memberof mesos.Environment.Variable
             * @static
             * @param {mesos.Environment.IVariable} message Variable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Variable.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Variable message, length delimited. Does not implicitly {@link mesos.Environment.Variable.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Environment.Variable
             * @static
             * @param {mesos.Environment.IVariable} message Variable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Variable.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Variable message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Environment.Variable
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Environment.Variable} Variable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Variable.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Environment.Variable();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };

            /**
             * Decodes a Variable message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Environment.Variable
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Environment.Variable} Variable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Variable.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Variable message.
             * @function verify
             * @memberof mesos.Environment.Variable
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Variable.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a Variable message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Environment.Variable
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Environment.Variable} Variable
             */
            Variable.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Environment.Variable)
                    return object;
                let message = new $root.mesos.Environment.Variable();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a Variable message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Environment.Variable
             * @static
             * @param {mesos.Environment.Variable} message Variable
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Variable.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Variable to JSON.
             * @function toJSON
             * @memberof mesos.Environment.Variable
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Variable.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Variable;
        })();

        return Environment;
    })();

    mesos.Parameter = (function() {

        /**
         * Properties of a Parameter.
         * @memberof mesos
         * @interface IParameter
         * @property {string} key Parameter key
         * @property {string} value Parameter value
         */

        /**
         * Constructs a new Parameter.
         * @memberof mesos
         * @classdesc A generic (key, value) pair used in various places for parameters.
         * @constructor
         * @param {mesos.IParameter=} [properties] Properties to set
         */
        function Parameter(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Parameter key.
         * @member {string}key
         * @memberof mesos.Parameter
         * @instance
         */
        Parameter.prototype.key = "";

        /**
         * Parameter value.
         * @member {string}value
         * @memberof mesos.Parameter
         * @instance
         */
        Parameter.prototype.value = "";

        /**
         * Creates a new Parameter instance using the specified properties.
         * @function create
         * @memberof mesos.Parameter
         * @static
         * @param {mesos.IParameter=} [properties] Properties to set
         * @returns {mesos.Parameter} Parameter instance
         */
        Parameter.create = function create(properties) {
            return new Parameter(properties);
        };

        /**
         * Encodes the specified Parameter message. Does not implicitly {@link mesos.Parameter.verify|verify} messages.
         * @function encode
         * @memberof mesos.Parameter
         * @static
         * @param {mesos.IParameter} message Parameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Parameter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Parameter message, length delimited. Does not implicitly {@link mesos.Parameter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Parameter
         * @static
         * @param {mesos.IParameter} message Parameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Parameter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Parameter message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Parameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Parameter} Parameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Parameter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Parameter();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };

        /**
         * Decodes a Parameter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Parameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Parameter} Parameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Parameter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Parameter message.
         * @function verify
         * @memberof mesos.Parameter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Parameter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.key))
                return "key: string expected";
            if (!$util.isString(message.value))
                return "value: string expected";
            return null;
        };

        /**
         * Creates a Parameter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Parameter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Parameter} Parameter
         */
        Parameter.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Parameter)
                return object;
            let message = new $root.mesos.Parameter();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Parameter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Parameter
         * @static
         * @param {mesos.Parameter} message Parameter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Parameter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Parameter to JSON.
         * @function toJSON
         * @memberof mesos.Parameter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Parameter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Parameter;
    })();

    mesos.Parameters = (function() {

        /**
         * Properties of a Parameters.
         * @memberof mesos
         * @interface IParameters
         * @property {Array.<mesos.IParameter>} [parameter] Parameters parameter
         */

        /**
         * Constructs a new Parameters.
         * @memberof mesos
         * @classdesc Collection of Parameter.
         * @constructor
         * @param {mesos.IParameters=} [properties] Properties to set
         */
        function Parameters(properties) {
            this.parameter = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Parameters parameter.
         * @member {Array.<mesos.IParameter>}parameter
         * @memberof mesos.Parameters
         * @instance
         */
        Parameters.prototype.parameter = $util.emptyArray;

        /**
         * Creates a new Parameters instance using the specified properties.
         * @function create
         * @memberof mesos.Parameters
         * @static
         * @param {mesos.IParameters=} [properties] Properties to set
         * @returns {mesos.Parameters} Parameters instance
         */
        Parameters.create = function create(properties) {
            return new Parameters(properties);
        };

        /**
         * Encodes the specified Parameters message. Does not implicitly {@link mesos.Parameters.verify|verify} messages.
         * @function encode
         * @memberof mesos.Parameters
         * @static
         * @param {mesos.IParameters} message Parameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Parameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.parameter != null && message.parameter.length)
                for (let i = 0; i < message.parameter.length; ++i)
                    $root.mesos.Parameter.encode(message.parameter[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Parameters message, length delimited. Does not implicitly {@link mesos.Parameters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Parameters
         * @static
         * @param {mesos.IParameters} message Parameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Parameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Parameters message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Parameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Parameters} Parameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Parameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Parameters();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.parameter && message.parameter.length))
                        message.parameter = [];
                    message.parameter.push($root.mesos.Parameter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Parameters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Parameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Parameters} Parameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Parameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Parameters message.
         * @function verify
         * @memberof mesos.Parameters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Parameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.parameter != null && message.hasOwnProperty("parameter")) {
                if (!Array.isArray(message.parameter))
                    return "parameter: array expected";
                for (let i = 0; i < message.parameter.length; ++i) {
                    let error = $root.mesos.Parameter.verify(message.parameter[i]);
                    if (error)
                        return "parameter." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Parameters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Parameters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Parameters} Parameters
         */
        Parameters.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Parameters)
                return object;
            let message = new $root.mesos.Parameters();
            if (object.parameter) {
                if (!Array.isArray(object.parameter))
                    throw TypeError(".mesos.Parameters.parameter: array expected");
                message.parameter = [];
                for (let i = 0; i < object.parameter.length; ++i) {
                    if (typeof object.parameter[i] !== "object")
                        throw TypeError(".mesos.Parameters.parameter: object expected");
                    message.parameter[i] = $root.mesos.Parameter.fromObject(object.parameter[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Parameters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Parameters
         * @static
         * @param {mesos.Parameters} message Parameters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Parameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.parameter = [];
            if (message.parameter && message.parameter.length) {
                object.parameter = [];
                for (let j = 0; j < message.parameter.length; ++j)
                    object.parameter[j] = $root.mesos.Parameter.toObject(message.parameter[j], options);
            }
            return object;
        };

        /**
         * Converts this Parameters to JSON.
         * @function toJSON
         * @memberof mesos.Parameters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Parameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Parameters;
    })();

    mesos.Credential = (function() {

        /**
         * Properties of a Credential.
         * @memberof mesos
         * @interface ICredential
         * @property {string} principal Credential principal
         * @property {string} [secret] Credential secret
         */

        /**
         * Constructs a new Credential.
         * @memberof mesos
         * @classdesc Credential used in various places for authentication and
         * authorization.
         * 
         * NOTE: A 'principal' is different from 'FrameworkInfo.user'. The
         * former is used for authentication and authorization while the
         * latter is used to determine the default user under which the
         * framework's executors/tasks are run.
         * @constructor
         * @param {mesos.ICredential=} [properties] Properties to set
         */
        function Credential(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Credential principal.
         * @member {string}principal
         * @memberof mesos.Credential
         * @instance
         */
        Credential.prototype.principal = "";

        /**
         * Credential secret.
         * @member {string}secret
         * @memberof mesos.Credential
         * @instance
         */
        Credential.prototype.secret = "";

        /**
         * Creates a new Credential instance using the specified properties.
         * @function create
         * @memberof mesos.Credential
         * @static
         * @param {mesos.ICredential=} [properties] Properties to set
         * @returns {mesos.Credential} Credential instance
         */
        Credential.create = function create(properties) {
            return new Credential(properties);
        };

        /**
         * Encodes the specified Credential message. Does not implicitly {@link mesos.Credential.verify|verify} messages.
         * @function encode
         * @memberof mesos.Credential
         * @static
         * @param {mesos.ICredential} message Credential message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Credential.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.principal);
            if (message.secret != null && message.hasOwnProperty("secret"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.secret);
            return writer;
        };

        /**
         * Encodes the specified Credential message, length delimited. Does not implicitly {@link mesos.Credential.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Credential
         * @static
         * @param {mesos.ICredential} message Credential message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Credential.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Credential message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Credential
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Credential} Credential
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Credential.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Credential();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.principal = reader.string();
                    break;
                case 2:
                    message.secret = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("principal"))
                throw $util.ProtocolError("missing required 'principal'", { instance: message });
            return message;
        };

        /**
         * Decodes a Credential message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Credential
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Credential} Credential
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Credential.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Credential message.
         * @function verify
         * @memberof mesos.Credential
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Credential.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.principal))
                return "principal: string expected";
            if (message.secret != null && message.hasOwnProperty("secret"))
                if (!$util.isString(message.secret))
                    return "secret: string expected";
            return null;
        };

        /**
         * Creates a Credential message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Credential
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Credential} Credential
         */
        Credential.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Credential)
                return object;
            let message = new $root.mesos.Credential();
            if (object.principal != null)
                message.principal = String(object.principal);
            if (object.secret != null)
                message.secret = String(object.secret);
            return message;
        };

        /**
         * Creates a plain object from a Credential message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Credential
         * @static
         * @param {mesos.Credential} message Credential
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Credential.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.principal = "";
                object.secret = "";
            }
            if (message.principal != null && message.hasOwnProperty("principal"))
                object.principal = message.principal;
            if (message.secret != null && message.hasOwnProperty("secret"))
                object.secret = message.secret;
            return object;
        };

        /**
         * Converts this Credential to JSON.
         * @function toJSON
         * @memberof mesos.Credential
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Credential.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Credential;
    })();

    mesos.Credentials = (function() {

        /**
         * Properties of a Credentials.
         * @memberof mesos
         * @interface ICredentials
         * @property {Array.<mesos.ICredential>} [credentials] Credentials credentials
         */

        /**
         * Constructs a new Credentials.
         * @memberof mesos
         * @classdesc Credentials used for framework authentication, HTTP authentication
         * (where the common 'username' and 'password' are captured as
         * 'principal' and 'secret' respectively), etc.
         * @constructor
         * @param {mesos.ICredentials=} [properties] Properties to set
         */
        function Credentials(properties) {
            this.credentials = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Credentials credentials.
         * @member {Array.<mesos.ICredential>}credentials
         * @memberof mesos.Credentials
         * @instance
         */
        Credentials.prototype.credentials = $util.emptyArray;

        /**
         * Creates a new Credentials instance using the specified properties.
         * @function create
         * @memberof mesos.Credentials
         * @static
         * @param {mesos.ICredentials=} [properties] Properties to set
         * @returns {mesos.Credentials} Credentials instance
         */
        Credentials.create = function create(properties) {
            return new Credentials(properties);
        };

        /**
         * Encodes the specified Credentials message. Does not implicitly {@link mesos.Credentials.verify|verify} messages.
         * @function encode
         * @memberof mesos.Credentials
         * @static
         * @param {mesos.ICredentials} message Credentials message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Credentials.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.credentials != null && message.credentials.length)
                for (let i = 0; i < message.credentials.length; ++i)
                    $root.mesos.Credential.encode(message.credentials[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Credentials message, length delimited. Does not implicitly {@link mesos.Credentials.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Credentials
         * @static
         * @param {mesos.ICredentials} message Credentials message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Credentials.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Credentials message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Credentials
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Credentials} Credentials
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Credentials.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Credentials();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.credentials && message.credentials.length))
                        message.credentials = [];
                    message.credentials.push($root.mesos.Credential.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Credentials message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Credentials
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Credentials} Credentials
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Credentials.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Credentials message.
         * @function verify
         * @memberof mesos.Credentials
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Credentials.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.credentials != null && message.hasOwnProperty("credentials")) {
                if (!Array.isArray(message.credentials))
                    return "credentials: array expected";
                for (let i = 0; i < message.credentials.length; ++i) {
                    let error = $root.mesos.Credential.verify(message.credentials[i]);
                    if (error)
                        return "credentials." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Credentials message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Credentials
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Credentials} Credentials
         */
        Credentials.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Credentials)
                return object;
            let message = new $root.mesos.Credentials();
            if (object.credentials) {
                if (!Array.isArray(object.credentials))
                    throw TypeError(".mesos.Credentials.credentials: array expected");
                message.credentials = [];
                for (let i = 0; i < object.credentials.length; ++i) {
                    if (typeof object.credentials[i] !== "object")
                        throw TypeError(".mesos.Credentials.credentials: object expected");
                    message.credentials[i] = $root.mesos.Credential.fromObject(object.credentials[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Credentials message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Credentials
         * @static
         * @param {mesos.Credentials} message Credentials
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Credentials.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.credentials = [];
            if (message.credentials && message.credentials.length) {
                object.credentials = [];
                for (let j = 0; j < message.credentials.length; ++j)
                    object.credentials[j] = $root.mesos.Credential.toObject(message.credentials[j], options);
            }
            return object;
        };

        /**
         * Converts this Credentials to JSON.
         * @function toJSON
         * @memberof mesos.Credentials
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Credentials.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Credentials;
    })();

    mesos.RateLimit = (function() {

        /**
         * Properties of a RateLimit.
         * @memberof mesos
         * @interface IRateLimit
         * @property {number} [qps] RateLimit qps
         * @property {string} principal RateLimit principal
         * @property {number} [capacity] RateLimit capacity
         */

        /**
         * Constructs a new RateLimit.
         * @memberof mesos
         * @classdesc Rate (queries per second, QPS) limit for messages from a framework to master.
         * Strictly speaking they are the combined rate from all frameworks of the same
         * principal.
         * @constructor
         * @param {mesos.IRateLimit=} [properties] Properties to set
         */
        function RateLimit(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RateLimit qps.
         * @member {number}qps
         * @memberof mesos.RateLimit
         * @instance
         */
        RateLimit.prototype.qps = 0;

        /**
         * RateLimit principal.
         * @member {string}principal
         * @memberof mesos.RateLimit
         * @instance
         */
        RateLimit.prototype.principal = "";

        /**
         * RateLimit capacity.
         * @member {number}capacity
         * @memberof mesos.RateLimit
         * @instance
         */
        RateLimit.prototype.capacity = 0;

        /**
         * Creates a new RateLimit instance using the specified properties.
         * @function create
         * @memberof mesos.RateLimit
         * @static
         * @param {mesos.IRateLimit=} [properties] Properties to set
         * @returns {mesos.RateLimit} RateLimit instance
         */
        RateLimit.create = function create(properties) {
            return new RateLimit(properties);
        };

        /**
         * Encodes the specified RateLimit message. Does not implicitly {@link mesos.RateLimit.verify|verify} messages.
         * @function encode
         * @memberof mesos.RateLimit
         * @static
         * @param {mesos.IRateLimit} message RateLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RateLimit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.qps != null && message.hasOwnProperty("qps"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.qps);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.principal);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.capacity);
            return writer;
        };

        /**
         * Encodes the specified RateLimit message, length delimited. Does not implicitly {@link mesos.RateLimit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.RateLimit
         * @static
         * @param {mesos.IRateLimit} message RateLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RateLimit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RateLimit message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.RateLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.RateLimit} RateLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RateLimit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.RateLimit();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.qps = reader.double();
                    break;
                case 2:
                    message.principal = reader.string();
                    break;
                case 3:
                    message.capacity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("principal"))
                throw $util.ProtocolError("missing required 'principal'", { instance: message });
            return message;
        };

        /**
         * Decodes a RateLimit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.RateLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.RateLimit} RateLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RateLimit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RateLimit message.
         * @function verify
         * @memberof mesos.RateLimit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RateLimit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.qps != null && message.hasOwnProperty("qps"))
                if (typeof message.qps !== "number")
                    return "qps: number expected";
            if (!$util.isString(message.principal))
                return "principal: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity))
                    return "capacity: integer expected";
            return null;
        };

        /**
         * Creates a RateLimit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.RateLimit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.RateLimit} RateLimit
         */
        RateLimit.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.RateLimit)
                return object;
            let message = new $root.mesos.RateLimit();
            if (object.qps != null)
                message.qps = Number(object.qps);
            if (object.principal != null)
                message.principal = String(object.principal);
            if (object.capacity != null)
                message.capacity = object.capacity >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a RateLimit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.RateLimit
         * @static
         * @param {mesos.RateLimit} message RateLimit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RateLimit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.qps = 0;
                object.principal = "";
                object.capacity = 0;
            }
            if (message.qps != null && message.hasOwnProperty("qps"))
                object.qps = options.json && !isFinite(message.qps) ? String(message.qps) : message.qps;
            if (message.principal != null && message.hasOwnProperty("principal"))
                object.principal = message.principal;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                object.capacity = message.capacity;
            return object;
        };

        /**
         * Converts this RateLimit to JSON.
         * @function toJSON
         * @memberof mesos.RateLimit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RateLimit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RateLimit;
    })();

    mesos.RateLimits = (function() {

        /**
         * Properties of a RateLimits.
         * @memberof mesos
         * @interface IRateLimits
         * @property {Array.<mesos.IRateLimit>} [limits] RateLimits limits
         * @property {number} [aggregateDefaultQps] RateLimits aggregateDefaultQps
         * @property {number} [aggregateDefaultCapacity] RateLimits aggregateDefaultCapacity
         */

        /**
         * Constructs a new RateLimits.
         * @memberof mesos
         * @classdesc Collection of RateLimit.
         * Frameworks without rate limits defined here are not throttled unless
         * 'aggregate_default_qps' is specified.
         * @constructor
         * @param {mesos.IRateLimits=} [properties] Properties to set
         */
        function RateLimits(properties) {
            this.limits = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RateLimits limits.
         * @member {Array.<mesos.IRateLimit>}limits
         * @memberof mesos.RateLimits
         * @instance
         */
        RateLimits.prototype.limits = $util.emptyArray;

        /**
         * RateLimits aggregateDefaultQps.
         * @member {number}aggregateDefaultQps
         * @memberof mesos.RateLimits
         * @instance
         */
        RateLimits.prototype.aggregateDefaultQps = 0;

        /**
         * RateLimits aggregateDefaultCapacity.
         * @member {number}aggregateDefaultCapacity
         * @memberof mesos.RateLimits
         * @instance
         */
        RateLimits.prototype.aggregateDefaultCapacity = 0;

        /**
         * Creates a new RateLimits instance using the specified properties.
         * @function create
         * @memberof mesos.RateLimits
         * @static
         * @param {mesos.IRateLimits=} [properties] Properties to set
         * @returns {mesos.RateLimits} RateLimits instance
         */
        RateLimits.create = function create(properties) {
            return new RateLimits(properties);
        };

        /**
         * Encodes the specified RateLimits message. Does not implicitly {@link mesos.RateLimits.verify|verify} messages.
         * @function encode
         * @memberof mesos.RateLimits
         * @static
         * @param {mesos.IRateLimits} message RateLimits message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RateLimits.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.limits != null && message.limits.length)
                for (let i = 0; i < message.limits.length; ++i)
                    $root.mesos.RateLimit.encode(message.limits[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.aggregateDefaultQps != null && message.hasOwnProperty("aggregateDefaultQps"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.aggregateDefaultQps);
            if (message.aggregateDefaultCapacity != null && message.hasOwnProperty("aggregateDefaultCapacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.aggregateDefaultCapacity);
            return writer;
        };

        /**
         * Encodes the specified RateLimits message, length delimited. Does not implicitly {@link mesos.RateLimits.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.RateLimits
         * @static
         * @param {mesos.IRateLimits} message RateLimits message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RateLimits.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RateLimits message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.RateLimits
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.RateLimits} RateLimits
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RateLimits.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.RateLimits();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.limits && message.limits.length))
                        message.limits = [];
                    message.limits.push($root.mesos.RateLimit.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.aggregateDefaultQps = reader.double();
                    break;
                case 3:
                    message.aggregateDefaultCapacity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RateLimits message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.RateLimits
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.RateLimits} RateLimits
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RateLimits.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RateLimits message.
         * @function verify
         * @memberof mesos.RateLimits
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RateLimits.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.limits != null && message.hasOwnProperty("limits")) {
                if (!Array.isArray(message.limits))
                    return "limits: array expected";
                for (let i = 0; i < message.limits.length; ++i) {
                    let error = $root.mesos.RateLimit.verify(message.limits[i]);
                    if (error)
                        return "limits." + error;
                }
            }
            if (message.aggregateDefaultQps != null && message.hasOwnProperty("aggregateDefaultQps"))
                if (typeof message.aggregateDefaultQps !== "number")
                    return "aggregateDefaultQps: number expected";
            if (message.aggregateDefaultCapacity != null && message.hasOwnProperty("aggregateDefaultCapacity"))
                if (!$util.isInteger(message.aggregateDefaultCapacity))
                    return "aggregateDefaultCapacity: integer expected";
            return null;
        };

        /**
         * Creates a RateLimits message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.RateLimits
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.RateLimits} RateLimits
         */
        RateLimits.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.RateLimits)
                return object;
            let message = new $root.mesos.RateLimits();
            if (object.limits) {
                if (!Array.isArray(object.limits))
                    throw TypeError(".mesos.RateLimits.limits: array expected");
                message.limits = [];
                for (let i = 0; i < object.limits.length; ++i) {
                    if (typeof object.limits[i] !== "object")
                        throw TypeError(".mesos.RateLimits.limits: object expected");
                    message.limits[i] = $root.mesos.RateLimit.fromObject(object.limits[i]);
                }
            }
            if (object.aggregateDefaultQps != null)
                message.aggregateDefaultQps = Number(object.aggregateDefaultQps);
            if (object.aggregateDefaultCapacity != null)
                message.aggregateDefaultCapacity = object.aggregateDefaultCapacity >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a RateLimits message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.RateLimits
         * @static
         * @param {mesos.RateLimits} message RateLimits
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RateLimits.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.limits = [];
            if (options.defaults) {
                object.aggregateDefaultQps = 0;
                object.aggregateDefaultCapacity = 0;
            }
            if (message.limits && message.limits.length) {
                object.limits = [];
                for (let j = 0; j < message.limits.length; ++j)
                    object.limits[j] = $root.mesos.RateLimit.toObject(message.limits[j], options);
            }
            if (message.aggregateDefaultQps != null && message.hasOwnProperty("aggregateDefaultQps"))
                object.aggregateDefaultQps = options.json && !isFinite(message.aggregateDefaultQps) ? String(message.aggregateDefaultQps) : message.aggregateDefaultQps;
            if (message.aggregateDefaultCapacity != null && message.hasOwnProperty("aggregateDefaultCapacity"))
                object.aggregateDefaultCapacity = message.aggregateDefaultCapacity;
            return object;
        };

        /**
         * Converts this RateLimits to JSON.
         * @function toJSON
         * @memberof mesos.RateLimits
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RateLimits.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RateLimits;
    })();

    mesos.Image = (function() {

        /**
         * Properties of an Image.
         * @memberof mesos
         * @interface IImage
         * @property {mesos.Image.Type} type Image type
         * @property {mesos.Image.IAppc} [appc] Image appc
         * @property {mesos.Image.IDocker} [docker] Image docker
         * @property {boolean} [cached] Image cached
         */

        /**
         * Constructs a new Image.
         * @memberof mesos
         * @classdesc Describe an image used by tasks or executors. Note that it's only
         * for tasks or executors launched by MesosContainerizer currently.
         * @constructor
         * @param {mesos.IImage=} [properties] Properties to set
         */
        function Image(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Image type.
         * @member {mesos.Image.Type}type
         * @memberof mesos.Image
         * @instance
         */
        Image.prototype.type = 1;

        /**
         * Image appc.
         * @member {(mesos.Image.IAppc|null|undefined)}appc
         * @memberof mesos.Image
         * @instance
         */
        Image.prototype.appc = null;

        /**
         * Image docker.
         * @member {(mesos.Image.IDocker|null|undefined)}docker
         * @memberof mesos.Image
         * @instance
         */
        Image.prototype.docker = null;

        /**
         * Image cached.
         * @member {boolean}cached
         * @memberof mesos.Image
         * @instance
         */
        Image.prototype.cached = true;

        /**
         * Creates a new Image instance using the specified properties.
         * @function create
         * @memberof mesos.Image
         * @static
         * @param {mesos.IImage=} [properties] Properties to set
         * @returns {mesos.Image} Image instance
         */
        Image.create = function create(properties) {
            return new Image(properties);
        };

        /**
         * Encodes the specified Image message. Does not implicitly {@link mesos.Image.verify|verify} messages.
         * @function encode
         * @memberof mesos.Image
         * @static
         * @param {mesos.IImage} message Image message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Image.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.appc != null && message.hasOwnProperty("appc"))
                $root.mesos.Image.Appc.encode(message.appc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.docker != null && message.hasOwnProperty("docker"))
                $root.mesos.Image.Docker.encode(message.docker, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.cached != null && message.hasOwnProperty("cached"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.cached);
            return writer;
        };

        /**
         * Encodes the specified Image message, length delimited. Does not implicitly {@link mesos.Image.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Image
         * @static
         * @param {mesos.IImage} message Image message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Image.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Image message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Image
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Image} Image
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Image.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Image();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.appc = $root.mesos.Image.Appc.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.docker = $root.mesos.Image.Docker.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.cached = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes an Image message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Image
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Image} Image
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Image.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Image message.
         * @function verify
         * @memberof mesos.Image
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Image.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
                break;
            }
            if (message.appc != null && message.hasOwnProperty("appc")) {
                let error = $root.mesos.Image.Appc.verify(message.appc);
                if (error)
                    return "appc." + error;
            }
            if (message.docker != null && message.hasOwnProperty("docker")) {
                error = $root.mesos.Image.Docker.verify(message.docker);
                if (error)
                    return "docker." + error;
            }
            if (message.cached != null && message.hasOwnProperty("cached"))
                if (typeof message.cached !== "boolean")
                    return "cached: boolean expected";
            return null;
        };

        /**
         * Creates an Image message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Image
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Image} Image
         */
        Image.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Image)
                return object;
            let message = new $root.mesos.Image();
            switch (object.type) {
            case "APPC":
            case 1:
                message.type = 1;
                break;
            case "DOCKER":
            case 2:
                message.type = 2;
                break;
            }
            if (object.appc != null) {
                if (typeof object.appc !== "object")
                    throw TypeError(".mesos.Image.appc: object expected");
                message.appc = $root.mesos.Image.Appc.fromObject(object.appc);
            }
            if (object.docker != null) {
                if (typeof object.docker !== "object")
                    throw TypeError(".mesos.Image.docker: object expected");
                message.docker = $root.mesos.Image.Docker.fromObject(object.docker);
            }
            if (object.cached != null)
                message.cached = Boolean(object.cached);
            return message;
        };

        /**
         * Creates a plain object from an Image message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Image
         * @static
         * @param {mesos.Image} message Image
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Image.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "APPC" : 1;
                object.appc = null;
                object.docker = null;
                object.cached = true;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.Image.Type[message.type] : message.type;
            if (message.appc != null && message.hasOwnProperty("appc"))
                object.appc = $root.mesos.Image.Appc.toObject(message.appc, options);
            if (message.docker != null && message.hasOwnProperty("docker"))
                object.docker = $root.mesos.Image.Docker.toObject(message.docker, options);
            if (message.cached != null && message.hasOwnProperty("cached"))
                object.cached = message.cached;
            return object;
        };

        /**
         * Converts this Image to JSON.
         * @function toJSON
         * @memberof mesos.Image
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Image.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} APPC=1 APPC value
         * @property {number} DOCKER=2 DOCKER value
         */
        Image.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "APPC"] = 1;
            values[valuesById[2] = "DOCKER"] = 2;
            return values;
        })();

        Image.Appc = (function() {

            /**
             * Properties of an Appc.
             * @memberof mesos.Image
             * @interface IAppc
             * @property {string} name Appc name
             * @property {string} [id] Appc id
             * @property {mesos.ILabels} [labels] Appc labels
             */

            /**
             * Constructs a new Appc.
             * @memberof mesos.Image
             * @classdesc Represents an Appc.
             * @constructor
             * @param {mesos.Image.IAppc=} [properties] Properties to set
             */
            function Appc(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Appc name.
             * @member {string}name
             * @memberof mesos.Image.Appc
             * @instance
             */
            Appc.prototype.name = "";

            /**
             * Appc id.
             * @member {string}id
             * @memberof mesos.Image.Appc
             * @instance
             */
            Appc.prototype.id = "";

            /**
             * Appc labels.
             * @member {(mesos.ILabels|null|undefined)}labels
             * @memberof mesos.Image.Appc
             * @instance
             */
            Appc.prototype.labels = null;

            /**
             * Creates a new Appc instance using the specified properties.
             * @function create
             * @memberof mesos.Image.Appc
             * @static
             * @param {mesos.Image.IAppc=} [properties] Properties to set
             * @returns {mesos.Image.Appc} Appc instance
             */
            Appc.create = function create(properties) {
                return new Appc(properties);
            };

            /**
             * Encodes the specified Appc message. Does not implicitly {@link mesos.Image.Appc.verify|verify} messages.
             * @function encode
             * @memberof mesos.Image.Appc
             * @static
             * @param {mesos.Image.IAppc} message Appc message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Appc.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.labels != null && message.hasOwnProperty("labels"))
                    $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Appc message, length delimited. Does not implicitly {@link mesos.Image.Appc.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Image.Appc
             * @static
             * @param {mesos.Image.IAppc} message Appc message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Appc.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Appc message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Image.Appc
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Image.Appc} Appc
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Appc.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Image.Appc();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    case 3:
                        message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };

            /**
             * Decodes an Appc message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Image.Appc
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Image.Appc} Appc
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Appc.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Appc message.
             * @function verify
             * @memberof mesos.Image.Appc
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Appc.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    let error = $root.mesos.Labels.verify(message.labels);
                    if (error)
                        return "labels." + error;
                }
                return null;
            };

            /**
             * Creates an Appc message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Image.Appc
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Image.Appc} Appc
             */
            Appc.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Image.Appc)
                    return object;
                let message = new $root.mesos.Image.Appc();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.labels != null) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".mesos.Image.Appc.labels: object expected");
                    message.labels = $root.mesos.Labels.fromObject(object.labels);
                }
                return message;
            };

            /**
             * Creates a plain object from an Appc message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Image.Appc
             * @static
             * @param {mesos.Image.Appc} message Appc
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Appc.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.id = "";
                    object.labels = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.labels != null && message.hasOwnProperty("labels"))
                    object.labels = $root.mesos.Labels.toObject(message.labels, options);
                return object;
            };

            /**
             * Converts this Appc to JSON.
             * @function toJSON
             * @memberof mesos.Image.Appc
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Appc.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Appc;
        })();

        Image.Docker = (function() {

            /**
             * Properties of a Docker.
             * @memberof mesos.Image
             * @interface IDocker
             * @property {string} name Docker name
             * @property {mesos.ICredential} [credential] Docker credential
             */

            /**
             * Constructs a new Docker.
             * @memberof mesos.Image
             * @classdesc Represents a Docker.
             * @constructor
             * @param {mesos.Image.IDocker=} [properties] Properties to set
             */
            function Docker(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Docker name.
             * @member {string}name
             * @memberof mesos.Image.Docker
             * @instance
             */
            Docker.prototype.name = "";

            /**
             * Docker credential.
             * @member {(mesos.ICredential|null|undefined)}credential
             * @memberof mesos.Image.Docker
             * @instance
             */
            Docker.prototype.credential = null;

            /**
             * Creates a new Docker instance using the specified properties.
             * @function create
             * @memberof mesos.Image.Docker
             * @static
             * @param {mesos.Image.IDocker=} [properties] Properties to set
             * @returns {mesos.Image.Docker} Docker instance
             */
            Docker.create = function create(properties) {
                return new Docker(properties);
            };

            /**
             * Encodes the specified Docker message. Does not implicitly {@link mesos.Image.Docker.verify|verify} messages.
             * @function encode
             * @memberof mesos.Image.Docker
             * @static
             * @param {mesos.Image.IDocker} message Docker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Docker.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.credential != null && message.hasOwnProperty("credential"))
                    $root.mesos.Credential.encode(message.credential, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Docker message, length delimited. Does not implicitly {@link mesos.Image.Docker.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Image.Docker
             * @static
             * @param {mesos.Image.IDocker} message Docker message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Docker.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Docker message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Image.Docker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Image.Docker} Docker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Docker.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Image.Docker();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.credential = $root.mesos.Credential.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                return message;
            };

            /**
             * Decodes a Docker message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Image.Docker
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Image.Docker} Docker
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Docker.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Docker message.
             * @function verify
             * @memberof mesos.Image.Docker
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Docker.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (message.credential != null && message.hasOwnProperty("credential")) {
                    let error = $root.mesos.Credential.verify(message.credential);
                    if (error)
                        return "credential." + error;
                }
                return null;
            };

            /**
             * Creates a Docker message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Image.Docker
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Image.Docker} Docker
             */
            Docker.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Image.Docker)
                    return object;
                let message = new $root.mesos.Image.Docker();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.credential != null) {
                    if (typeof object.credential !== "object")
                        throw TypeError(".mesos.Image.Docker.credential: object expected");
                    message.credential = $root.mesos.Credential.fromObject(object.credential);
                }
                return message;
            };

            /**
             * Creates a plain object from a Docker message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Image.Docker
             * @static
             * @param {mesos.Image.Docker} message Docker
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Docker.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.credential = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.credential != null && message.hasOwnProperty("credential"))
                    object.credential = $root.mesos.Credential.toObject(message.credential, options);
                return object;
            };

            /**
             * Converts this Docker to JSON.
             * @function toJSON
             * @memberof mesos.Image.Docker
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Docker.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Docker;
        })();

        return Image;
    })();

    mesos.Volume = (function() {

        /**
         * Properties of a Volume.
         * @memberof mesos
         * @interface IVolume
         * @property {mesos.Volume.Mode} mode Volume mode
         * @property {string} containerPath Volume containerPath
         * @property {string} [hostPath] Volume hostPath
         * @property {mesos.IImage} [image] Volume image
         * @property {mesos.Volume.ISource} [source] Volume source
         */

        /**
         * Constructs a new Volume.
         * @memberof mesos
         * @classdesc Describes a volume mapping either from host to container or vice
         * versa. Both paths can either refer to a directory or a file.
         * @constructor
         * @param {mesos.IVolume=} [properties] Properties to set
         */
        function Volume(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Volume mode.
         * @member {mesos.Volume.Mode}mode
         * @memberof mesos.Volume
         * @instance
         */
        Volume.prototype.mode = 1;

        /**
         * Volume containerPath.
         * @member {string}containerPath
         * @memberof mesos.Volume
         * @instance
         */
        Volume.prototype.containerPath = "";

        /**
         * Volume hostPath.
         * @member {string}hostPath
         * @memberof mesos.Volume
         * @instance
         */
        Volume.prototype.hostPath = "";

        /**
         * Volume image.
         * @member {(mesos.IImage|null|undefined)}image
         * @memberof mesos.Volume
         * @instance
         */
        Volume.prototype.image = null;

        /**
         * Volume source.
         * @member {(mesos.Volume.ISource|null|undefined)}source
         * @memberof mesos.Volume
         * @instance
         */
        Volume.prototype.source = null;

        /**
         * Creates a new Volume instance using the specified properties.
         * @function create
         * @memberof mesos.Volume
         * @static
         * @param {mesos.IVolume=} [properties] Properties to set
         * @returns {mesos.Volume} Volume instance
         */
        Volume.create = function create(properties) {
            return new Volume(properties);
        };

        /**
         * Encodes the specified Volume message. Does not implicitly {@link mesos.Volume.verify|verify} messages.
         * @function encode
         * @memberof mesos.Volume
         * @static
         * @param {mesos.IVolume} message Volume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Volume.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.containerPath);
            if (message.hostPath != null && message.hasOwnProperty("hostPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hostPath);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mode);
            if (message.image != null && message.hasOwnProperty("image"))
                $root.mesos.Image.encode(message.image, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                $root.mesos.Volume.Source.encode(message.source, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Volume message, length delimited. Does not implicitly {@link mesos.Volume.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Volume
         * @static
         * @param {mesos.IVolume} message Volume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Volume.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Volume message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Volume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Volume} Volume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Volume.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Volume();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.mode = reader.int32();
                    break;
                case 1:
                    message.containerPath = reader.string();
                    break;
                case 2:
                    message.hostPath = reader.string();
                    break;
                case 4:
                    message.image = $root.mesos.Image.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.source = $root.mesos.Volume.Source.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("mode"))
                throw $util.ProtocolError("missing required 'mode'", { instance: message });
            if (!message.hasOwnProperty("containerPath"))
                throw $util.ProtocolError("missing required 'containerPath'", { instance: message });
            return message;
        };

        /**
         * Decodes a Volume message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Volume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Volume} Volume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Volume.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Volume message.
         * @function verify
         * @memberof mesos.Volume
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Volume.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.mode) {
            default:
                return "mode: enum value expected";
            case 1:
            case 2:
                break;
            }
            if (!$util.isString(message.containerPath))
                return "containerPath: string expected";
            if (message.hostPath != null && message.hasOwnProperty("hostPath"))
                if (!$util.isString(message.hostPath))
                    return "hostPath: string expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                let error = $root.mesos.Image.verify(message.image);
                if (error)
                    return "image." + error;
            }
            if (message.source != null && message.hasOwnProperty("source")) {
                error = $root.mesos.Volume.Source.verify(message.source);
                if (error)
                    return "source." + error;
            }
            return null;
        };

        /**
         * Creates a Volume message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Volume
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Volume} Volume
         */
        Volume.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Volume)
                return object;
            let message = new $root.mesos.Volume();
            switch (object.mode) {
            case "RW":
            case 1:
                message.mode = 1;
                break;
            case "RO":
            case 2:
                message.mode = 2;
                break;
            }
            if (object.containerPath != null)
                message.containerPath = String(object.containerPath);
            if (object.hostPath != null)
                message.hostPath = String(object.hostPath);
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".mesos.Volume.image: object expected");
                message.image = $root.mesos.Image.fromObject(object.image);
            }
            if (object.source != null) {
                if (typeof object.source !== "object")
                    throw TypeError(".mesos.Volume.source: object expected");
                message.source = $root.mesos.Volume.Source.fromObject(object.source);
            }
            return message;
        };

        /**
         * Creates a plain object from a Volume message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Volume
         * @static
         * @param {mesos.Volume} message Volume
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Volume.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.containerPath = "";
                object.hostPath = "";
                object.mode = options.enums === String ? "RW" : 1;
                object.image = null;
                object.source = null;
            }
            if (message.containerPath != null && message.hasOwnProperty("containerPath"))
                object.containerPath = message.containerPath;
            if (message.hostPath != null && message.hasOwnProperty("hostPath"))
                object.hostPath = message.hostPath;
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = options.enums === String ? $root.mesos.Volume.Mode[message.mode] : message.mode;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.mesos.Image.toObject(message.image, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = $root.mesos.Volume.Source.toObject(message.source, options);
            return object;
        };

        /**
         * Converts this Volume to JSON.
         * @function toJSON
         * @memberof mesos.Volume
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Volume.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Mode enum.
         * @enum {string}
         * @property {number} RW=1 RW value
         * @property {number} RO=2 RO value
         */
        Volume.Mode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "RW"] = 1;
            values[valuesById[2] = "RO"] = 2;
            return values;
        })();

        Volume.Source = (function() {

            /**
             * Properties of a Source.
             * @memberof mesos.Volume
             * @interface ISource
             * @property {mesos.Volume.Source.Type} [type] Source type
             * @property {mesos.Volume.Source.IDockerVolume} [dockerVolume] Source dockerVolume
             * @property {mesos.Volume.Source.ISandboxPath} [sandboxPath] Source sandboxPath
             */

            /**
             * Constructs a new Source.
             * @memberof mesos.Volume
             * @classdesc Represents a Source.
             * @constructor
             * @param {mesos.Volume.ISource=} [properties] Properties to set
             */
            function Source(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Source type.
             * @member {mesos.Volume.Source.Type}type
             * @memberof mesos.Volume.Source
             * @instance
             */
            Source.prototype.type = 0;

            /**
             * Source dockerVolume.
             * @member {(mesos.Volume.Source.IDockerVolume|null|undefined)}dockerVolume
             * @memberof mesos.Volume.Source
             * @instance
             */
            Source.prototype.dockerVolume = null;

            /**
             * Source sandboxPath.
             * @member {(mesos.Volume.Source.ISandboxPath|null|undefined)}sandboxPath
             * @memberof mesos.Volume.Source
             * @instance
             */
            Source.prototype.sandboxPath = null;

            /**
             * Creates a new Source instance using the specified properties.
             * @function create
             * @memberof mesos.Volume.Source
             * @static
             * @param {mesos.Volume.ISource=} [properties] Properties to set
             * @returns {mesos.Volume.Source} Source instance
             */
            Source.create = function create(properties) {
                return new Source(properties);
            };

            /**
             * Encodes the specified Source message. Does not implicitly {@link mesos.Volume.Source.verify|verify} messages.
             * @function encode
             * @memberof mesos.Volume.Source
             * @static
             * @param {mesos.Volume.ISource} message Source message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Source.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.dockerVolume != null && message.hasOwnProperty("dockerVolume"))
                    $root.mesos.Volume.Source.DockerVolume.encode(message.dockerVolume, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.sandboxPath != null && message.hasOwnProperty("sandboxPath"))
                    $root.mesos.Volume.Source.SandboxPath.encode(message.sandboxPath, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Source message, length delimited. Does not implicitly {@link mesos.Volume.Source.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.Volume.Source
             * @static
             * @param {mesos.Volume.ISource} message Source message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Source.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Source message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.Volume.Source
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.Volume.Source} Source
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Source.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Volume.Source();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.dockerVolume = $root.mesos.Volume.Source.DockerVolume.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.sandboxPath = $root.mesos.Volume.Source.SandboxPath.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Source message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.Volume.Source
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.Volume.Source} Source
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Source.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Source message.
             * @function verify
             * @memberof mesos.Volume.Source
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Source.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.dockerVolume != null && message.hasOwnProperty("dockerVolume")) {
                    let error = $root.mesos.Volume.Source.DockerVolume.verify(message.dockerVolume);
                    if (error)
                        return "dockerVolume." + error;
                }
                if (message.sandboxPath != null && message.hasOwnProperty("sandboxPath")) {
                    error = $root.mesos.Volume.Source.SandboxPath.verify(message.sandboxPath);
                    if (error)
                        return "sandboxPath." + error;
                }
                return null;
            };

            /**
             * Creates a Source message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.Volume.Source
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.Volume.Source} Source
             */
            Source.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.Volume.Source)
                    return object;
                let message = new $root.mesos.Volume.Source();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "DOCKER_VOLUME":
                case 1:
                    message.type = 1;
                    break;
                case "SANDBOX_PATH":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.dockerVolume != null) {
                    if (typeof object.dockerVolume !== "object")
                        throw TypeError(".mesos.Volume.Source.dockerVolume: object expected");
                    message.dockerVolume = $root.mesos.Volume.Source.DockerVolume.fromObject(object.dockerVolume);
                }
                if (object.sandboxPath != null) {
                    if (typeof object.sandboxPath !== "object")
                        throw TypeError(".mesos.Volume.Source.sandboxPath: object expected");
                    message.sandboxPath = $root.mesos.Volume.Source.SandboxPath.fromObject(object.sandboxPath);
                }
                return message;
            };

            /**
             * Creates a plain object from a Source message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.Volume.Source
             * @static
             * @param {mesos.Volume.Source} message Source
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Source.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.dockerVolume = null;
                    object.sandboxPath = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.Volume.Source.Type[message.type] : message.type;
                if (message.dockerVolume != null && message.hasOwnProperty("dockerVolume"))
                    object.dockerVolume = $root.mesos.Volume.Source.DockerVolume.toObject(message.dockerVolume, options);
                if (message.sandboxPath != null && message.hasOwnProperty("sandboxPath"))
                    object.sandboxPath = $root.mesos.Volume.Source.SandboxPath.toObject(message.sandboxPath, options);
                return object;
            };

            /**
             * Converts this Source to JSON.
             * @function toJSON
             * @memberof mesos.Volume.Source
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Source.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} DOCKER_VOLUME=1 DOCKER_VOLUME value
             * @property {number} SANDBOX_PATH=2 SANDBOX_PATH value
             */
            Source.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "DOCKER_VOLUME"] = 1;
                values[valuesById[2] = "SANDBOX_PATH"] = 2;
                return values;
            })();

            Source.DockerVolume = (function() {

                /**
                 * Properties of a DockerVolume.
                 * @memberof mesos.Volume.Source
                 * @interface IDockerVolume
                 * @property {string} [driver] DockerVolume driver
                 * @property {string} name DockerVolume name
                 * @property {mesos.IParameters} [driverOptions] DockerVolume driverOptions
                 */

                /**
                 * Constructs a new DockerVolume.
                 * @memberof mesos.Volume.Source
                 * @classdesc Represents a DockerVolume.
                 * @constructor
                 * @param {mesos.Volume.Source.IDockerVolume=} [properties] Properties to set
                 */
                function DockerVolume(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DockerVolume driver.
                 * @member {string}driver
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @instance
                 */
                DockerVolume.prototype.driver = "";

                /**
                 * DockerVolume name.
                 * @member {string}name
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @instance
                 */
                DockerVolume.prototype.name = "";

                /**
                 * DockerVolume driverOptions.
                 * @member {(mesos.IParameters|null|undefined)}driverOptions
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @instance
                 */
                DockerVolume.prototype.driverOptions = null;

                /**
                 * Creates a new DockerVolume instance using the specified properties.
                 * @function create
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {mesos.Volume.Source.IDockerVolume=} [properties] Properties to set
                 * @returns {mesos.Volume.Source.DockerVolume} DockerVolume instance
                 */
                DockerVolume.create = function create(properties) {
                    return new DockerVolume(properties);
                };

                /**
                 * Encodes the specified DockerVolume message. Does not implicitly {@link mesos.Volume.Source.DockerVolume.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {mesos.Volume.Source.IDockerVolume} message DockerVolume message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DockerVolume.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.driver != null && message.hasOwnProperty("driver"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.driver);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.driverOptions != null && message.hasOwnProperty("driverOptions"))
                        $root.mesos.Parameters.encode(message.driverOptions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DockerVolume message, length delimited. Does not implicitly {@link mesos.Volume.Source.DockerVolume.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {mesos.Volume.Source.IDockerVolume} message DockerVolume message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DockerVolume.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DockerVolume message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Volume.Source.DockerVolume} DockerVolume
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DockerVolume.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Volume.Source.DockerVolume();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.driver = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.driverOptions = $root.mesos.Parameters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("name"))
                        throw $util.ProtocolError("missing required 'name'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a DockerVolume message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Volume.Source.DockerVolume} DockerVolume
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DockerVolume.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DockerVolume message.
                 * @function verify
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DockerVolume.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.driver != null && message.hasOwnProperty("driver"))
                        if (!$util.isString(message.driver))
                            return "driver: string expected";
                    if (!$util.isString(message.name))
                        return "name: string expected";
                    if (message.driverOptions != null && message.hasOwnProperty("driverOptions")) {
                        let error = $root.mesos.Parameters.verify(message.driverOptions);
                        if (error)
                            return "driverOptions." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DockerVolume message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Volume.Source.DockerVolume} DockerVolume
                 */
                DockerVolume.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Volume.Source.DockerVolume)
                        return object;
                    let message = new $root.mesos.Volume.Source.DockerVolume();
                    if (object.driver != null)
                        message.driver = String(object.driver);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.driverOptions != null) {
                        if (typeof object.driverOptions !== "object")
                            throw TypeError(".mesos.Volume.Source.DockerVolume.driverOptions: object expected");
                        message.driverOptions = $root.mesos.Parameters.fromObject(object.driverOptions);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DockerVolume message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @static
                 * @param {mesos.Volume.Source.DockerVolume} message DockerVolume
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DockerVolume.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.driver = "";
                        object.name = "";
                        object.driverOptions = null;
                    }
                    if (message.driver != null && message.hasOwnProperty("driver"))
                        object.driver = message.driver;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.driverOptions != null && message.hasOwnProperty("driverOptions"))
                        object.driverOptions = $root.mesos.Parameters.toObject(message.driverOptions, options);
                    return object;
                };

                /**
                 * Converts this DockerVolume to JSON.
                 * @function toJSON
                 * @memberof mesos.Volume.Source.DockerVolume
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DockerVolume.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DockerVolume;
            })();

            Source.SandboxPath = (function() {

                /**
                 * Properties of a SandboxPath.
                 * @memberof mesos.Volume.Source
                 * @interface ISandboxPath
                 * @property {mesos.Volume.Source.SandboxPath.Type} [type] SandboxPath type
                 * @property {string} path SandboxPath path
                 */

                /**
                 * Constructs a new SandboxPath.
                 * @memberof mesos.Volume.Source
                 * @classdesc Represents a SandboxPath.
                 * @constructor
                 * @param {mesos.Volume.Source.ISandboxPath=} [properties] Properties to set
                 */
                function SandboxPath(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SandboxPath type.
                 * @member {mesos.Volume.Source.SandboxPath.Type}type
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @instance
                 */
                SandboxPath.prototype.type = 0;

                /**
                 * SandboxPath path.
                 * @member {string}path
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @instance
                 */
                SandboxPath.prototype.path = "";

                /**
                 * Creates a new SandboxPath instance using the specified properties.
                 * @function create
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {mesos.Volume.Source.ISandboxPath=} [properties] Properties to set
                 * @returns {mesos.Volume.Source.SandboxPath} SandboxPath instance
                 */
                SandboxPath.create = function create(properties) {
                    return new SandboxPath(properties);
                };

                /**
                 * Encodes the specified SandboxPath message. Does not implicitly {@link mesos.Volume.Source.SandboxPath.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {mesos.Volume.Source.ISandboxPath} message SandboxPath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SandboxPath.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                    return writer;
                };

                /**
                 * Encodes the specified SandboxPath message, length delimited. Does not implicitly {@link mesos.Volume.Source.SandboxPath.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {mesos.Volume.Source.ISandboxPath} message SandboxPath message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SandboxPath.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SandboxPath message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.Volume.Source.SandboxPath} SandboxPath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SandboxPath.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Volume.Source.SandboxPath();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.path = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("path"))
                        throw $util.ProtocolError("missing required 'path'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SandboxPath message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.Volume.Source.SandboxPath} SandboxPath
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SandboxPath.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SandboxPath message.
                 * @function verify
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SandboxPath.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (!$util.isString(message.path))
                        return "path: string expected";
                    return null;
                };

                /**
                 * Creates a SandboxPath message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.Volume.Source.SandboxPath} SandboxPath
                 */
                SandboxPath.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.Volume.Source.SandboxPath)
                        return object;
                    let message = new $root.mesos.Volume.Source.SandboxPath();
                    switch (object.type) {
                    case "UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.type = 1;
                        break;
                    case "PARENT":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.path != null)
                        message.path = String(object.path);
                    return message;
                };

                /**
                 * Creates a plain object from a SandboxPath message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @static
                 * @param {mesos.Volume.Source.SandboxPath} message SandboxPath
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SandboxPath.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "UNKNOWN" : 0;
                        object.path = "";
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.mesos.Volume.Source.SandboxPath.Type[message.type] : message.type;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    return object;
                };

                /**
                 * Converts this SandboxPath to JSON.
                 * @function toJSON
                 * @memberof mesos.Volume.Source.SandboxPath
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SandboxPath.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} SELF=1 SELF value
                 * @property {number} PARENT=2 PARENT value
                 */
                SandboxPath.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "SELF"] = 1;
                    values[valuesById[2] = "PARENT"] = 2;
                    return values;
                })();

                return SandboxPath;
            })();

            return Source;
        })();

        return Volume;
    })();

    mesos.NetworkInfo = (function() {

        /**
         * Properties of a NetworkInfo.
         * @memberof mesos
         * @interface INetworkInfo
         * @property {Array.<mesos.NetworkInfo.IIPAddress>} [ipAddresses] NetworkInfo ipAddresses
         * @property {string} [name] NetworkInfo name
         * @property {Array.<string>} [groups] NetworkInfo groups
         * @property {mesos.ILabels} [labels] NetworkInfo labels
         * @property {Array.<mesos.NetworkInfo.IPortMapping>} [portMappings] NetworkInfo portMappings
         */

        /**
         * Constructs a new NetworkInfo.
         * @memberof mesos
         * @classdesc Describes a network request from a framework as well as network resolution
         * provided by Mesos.
         * 
         * A framework may request the network isolator on the Agent to isolate the
         * container in a network namespace and create a virtual network interface.
         * The `NetworkInfo` message describes the properties of that virtual
         * interface, including the IP addresses and network isolation policy
         * (network group membership).
         * 
         * The NetworkInfo message is not interpreted by the Master or Agent and is
         * intended to be used by Agent and Master modules implementing network
         * isolation. If the modules are missing, the message is simply ignored. In
         * future, the task launch will fail if there is no module providing the
         * network isolation capabilities (MESOS-3390).
         * 
         * An executor, Agent, or an Agent module may append NetworkInfos inside
         * TaskStatus::container_status to provide information such as the container IP
         * address and isolation groups.
         * @constructor
         * @param {mesos.INetworkInfo=} [properties] Properties to set
         */
        function NetworkInfo(properties) {
            this.ipAddresses = [];
            this.groups = [];
            this.portMappings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkInfo ipAddresses.
         * @member {Array.<mesos.NetworkInfo.IIPAddress>}ipAddresses
         * @memberof mesos.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.ipAddresses = $util.emptyArray;

        /**
         * NetworkInfo name.
         * @member {string}name
         * @memberof mesos.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.name = "";

        /**
         * NetworkInfo groups.
         * @member {Array.<string>}groups
         * @memberof mesos.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.groups = $util.emptyArray;

        /**
         * NetworkInfo labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.labels = null;

        /**
         * NetworkInfo portMappings.
         * @member {Array.<mesos.NetworkInfo.IPortMapping>}portMappings
         * @memberof mesos.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.portMappings = $util.emptyArray;

        /**
         * Creates a new NetworkInfo instance using the specified properties.
         * @function create
         * @memberof mesos.NetworkInfo
         * @static
         * @param {mesos.INetworkInfo=} [properties] Properties to set
         * @returns {mesos.NetworkInfo} NetworkInfo instance
         */
        NetworkInfo.create = function create(properties) {
            return new NetworkInfo(properties);
        };

        /**
         * Encodes the specified NetworkInfo message. Does not implicitly {@link mesos.NetworkInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.NetworkInfo
         * @static
         * @param {mesos.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groups != null && message.groups.length)
                for (let i = 0; i < message.groups.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.groups[i]);
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.ipAddresses != null && message.ipAddresses.length)
                for (let i = 0; i < message.ipAddresses.length; ++i)
                    $root.mesos.NetworkInfo.IPAddress.encode(message.ipAddresses[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.portMappings != null && message.portMappings.length)
                for (let i = 0; i < message.portMappings.length; ++i)
                    $root.mesos.NetworkInfo.PortMapping.encode(message.portMappings[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NetworkInfo message, length delimited. Does not implicitly {@link mesos.NetworkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.NetworkInfo
         * @static
         * @param {mesos.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.NetworkInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5:
                    if (!(message.ipAddresses && message.ipAddresses.length))
                        message.ipAddresses = [];
                    message.ipAddresses.push($root.mesos.NetworkInfo.IPAddress.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.name = reader.string();
                    break;
                case 3:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push(reader.string());
                    break;
                case 4:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.portMappings && message.portMappings.length))
                        message.portMappings = [];
                    message.portMappings.push($root.mesos.NetworkInfo.PortMapping.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfo message.
         * @function verify
         * @memberof mesos.NetworkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ipAddresses != null && message.hasOwnProperty("ipAddresses")) {
                if (!Array.isArray(message.ipAddresses))
                    return "ipAddresses: array expected";
                for (let i = 0; i < message.ipAddresses.length; ++i) {
                    let error = $root.mesos.NetworkInfo.IPAddress.verify(message.ipAddresses[i]);
                    if (error)
                        return "ipAddresses." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.groups != null && message.hasOwnProperty("groups")) {
                if (!Array.isArray(message.groups))
                    return "groups: array expected";
                for (let i = 0; i < message.groups.length; ++i)
                    if (!$util.isString(message.groups[i]))
                        return "groups: string[] expected";
            }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            if (message.portMappings != null && message.hasOwnProperty("portMappings")) {
                if (!Array.isArray(message.portMappings))
                    return "portMappings: array expected";
                for (let i = 0; i < message.portMappings.length; ++i) {
                    error = $root.mesos.NetworkInfo.PortMapping.verify(message.portMappings[i]);
                    if (error)
                        return "portMappings." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NetworkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.NetworkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.NetworkInfo} NetworkInfo
         */
        NetworkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.NetworkInfo)
                return object;
            let message = new $root.mesos.NetworkInfo();
            if (object.ipAddresses) {
                if (!Array.isArray(object.ipAddresses))
                    throw TypeError(".mesos.NetworkInfo.ipAddresses: array expected");
                message.ipAddresses = [];
                for (let i = 0; i < object.ipAddresses.length; ++i) {
                    if (typeof object.ipAddresses[i] !== "object")
                        throw TypeError(".mesos.NetworkInfo.ipAddresses: object expected");
                    message.ipAddresses[i] = $root.mesos.NetworkInfo.IPAddress.fromObject(object.ipAddresses[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.groups) {
                if (!Array.isArray(object.groups))
                    throw TypeError(".mesos.NetworkInfo.groups: array expected");
                message.groups = [];
                for (let i = 0; i < object.groups.length; ++i)
                    message.groups[i] = String(object.groups[i]);
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.NetworkInfo.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            if (object.portMappings) {
                if (!Array.isArray(object.portMappings))
                    throw TypeError(".mesos.NetworkInfo.portMappings: array expected");
                message.portMappings = [];
                for (let i = 0; i < object.portMappings.length; ++i) {
                    if (typeof object.portMappings[i] !== "object")
                        throw TypeError(".mesos.NetworkInfo.portMappings: object expected");
                    message.portMappings[i] = $root.mesos.NetworkInfo.PortMapping.fromObject(object.portMappings[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NetworkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.NetworkInfo
         * @static
         * @param {mesos.NetworkInfo} message NetworkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.groups = [];
                object.ipAddresses = [];
                object.portMappings = [];
            }
            if (options.defaults) {
                object.labels = null;
                object.name = "";
            }
            if (message.groups && message.groups.length) {
                object.groups = [];
                for (let j = 0; j < message.groups.length; ++j)
                    object.groups[j] = message.groups[j];
            }
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            if (message.ipAddresses && message.ipAddresses.length) {
                object.ipAddresses = [];
                for (let j = 0; j < message.ipAddresses.length; ++j)
                    object.ipAddresses[j] = $root.mesos.NetworkInfo.IPAddress.toObject(message.ipAddresses[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.portMappings && message.portMappings.length) {
                object.portMappings = [];
                for (let j = 0; j < message.portMappings.length; ++j)
                    object.portMappings[j] = $root.mesos.NetworkInfo.PortMapping.toObject(message.portMappings[j], options);
            }
            return object;
        };

        /**
         * Converts this NetworkInfo to JSON.
         * @function toJSON
         * @memberof mesos.NetworkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Protocol enum.
         * @enum {string}
         * @property {number} IPv4=1 IPv4 value
         * @property {number} IPv6=2 IPv6 value
         */
        NetworkInfo.Protocol = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "IPv4"] = 1;
            values[valuesById[2] = "IPv6"] = 2;
            return values;
        })();

        NetworkInfo.IPAddress = (function() {

            /**
             * Properties of a IPAddress.
             * @memberof mesos.NetworkInfo
             * @interface IIPAddress
             * @property {mesos.NetworkInfo.Protocol} [protocol] IPAddress protocol
             * @property {string} [ipAddress] IPAddress ipAddress
             */

            /**
             * Constructs a new IPAddress.
             * @memberof mesos.NetworkInfo
             * @classdesc Represents a IPAddress.
             * @constructor
             * @param {mesos.NetworkInfo.IIPAddress=} [properties] Properties to set
             */
            function IPAddress(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IPAddress protocol.
             * @member {mesos.NetworkInfo.Protocol}protocol
             * @memberof mesos.NetworkInfo.IPAddress
             * @instance
             */
            IPAddress.prototype.protocol = 1;

            /**
             * IPAddress ipAddress.
             * @member {string}ipAddress
             * @memberof mesos.NetworkInfo.IPAddress
             * @instance
             */
            IPAddress.prototype.ipAddress = "";

            /**
             * Creates a new IPAddress instance using the specified properties.
             * @function create
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {mesos.NetworkInfo.IIPAddress=} [properties] Properties to set
             * @returns {mesos.NetworkInfo.IPAddress} IPAddress instance
             */
            IPAddress.create = function create(properties) {
                return new IPAddress(properties);
            };

            /**
             * Encodes the specified IPAddress message. Does not implicitly {@link mesos.NetworkInfo.IPAddress.verify|verify} messages.
             * @function encode
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {mesos.NetworkInfo.IIPAddress} message IPAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IPAddress.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
                if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ipAddress);
                return writer;
            };

            /**
             * Encodes the specified IPAddress message, length delimited. Does not implicitly {@link mesos.NetworkInfo.IPAddress.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {mesos.NetworkInfo.IIPAddress} message IPAddress message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IPAddress.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a IPAddress message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.NetworkInfo.IPAddress} IPAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IPAddress.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.NetworkInfo.IPAddress();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.protocol = reader.int32();
                        break;
                    case 2:
                        message.ipAddress = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a IPAddress message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.NetworkInfo.IPAddress} IPAddress
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IPAddress.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a IPAddress message.
             * @function verify
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IPAddress.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    switch (message.protocol) {
                    default:
                        return "protocol: enum value expected";
                    case 1:
                    case 2:
                        break;
                    }
                if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                    if (!$util.isString(message.ipAddress))
                        return "ipAddress: string expected";
                return null;
            };

            /**
             * Creates a IPAddress message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.NetworkInfo.IPAddress} IPAddress
             */
            IPAddress.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.NetworkInfo.IPAddress)
                    return object;
                let message = new $root.mesos.NetworkInfo.IPAddress();
                switch (object.protocol) {
                case "IPv4":
                case 1:
                    message.protocol = 1;
                    break;
                case "IPv6":
                case 2:
                    message.protocol = 2;
                    break;
                }
                if (object.ipAddress != null)
                    message.ipAddress = String(object.ipAddress);
                return message;
            };

            /**
             * Creates a plain object from a IPAddress message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.NetworkInfo.IPAddress
             * @static
             * @param {mesos.NetworkInfo.IPAddress} message IPAddress
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IPAddress.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.protocol = options.enums === String ? "IPv4" : 1;
                    object.ipAddress = "";
                }
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    object.protocol = options.enums === String ? $root.mesos.NetworkInfo.Protocol[message.protocol] : message.protocol;
                if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                    object.ipAddress = message.ipAddress;
                return object;
            };

            /**
             * Converts this IPAddress to JSON.
             * @function toJSON
             * @memberof mesos.NetworkInfo.IPAddress
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IPAddress.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IPAddress;
        })();

        NetworkInfo.PortMapping = (function() {

            /**
             * Properties of a PortMapping.
             * @memberof mesos.NetworkInfo
             * @interface IPortMapping
             * @property {number} hostPort PortMapping hostPort
             * @property {number} containerPort PortMapping containerPort
             * @property {string} [protocol] PortMapping protocol
             */

            /**
             * Constructs a new PortMapping.
             * @memberof mesos.NetworkInfo
             * @classdesc Represents a PortMapping.
             * @constructor
             * @param {mesos.NetworkInfo.IPortMapping=} [properties] Properties to set
             */
            function PortMapping(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PortMapping hostPort.
             * @member {number}hostPort
             * @memberof mesos.NetworkInfo.PortMapping
             * @instance
             */
            PortMapping.prototype.hostPort = 0;

            /**
             * PortMapping containerPort.
             * @member {number}containerPort
             * @memberof mesos.NetworkInfo.PortMapping
             * @instance
             */
            PortMapping.prototype.containerPort = 0;

            /**
             * PortMapping protocol.
             * @member {string}protocol
             * @memberof mesos.NetworkInfo.PortMapping
             * @instance
             */
            PortMapping.prototype.protocol = "";

            /**
             * Creates a new PortMapping instance using the specified properties.
             * @function create
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {mesos.NetworkInfo.IPortMapping=} [properties] Properties to set
             * @returns {mesos.NetworkInfo.PortMapping} PortMapping instance
             */
            PortMapping.create = function create(properties) {
                return new PortMapping(properties);
            };

            /**
             * Encodes the specified PortMapping message. Does not implicitly {@link mesos.NetworkInfo.PortMapping.verify|verify} messages.
             * @function encode
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {mesos.NetworkInfo.IPortMapping} message PortMapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PortMapping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hostPort);
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.containerPort);
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.protocol);
                return writer;
            };

            /**
             * Encodes the specified PortMapping message, length delimited. Does not implicitly {@link mesos.NetworkInfo.PortMapping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {mesos.NetworkInfo.IPortMapping} message PortMapping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PortMapping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PortMapping message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.NetworkInfo.PortMapping} PortMapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PortMapping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.NetworkInfo.PortMapping();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hostPort = reader.uint32();
                        break;
                    case 2:
                        message.containerPort = reader.uint32();
                        break;
                    case 3:
                        message.protocol = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("hostPort"))
                    throw $util.ProtocolError("missing required 'hostPort'", { instance: message });
                if (!message.hasOwnProperty("containerPort"))
                    throw $util.ProtocolError("missing required 'containerPort'", { instance: message });
                return message;
            };

            /**
             * Decodes a PortMapping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.NetworkInfo.PortMapping} PortMapping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PortMapping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PortMapping message.
             * @function verify
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PortMapping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.hostPort))
                    return "hostPort: integer expected";
                if (!$util.isInteger(message.containerPort))
                    return "containerPort: integer expected";
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    if (!$util.isString(message.protocol))
                        return "protocol: string expected";
                return null;
            };

            /**
             * Creates a PortMapping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.NetworkInfo.PortMapping} PortMapping
             */
            PortMapping.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.NetworkInfo.PortMapping)
                    return object;
                let message = new $root.mesos.NetworkInfo.PortMapping();
                if (object.hostPort != null)
                    message.hostPort = object.hostPort >>> 0;
                if (object.containerPort != null)
                    message.containerPort = object.containerPort >>> 0;
                if (object.protocol != null)
                    message.protocol = String(object.protocol);
                return message;
            };

            /**
             * Creates a plain object from a PortMapping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.NetworkInfo.PortMapping
             * @static
             * @param {mesos.NetworkInfo.PortMapping} message PortMapping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PortMapping.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.hostPort = 0;
                    object.containerPort = 0;
                    object.protocol = "";
                }
                if (message.hostPort != null && message.hasOwnProperty("hostPort"))
                    object.hostPort = message.hostPort;
                if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                    object.containerPort = message.containerPort;
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    object.protocol = message.protocol;
                return object;
            };

            /**
             * Converts this PortMapping to JSON.
             * @function toJSON
             * @memberof mesos.NetworkInfo.PortMapping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PortMapping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PortMapping;
        })();

        return NetworkInfo;
    })();

    mesos.CapabilityInfo = (function() {

        /**
         * Properties of a CapabilityInfo.
         * @memberof mesos
         * @interface ICapabilityInfo
         * @property {Array.<mesos.CapabilityInfo.Capability>} [capabilities] CapabilityInfo capabilities
         */

        /**
         * Constructs a new CapabilityInfo.
         * @memberof mesos
         * @classdesc Encapsulation of `Capabilities` supported by Linux.
         * Reference: http://linux.die.net/man/7/capabilities.
         * @constructor
         * @param {mesos.ICapabilityInfo=} [properties] Properties to set
         */
        function CapabilityInfo(properties) {
            this.capabilities = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapabilityInfo capabilities.
         * @member {Array.<mesos.CapabilityInfo.Capability>}capabilities
         * @memberof mesos.CapabilityInfo
         * @instance
         */
        CapabilityInfo.prototype.capabilities = $util.emptyArray;

        /**
         * Creates a new CapabilityInfo instance using the specified properties.
         * @function create
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {mesos.ICapabilityInfo=} [properties] Properties to set
         * @returns {mesos.CapabilityInfo} CapabilityInfo instance
         */
        CapabilityInfo.create = function create(properties) {
            return new CapabilityInfo(properties);
        };

        /**
         * Encodes the specified CapabilityInfo message. Does not implicitly {@link mesos.CapabilityInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {mesos.ICapabilityInfo} message CapabilityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapabilityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.capabilities != null && message.capabilities.length)
                for (let i = 0; i < message.capabilities.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.capabilities[i]);
            return writer;
        };

        /**
         * Encodes the specified CapabilityInfo message, length delimited. Does not implicitly {@link mesos.CapabilityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {mesos.ICapabilityInfo} message CapabilityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapabilityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapabilityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.CapabilityInfo} CapabilityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapabilityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CapabilityInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.capabilities && message.capabilities.length))
                        message.capabilities = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.capabilities.push(reader.int32());
                    } else
                        message.capabilities.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CapabilityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.CapabilityInfo} CapabilityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapabilityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapabilityInfo message.
         * @function verify
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapabilityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.capabilities != null && message.hasOwnProperty("capabilities")) {
                if (!Array.isArray(message.capabilities))
                    return "capabilities: array expected";
                for (let i = 0; i < message.capabilities.length; ++i)
                    switch (message.capabilities[i]) {
                    default:
                        return "capabilities: enum value[] expected";
                    case 0:
                    case 1000:
                    case 1001:
                    case 1002:
                    case 1003:
                    case 1004:
                    case 1005:
                    case 1006:
                    case 1007:
                    case 1008:
                    case 1009:
                    case 1010:
                    case 1011:
                    case 1012:
                    case 1013:
                    case 1014:
                    case 1015:
                    case 1016:
                    case 1017:
                    case 1018:
                    case 1019:
                    case 1020:
                    case 1021:
                    case 1022:
                    case 1023:
                    case 1024:
                    case 1025:
                    case 1026:
                    case 1027:
                    case 1028:
                    case 1029:
                    case 1030:
                    case 1031:
                    case 1032:
                    case 1033:
                    case 1034:
                    case 1035:
                    case 1036:
                    case 1037:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a CapabilityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.CapabilityInfo} CapabilityInfo
         */
        CapabilityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.CapabilityInfo)
                return object;
            let message = new $root.mesos.CapabilityInfo();
            if (object.capabilities) {
                if (!Array.isArray(object.capabilities))
                    throw TypeError(".mesos.CapabilityInfo.capabilities: array expected");
                message.capabilities = [];
                for (let i = 0; i < object.capabilities.length; ++i)
                    switch (object.capabilities[i]) {
                    default:
                    case "UNKNOWN":
                    case 0:
                        message.capabilities[i] = 0;
                        break;
                    case "CHOWN":
                    case 1000:
                        message.capabilities[i] = 1000;
                        break;
                    case "DAC_OVERRIDE":
                    case 1001:
                        message.capabilities[i] = 1001;
                        break;
                    case "DAC_READ_SEARCH":
                    case 1002:
                        message.capabilities[i] = 1002;
                        break;
                    case "FOWNER":
                    case 1003:
                        message.capabilities[i] = 1003;
                        break;
                    case "FSETID":
                    case 1004:
                        message.capabilities[i] = 1004;
                        break;
                    case "KILL":
                    case 1005:
                        message.capabilities[i] = 1005;
                        break;
                    case "SETGID":
                    case 1006:
                        message.capabilities[i] = 1006;
                        break;
                    case "SETUID":
                    case 1007:
                        message.capabilities[i] = 1007;
                        break;
                    case "SETPCAP":
                    case 1008:
                        message.capabilities[i] = 1008;
                        break;
                    case "LINUX_IMMUTABLE":
                    case 1009:
                        message.capabilities[i] = 1009;
                        break;
                    case "NET_BIND_SERVICE":
                    case 1010:
                        message.capabilities[i] = 1010;
                        break;
                    case "NET_BROADCAST":
                    case 1011:
                        message.capabilities[i] = 1011;
                        break;
                    case "NET_ADMIN":
                    case 1012:
                        message.capabilities[i] = 1012;
                        break;
                    case "NET_RAW":
                    case 1013:
                        message.capabilities[i] = 1013;
                        break;
                    case "IPC_LOCK":
                    case 1014:
                        message.capabilities[i] = 1014;
                        break;
                    case "IPC_OWNER":
                    case 1015:
                        message.capabilities[i] = 1015;
                        break;
                    case "SYS_MODULE":
                    case 1016:
                        message.capabilities[i] = 1016;
                        break;
                    case "SYS_RAWIO":
                    case 1017:
                        message.capabilities[i] = 1017;
                        break;
                    case "SYS_CHROOT":
                    case 1018:
                        message.capabilities[i] = 1018;
                        break;
                    case "SYS_PTRACE":
                    case 1019:
                        message.capabilities[i] = 1019;
                        break;
                    case "SYS_PACCT":
                    case 1020:
                        message.capabilities[i] = 1020;
                        break;
                    case "SYS_ADMIN":
                    case 1021:
                        message.capabilities[i] = 1021;
                        break;
                    case "SYS_BOOT":
                    case 1022:
                        message.capabilities[i] = 1022;
                        break;
                    case "SYS_NICE":
                    case 1023:
                        message.capabilities[i] = 1023;
                        break;
                    case "SYS_RESOURCE":
                    case 1024:
                        message.capabilities[i] = 1024;
                        break;
                    case "SYS_TIME":
                    case 1025:
                        message.capabilities[i] = 1025;
                        break;
                    case "SYS_TTY_CONFIG":
                    case 1026:
                        message.capabilities[i] = 1026;
                        break;
                    case "MKNOD":
                    case 1027:
                        message.capabilities[i] = 1027;
                        break;
                    case "LEASE":
                    case 1028:
                        message.capabilities[i] = 1028;
                        break;
                    case "AUDIT_WRITE":
                    case 1029:
                        message.capabilities[i] = 1029;
                        break;
                    case "AUDIT_CONTROL":
                    case 1030:
                        message.capabilities[i] = 1030;
                        break;
                    case "SETFCAP":
                    case 1031:
                        message.capabilities[i] = 1031;
                        break;
                    case "MAC_OVERRIDE":
                    case 1032:
                        message.capabilities[i] = 1032;
                        break;
                    case "MAC_ADMIN":
                    case 1033:
                        message.capabilities[i] = 1033;
                        break;
                    case "SYSLOG":
                    case 1034:
                        message.capabilities[i] = 1034;
                        break;
                    case "WAKE_ALARM":
                    case 1035:
                        message.capabilities[i] = 1035;
                        break;
                    case "BLOCK_SUSPEND":
                    case 1036:
                        message.capabilities[i] = 1036;
                        break;
                    case "AUDIT_READ":
                    case 1037:
                        message.capabilities[i] = 1037;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a CapabilityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.CapabilityInfo
         * @static
         * @param {mesos.CapabilityInfo} message CapabilityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CapabilityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.capabilities = [];
            if (message.capabilities && message.capabilities.length) {
                object.capabilities = [];
                for (let j = 0; j < message.capabilities.length; ++j)
                    object.capabilities[j] = options.enums === String ? $root.mesos.CapabilityInfo.Capability[message.capabilities[j]] : message.capabilities[j];
            }
            return object;
        };

        /**
         * Converts this CapabilityInfo to JSON.
         * @function toJSON
         * @memberof mesos.CapabilityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CapabilityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Capability enum.
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CHOWN=1000 CHOWN value
         * @property {number} DAC_OVERRIDE=1001 DAC_OVERRIDE value
         * @property {number} DAC_READ_SEARCH=1002 DAC_READ_SEARCH value
         * @property {number} FOWNER=1003 FOWNER value
         * @property {number} FSETID=1004 FSETID value
         * @property {number} KILL=1005 KILL value
         * @property {number} SETGID=1006 SETGID value
         * @property {number} SETUID=1007 SETUID value
         * @property {number} SETPCAP=1008 SETPCAP value
         * @property {number} LINUX_IMMUTABLE=1009 LINUX_IMMUTABLE value
         * @property {number} NET_BIND_SERVICE=1010 NET_BIND_SERVICE value
         * @property {number} NET_BROADCAST=1011 NET_BROADCAST value
         * @property {number} NET_ADMIN=1012 NET_ADMIN value
         * @property {number} NET_RAW=1013 NET_RAW value
         * @property {number} IPC_LOCK=1014 IPC_LOCK value
         * @property {number} IPC_OWNER=1015 IPC_OWNER value
         * @property {number} SYS_MODULE=1016 SYS_MODULE value
         * @property {number} SYS_RAWIO=1017 SYS_RAWIO value
         * @property {number} SYS_CHROOT=1018 SYS_CHROOT value
         * @property {number} SYS_PTRACE=1019 SYS_PTRACE value
         * @property {number} SYS_PACCT=1020 SYS_PACCT value
         * @property {number} SYS_ADMIN=1021 SYS_ADMIN value
         * @property {number} SYS_BOOT=1022 SYS_BOOT value
         * @property {number} SYS_NICE=1023 SYS_NICE value
         * @property {number} SYS_RESOURCE=1024 SYS_RESOURCE value
         * @property {number} SYS_TIME=1025 SYS_TIME value
         * @property {number} SYS_TTY_CONFIG=1026 SYS_TTY_CONFIG value
         * @property {number} MKNOD=1027 MKNOD value
         * @property {number} LEASE=1028 LEASE value
         * @property {number} AUDIT_WRITE=1029 AUDIT_WRITE value
         * @property {number} AUDIT_CONTROL=1030 AUDIT_CONTROL value
         * @property {number} SETFCAP=1031 SETFCAP value
         * @property {number} MAC_OVERRIDE=1032 MAC_OVERRIDE value
         * @property {number} MAC_ADMIN=1033 MAC_ADMIN value
         * @property {number} SYSLOG=1034 SYSLOG value
         * @property {number} WAKE_ALARM=1035 WAKE_ALARM value
         * @property {number} BLOCK_SUSPEND=1036 BLOCK_SUSPEND value
         * @property {number} AUDIT_READ=1037 AUDIT_READ value
         */
        CapabilityInfo.Capability = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1000] = "CHOWN"] = 1000;
            values[valuesById[1001] = "DAC_OVERRIDE"] = 1001;
            values[valuesById[1002] = "DAC_READ_SEARCH"] = 1002;
            values[valuesById[1003] = "FOWNER"] = 1003;
            values[valuesById[1004] = "FSETID"] = 1004;
            values[valuesById[1005] = "KILL"] = 1005;
            values[valuesById[1006] = "SETGID"] = 1006;
            values[valuesById[1007] = "SETUID"] = 1007;
            values[valuesById[1008] = "SETPCAP"] = 1008;
            values[valuesById[1009] = "LINUX_IMMUTABLE"] = 1009;
            values[valuesById[1010] = "NET_BIND_SERVICE"] = 1010;
            values[valuesById[1011] = "NET_BROADCAST"] = 1011;
            values[valuesById[1012] = "NET_ADMIN"] = 1012;
            values[valuesById[1013] = "NET_RAW"] = 1013;
            values[valuesById[1014] = "IPC_LOCK"] = 1014;
            values[valuesById[1015] = "IPC_OWNER"] = 1015;
            values[valuesById[1016] = "SYS_MODULE"] = 1016;
            values[valuesById[1017] = "SYS_RAWIO"] = 1017;
            values[valuesById[1018] = "SYS_CHROOT"] = 1018;
            values[valuesById[1019] = "SYS_PTRACE"] = 1019;
            values[valuesById[1020] = "SYS_PACCT"] = 1020;
            values[valuesById[1021] = "SYS_ADMIN"] = 1021;
            values[valuesById[1022] = "SYS_BOOT"] = 1022;
            values[valuesById[1023] = "SYS_NICE"] = 1023;
            values[valuesById[1024] = "SYS_RESOURCE"] = 1024;
            values[valuesById[1025] = "SYS_TIME"] = 1025;
            values[valuesById[1026] = "SYS_TTY_CONFIG"] = 1026;
            values[valuesById[1027] = "MKNOD"] = 1027;
            values[valuesById[1028] = "LEASE"] = 1028;
            values[valuesById[1029] = "AUDIT_WRITE"] = 1029;
            values[valuesById[1030] = "AUDIT_CONTROL"] = 1030;
            values[valuesById[1031] = "SETFCAP"] = 1031;
            values[valuesById[1032] = "MAC_OVERRIDE"] = 1032;
            values[valuesById[1033] = "MAC_ADMIN"] = 1033;
            values[valuesById[1034] = "SYSLOG"] = 1034;
            values[valuesById[1035] = "WAKE_ALARM"] = 1035;
            values[valuesById[1036] = "BLOCK_SUSPEND"] = 1036;
            values[valuesById[1037] = "AUDIT_READ"] = 1037;
            return values;
        })();

        return CapabilityInfo;
    })();

    mesos.LinuxInfo = (function() {

        /**
         * Properties of a LinuxInfo.
         * @memberof mesos
         * @interface ILinuxInfo
         * @property {mesos.ICapabilityInfo} [capabilityInfo] LinuxInfo capabilityInfo
         */

        /**
         * Constructs a new LinuxInfo.
         * @memberof mesos
         * @classdesc Encapsulation for Linux specific configuration.
         * E.g, capabilities, limits etc.
         * @constructor
         * @param {mesos.ILinuxInfo=} [properties] Properties to set
         */
        function LinuxInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LinuxInfo capabilityInfo.
         * @member {(mesos.ICapabilityInfo|null|undefined)}capabilityInfo
         * @memberof mesos.LinuxInfo
         * @instance
         */
        LinuxInfo.prototype.capabilityInfo = null;

        /**
         * Creates a new LinuxInfo instance using the specified properties.
         * @function create
         * @memberof mesos.LinuxInfo
         * @static
         * @param {mesos.ILinuxInfo=} [properties] Properties to set
         * @returns {mesos.LinuxInfo} LinuxInfo instance
         */
        LinuxInfo.create = function create(properties) {
            return new LinuxInfo(properties);
        };

        /**
         * Encodes the specified LinuxInfo message. Does not implicitly {@link mesos.LinuxInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.LinuxInfo
         * @static
         * @param {mesos.ILinuxInfo} message LinuxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinuxInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.capabilityInfo != null && message.hasOwnProperty("capabilityInfo"))
                $root.mesos.CapabilityInfo.encode(message.capabilityInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LinuxInfo message, length delimited. Does not implicitly {@link mesos.LinuxInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.LinuxInfo
         * @static
         * @param {mesos.ILinuxInfo} message LinuxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LinuxInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LinuxInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.LinuxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.LinuxInfo} LinuxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinuxInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.LinuxInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.capabilityInfo = $root.mesos.CapabilityInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LinuxInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.LinuxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.LinuxInfo} LinuxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LinuxInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LinuxInfo message.
         * @function verify
         * @memberof mesos.LinuxInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LinuxInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.capabilityInfo != null && message.hasOwnProperty("capabilityInfo")) {
                let error = $root.mesos.CapabilityInfo.verify(message.capabilityInfo);
                if (error)
                    return "capabilityInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LinuxInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.LinuxInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.LinuxInfo} LinuxInfo
         */
        LinuxInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.LinuxInfo)
                return object;
            let message = new $root.mesos.LinuxInfo();
            if (object.capabilityInfo != null) {
                if (typeof object.capabilityInfo !== "object")
                    throw TypeError(".mesos.LinuxInfo.capabilityInfo: object expected");
                message.capabilityInfo = $root.mesos.CapabilityInfo.fromObject(object.capabilityInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LinuxInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.LinuxInfo
         * @static
         * @param {mesos.LinuxInfo} message LinuxInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LinuxInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.capabilityInfo = null;
            if (message.capabilityInfo != null && message.hasOwnProperty("capabilityInfo"))
                object.capabilityInfo = $root.mesos.CapabilityInfo.toObject(message.capabilityInfo, options);
            return object;
        };

        /**
         * Converts this LinuxInfo to JSON.
         * @function toJSON
         * @memberof mesos.LinuxInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LinuxInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LinuxInfo;
    })();

    mesos.RLimitInfo = (function() {

        /**
         * Properties of a RLimitInfo.
         * @memberof mesos
         * @interface IRLimitInfo
         * @property {Array.<mesos.RLimitInfo.IRLimit>} [rlimits] RLimitInfo rlimits
         */

        /**
         * Constructs a new RLimitInfo.
         * @memberof mesos
         * @classdesc Encapsulation for POSIX rlimits, see
         * http://pubs.opengroup.org/onlinepubs/009695399/functions/getrlimit.html.
         * Note that some types might only be defined for Linux.
         * We use a custom prefix to avoid conflict with existing system macros
         * (e.g., `RLIMIT_CPU` or `NOFILE`).
         * @constructor
         * @param {mesos.IRLimitInfo=} [properties] Properties to set
         */
        function RLimitInfo(properties) {
            this.rlimits = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RLimitInfo rlimits.
         * @member {Array.<mesos.RLimitInfo.IRLimit>}rlimits
         * @memberof mesos.RLimitInfo
         * @instance
         */
        RLimitInfo.prototype.rlimits = $util.emptyArray;

        /**
         * Creates a new RLimitInfo instance using the specified properties.
         * @function create
         * @memberof mesos.RLimitInfo
         * @static
         * @param {mesos.IRLimitInfo=} [properties] Properties to set
         * @returns {mesos.RLimitInfo} RLimitInfo instance
         */
        RLimitInfo.create = function create(properties) {
            return new RLimitInfo(properties);
        };

        /**
         * Encodes the specified RLimitInfo message. Does not implicitly {@link mesos.RLimitInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.RLimitInfo
         * @static
         * @param {mesos.IRLimitInfo} message RLimitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RLimitInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rlimits != null && message.rlimits.length)
                for (let i = 0; i < message.rlimits.length; ++i)
                    $root.mesos.RLimitInfo.RLimit.encode(message.rlimits[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RLimitInfo message, length delimited. Does not implicitly {@link mesos.RLimitInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.RLimitInfo
         * @static
         * @param {mesos.IRLimitInfo} message RLimitInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RLimitInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RLimitInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.RLimitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.RLimitInfo} RLimitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RLimitInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.RLimitInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rlimits && message.rlimits.length))
                        message.rlimits = [];
                    message.rlimits.push($root.mesos.RLimitInfo.RLimit.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RLimitInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.RLimitInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.RLimitInfo} RLimitInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RLimitInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RLimitInfo message.
         * @function verify
         * @memberof mesos.RLimitInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RLimitInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rlimits != null && message.hasOwnProperty("rlimits")) {
                if (!Array.isArray(message.rlimits))
                    return "rlimits: array expected";
                for (let i = 0; i < message.rlimits.length; ++i) {
                    let error = $root.mesos.RLimitInfo.RLimit.verify(message.rlimits[i]);
                    if (error)
                        return "rlimits." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RLimitInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.RLimitInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.RLimitInfo} RLimitInfo
         */
        RLimitInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.RLimitInfo)
                return object;
            let message = new $root.mesos.RLimitInfo();
            if (object.rlimits) {
                if (!Array.isArray(object.rlimits))
                    throw TypeError(".mesos.RLimitInfo.rlimits: array expected");
                message.rlimits = [];
                for (let i = 0; i < object.rlimits.length; ++i) {
                    if (typeof object.rlimits[i] !== "object")
                        throw TypeError(".mesos.RLimitInfo.rlimits: object expected");
                    message.rlimits[i] = $root.mesos.RLimitInfo.RLimit.fromObject(object.rlimits[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RLimitInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.RLimitInfo
         * @static
         * @param {mesos.RLimitInfo} message RLimitInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RLimitInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.rlimits = [];
            if (message.rlimits && message.rlimits.length) {
                object.rlimits = [];
                for (let j = 0; j < message.rlimits.length; ++j)
                    object.rlimits[j] = $root.mesos.RLimitInfo.RLimit.toObject(message.rlimits[j], options);
            }
            return object;
        };

        /**
         * Converts this RLimitInfo to JSON.
         * @function toJSON
         * @memberof mesos.RLimitInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RLimitInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        RLimitInfo.RLimit = (function() {

            /**
             * Properties of a RLimit.
             * @memberof mesos.RLimitInfo
             * @interface IRLimit
             * @property {mesos.RLimitInfo.RLimit.Type} [type] RLimit type
             * @property {number} [hard] RLimit hard
             * @property {number} [soft] RLimit soft
             */

            /**
             * Constructs a new RLimit.
             * @memberof mesos.RLimitInfo
             * @classdesc Represents a RLimit.
             * @constructor
             * @param {mesos.RLimitInfo.IRLimit=} [properties] Properties to set
             */
            function RLimit(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RLimit type.
             * @member {mesos.RLimitInfo.RLimit.Type}type
             * @memberof mesos.RLimitInfo.RLimit
             * @instance
             */
            RLimit.prototype.type = 0;

            /**
             * RLimit hard.
             * @member {number}hard
             * @memberof mesos.RLimitInfo.RLimit
             * @instance
             */
            RLimit.prototype.hard = 0;

            /**
             * RLimit soft.
             * @member {number}soft
             * @memberof mesos.RLimitInfo.RLimit
             * @instance
             */
            RLimit.prototype.soft = 0;

            /**
             * Creates a new RLimit instance using the specified properties.
             * @function create
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {mesos.RLimitInfo.IRLimit=} [properties] Properties to set
             * @returns {mesos.RLimitInfo.RLimit} RLimit instance
             */
            RLimit.create = function create(properties) {
                return new RLimit(properties);
            };

            /**
             * Encodes the specified RLimit message. Does not implicitly {@link mesos.RLimitInfo.RLimit.verify|verify} messages.
             * @function encode
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {mesos.RLimitInfo.IRLimit} message RLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RLimit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.hard != null && message.hasOwnProperty("hard"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hard);
                if (message.soft != null && message.hasOwnProperty("soft"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.soft);
                return writer;
            };

            /**
             * Encodes the specified RLimit message, length delimited. Does not implicitly {@link mesos.RLimitInfo.RLimit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {mesos.RLimitInfo.IRLimit} message RLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RLimit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RLimit message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.RLimitInfo.RLimit} RLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RLimit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.RLimitInfo.RLimit();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.hard = reader.uint32();
                        break;
                    case 3:
                        message.soft = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RLimit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.RLimitInfo.RLimit} RLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RLimit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RLimit message.
             * @function verify
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RLimit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                        break;
                    }
                if (message.hard != null && message.hasOwnProperty("hard"))
                    if (!$util.isInteger(message.hard))
                        return "hard: integer expected";
                if (message.soft != null && message.hasOwnProperty("soft"))
                    if (!$util.isInteger(message.soft))
                        return "soft: integer expected";
                return null;
            };

            /**
             * Creates a RLimit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.RLimitInfo.RLimit} RLimit
             */
            RLimit.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.RLimitInfo.RLimit)
                    return object;
                let message = new $root.mesos.RLimitInfo.RLimit();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "RLMT_AS":
                case 1:
                    message.type = 1;
                    break;
                case "RLMT_CORE":
                case 2:
                    message.type = 2;
                    break;
                case "RLMT_CPU":
                case 3:
                    message.type = 3;
                    break;
                case "RLMT_DATA":
                case 4:
                    message.type = 4;
                    break;
                case "RLMT_FSIZE":
                case 5:
                    message.type = 5;
                    break;
                case "RLMT_LOCKS":
                case 6:
                    message.type = 6;
                    break;
                case "RLMT_MEMLOCK":
                case 7:
                    message.type = 7;
                    break;
                case "RLMT_MSGQUEUE":
                case 8:
                    message.type = 8;
                    break;
                case "RLMT_NICE":
                case 9:
                    message.type = 9;
                    break;
                case "RLMT_NOFILE":
                case 10:
                    message.type = 10;
                    break;
                case "RLMT_NPROC":
                case 11:
                    message.type = 11;
                    break;
                case "RLMT_RSS":
                case 12:
                    message.type = 12;
                    break;
                case "RLMT_RTPRIO":
                case 13:
                    message.type = 13;
                    break;
                case "RLMT_RTTIME":
                case 14:
                    message.type = 14;
                    break;
                case "RLMT_SIGPENDING":
                case 15:
                    message.type = 15;
                    break;
                case "RLMT_STACK":
                case 16:
                    message.type = 16;
                    break;
                }
                if (object.hard != null)
                    message.hard = object.hard >>> 0;
                if (object.soft != null)
                    message.soft = object.soft >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RLimit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.RLimitInfo.RLimit
             * @static
             * @param {mesos.RLimitInfo.RLimit} message RLimit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RLimit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.hard = 0;
                    object.soft = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.RLimitInfo.RLimit.Type[message.type] : message.type;
                if (message.hard != null && message.hasOwnProperty("hard"))
                    object.hard = message.hard;
                if (message.soft != null && message.hasOwnProperty("soft"))
                    object.soft = message.soft;
                return object;
            };

            /**
             * Converts this RLimit to JSON.
             * @function toJSON
             * @memberof mesos.RLimitInfo.RLimit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RLimit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} RLMT_AS=1 RLMT_AS value
             * @property {number} RLMT_CORE=2 RLMT_CORE value
             * @property {number} RLMT_CPU=3 RLMT_CPU value
             * @property {number} RLMT_DATA=4 RLMT_DATA value
             * @property {number} RLMT_FSIZE=5 RLMT_FSIZE value
             * @property {number} RLMT_LOCKS=6 RLMT_LOCKS value
             * @property {number} RLMT_MEMLOCK=7 RLMT_MEMLOCK value
             * @property {number} RLMT_MSGQUEUE=8 RLMT_MSGQUEUE value
             * @property {number} RLMT_NICE=9 RLMT_NICE value
             * @property {number} RLMT_NOFILE=10 RLMT_NOFILE value
             * @property {number} RLMT_NPROC=11 RLMT_NPROC value
             * @property {number} RLMT_RSS=12 RLMT_RSS value
             * @property {number} RLMT_RTPRIO=13 RLMT_RTPRIO value
             * @property {number} RLMT_RTTIME=14 RLMT_RTTIME value
             * @property {number} RLMT_SIGPENDING=15 RLMT_SIGPENDING value
             * @property {number} RLMT_STACK=16 RLMT_STACK value
             */
            RLimit.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "RLMT_AS"] = 1;
                values[valuesById[2] = "RLMT_CORE"] = 2;
                values[valuesById[3] = "RLMT_CPU"] = 3;
                values[valuesById[4] = "RLMT_DATA"] = 4;
                values[valuesById[5] = "RLMT_FSIZE"] = 5;
                values[valuesById[6] = "RLMT_LOCKS"] = 6;
                values[valuesById[7] = "RLMT_MEMLOCK"] = 7;
                values[valuesById[8] = "RLMT_MSGQUEUE"] = 8;
                values[valuesById[9] = "RLMT_NICE"] = 9;
                values[valuesById[10] = "RLMT_NOFILE"] = 10;
                values[valuesById[11] = "RLMT_NPROC"] = 11;
                values[valuesById[12] = "RLMT_RSS"] = 12;
                values[valuesById[13] = "RLMT_RTPRIO"] = 13;
                values[valuesById[14] = "RLMT_RTTIME"] = 14;
                values[valuesById[15] = "RLMT_SIGPENDING"] = 15;
                values[valuesById[16] = "RLMT_STACK"] = 16;
                return values;
            })();

            return RLimit;
        })();

        return RLimitInfo;
    })();

    mesos.TTYInfo = (function() {

        /**
         * Properties of a TTYInfo.
         * @memberof mesos
         * @interface ITTYInfo
         * @property {mesos.TTYInfo.IWindowSize} [windowSize] TTYInfo windowSize
         */

        /**
         * Constructs a new TTYInfo.
         * @memberof mesos
         * @classdesc Describes the information about (pseudo) TTY that can
         * be attached to a process running in a container.
         * @constructor
         * @param {mesos.ITTYInfo=} [properties] Properties to set
         */
        function TTYInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TTYInfo windowSize.
         * @member {(mesos.TTYInfo.IWindowSize|null|undefined)}windowSize
         * @memberof mesos.TTYInfo
         * @instance
         */
        TTYInfo.prototype.windowSize = null;

        /**
         * Creates a new TTYInfo instance using the specified properties.
         * @function create
         * @memberof mesos.TTYInfo
         * @static
         * @param {mesos.ITTYInfo=} [properties] Properties to set
         * @returns {mesos.TTYInfo} TTYInfo instance
         */
        TTYInfo.create = function create(properties) {
            return new TTYInfo(properties);
        };

        /**
         * Encodes the specified TTYInfo message. Does not implicitly {@link mesos.TTYInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.TTYInfo
         * @static
         * @param {mesos.ITTYInfo} message TTYInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TTYInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.windowSize != null && message.hasOwnProperty("windowSize"))
                $root.mesos.TTYInfo.WindowSize.encode(message.windowSize, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TTYInfo message, length delimited. Does not implicitly {@link mesos.TTYInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.TTYInfo
         * @static
         * @param {mesos.ITTYInfo} message TTYInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TTYInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TTYInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.TTYInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.TTYInfo} TTYInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TTYInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TTYInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.windowSize = $root.mesos.TTYInfo.WindowSize.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TTYInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.TTYInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.TTYInfo} TTYInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TTYInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TTYInfo message.
         * @function verify
         * @memberof mesos.TTYInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TTYInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.windowSize != null && message.hasOwnProperty("windowSize")) {
                let error = $root.mesos.TTYInfo.WindowSize.verify(message.windowSize);
                if (error)
                    return "windowSize." + error;
            }
            return null;
        };

        /**
         * Creates a TTYInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.TTYInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.TTYInfo} TTYInfo
         */
        TTYInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.TTYInfo)
                return object;
            let message = new $root.mesos.TTYInfo();
            if (object.windowSize != null) {
                if (typeof object.windowSize !== "object")
                    throw TypeError(".mesos.TTYInfo.windowSize: object expected");
                message.windowSize = $root.mesos.TTYInfo.WindowSize.fromObject(object.windowSize);
            }
            return message;
        };

        /**
         * Creates a plain object from a TTYInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.TTYInfo
         * @static
         * @param {mesos.TTYInfo} message TTYInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TTYInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.windowSize = null;
            if (message.windowSize != null && message.hasOwnProperty("windowSize"))
                object.windowSize = $root.mesos.TTYInfo.WindowSize.toObject(message.windowSize, options);
            return object;
        };

        /**
         * Converts this TTYInfo to JSON.
         * @function toJSON
         * @memberof mesos.TTYInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TTYInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TTYInfo.WindowSize = (function() {

            /**
             * Properties of a WindowSize.
             * @memberof mesos.TTYInfo
             * @interface IWindowSize
             * @property {number} rows WindowSize rows
             * @property {number} columns WindowSize columns
             */

            /**
             * Constructs a new WindowSize.
             * @memberof mesos.TTYInfo
             * @classdesc Represents a WindowSize.
             * @constructor
             * @param {mesos.TTYInfo.IWindowSize=} [properties] Properties to set
             */
            function WindowSize(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WindowSize rows.
             * @member {number}rows
             * @memberof mesos.TTYInfo.WindowSize
             * @instance
             */
            WindowSize.prototype.rows = 0;

            /**
             * WindowSize columns.
             * @member {number}columns
             * @memberof mesos.TTYInfo.WindowSize
             * @instance
             */
            WindowSize.prototype.columns = 0;

            /**
             * Creates a new WindowSize instance using the specified properties.
             * @function create
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {mesos.TTYInfo.IWindowSize=} [properties] Properties to set
             * @returns {mesos.TTYInfo.WindowSize} WindowSize instance
             */
            WindowSize.create = function create(properties) {
                return new WindowSize(properties);
            };

            /**
             * Encodes the specified WindowSize message. Does not implicitly {@link mesos.TTYInfo.WindowSize.verify|verify} messages.
             * @function encode
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {mesos.TTYInfo.IWindowSize} message WindowSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WindowSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.columns);
                return writer;
            };

            /**
             * Encodes the specified WindowSize message, length delimited. Does not implicitly {@link mesos.TTYInfo.WindowSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {mesos.TTYInfo.IWindowSize} message WindowSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WindowSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WindowSize message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.TTYInfo.WindowSize} WindowSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WindowSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.TTYInfo.WindowSize();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rows = reader.uint32();
                        break;
                    case 2:
                        message.columns = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("rows"))
                    throw $util.ProtocolError("missing required 'rows'", { instance: message });
                if (!message.hasOwnProperty("columns"))
                    throw $util.ProtocolError("missing required 'columns'", { instance: message });
                return message;
            };

            /**
             * Decodes a WindowSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.TTYInfo.WindowSize} WindowSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WindowSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WindowSize message.
             * @function verify
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WindowSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isInteger(message.rows))
                    return "rows: integer expected";
                if (!$util.isInteger(message.columns))
                    return "columns: integer expected";
                return null;
            };

            /**
             * Creates a WindowSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.TTYInfo.WindowSize} WindowSize
             */
            WindowSize.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.TTYInfo.WindowSize)
                    return object;
                let message = new $root.mesos.TTYInfo.WindowSize();
                if (object.rows != null)
                    message.rows = object.rows >>> 0;
                if (object.columns != null)
                    message.columns = object.columns >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a WindowSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.TTYInfo.WindowSize
             * @static
             * @param {mesos.TTYInfo.WindowSize} message WindowSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WindowSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.rows = 0;
                    object.columns = 0;
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = message.rows;
                if (message.columns != null && message.hasOwnProperty("columns"))
                    object.columns = message.columns;
                return object;
            };

            /**
             * Converts this WindowSize to JSON.
             * @function toJSON
             * @memberof mesos.TTYInfo.WindowSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WindowSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WindowSize;
        })();

        return TTYInfo;
    })();

    mesos.ContainerInfo = (function() {

        /**
         * Properties of a ContainerInfo.
         * @memberof mesos
         * @interface IContainerInfo
         * @property {mesos.ContainerInfo.Type} type ContainerInfo type
         * @property {Array.<mesos.IVolume>} [volumes] ContainerInfo volumes
         * @property {string} [hostname] ContainerInfo hostname
         * @property {mesos.ContainerInfo.IDockerInfo} [docker] ContainerInfo docker
         * @property {mesos.ContainerInfo.IMesosInfo} [mesos] ContainerInfo mesos
         * @property {Array.<mesos.INetworkInfo>} [networkInfos] ContainerInfo networkInfos
         * @property {mesos.ILinuxInfo} [linuxInfo] ContainerInfo linuxInfo
         * @property {mesos.IRLimitInfo} [rlimitInfo] ContainerInfo rlimitInfo
         * @property {mesos.ITTYInfo} [ttyInfo] ContainerInfo ttyInfo
         */

        /**
         * Constructs a new ContainerInfo.
         * @memberof mesos
         * @classdesc Describes a container configuration and allows extensible
         * configurations for different container implementations.
         * 
         * NOTE: `ContainerInfo` may be specified, e.g., by a task, even if no
         * container image is provided. In this case neither `MesosInfo` nor
         * `DockerInfo` is set, the required `type` must be `MESOS`. This is to
         * address a case when a task without an image, e.g., a shell script
         * with URIs, wants to use features originally designed for containers,
         * for example custom network isolation via `NetworkInfo`.
         * @constructor
         * @param {mesos.IContainerInfo=} [properties] Properties to set
         */
        function ContainerInfo(properties) {
            this.volumes = [];
            this.networkInfos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContainerInfo type.
         * @member {mesos.ContainerInfo.Type}type
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.type = 1;

        /**
         * ContainerInfo volumes.
         * @member {Array.<mesos.IVolume>}volumes
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.volumes = $util.emptyArray;

        /**
         * ContainerInfo hostname.
         * @member {string}hostname
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.hostname = "";

        /**
         * ContainerInfo docker.
         * @member {(mesos.ContainerInfo.IDockerInfo|null|undefined)}docker
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.docker = null;

        /**
         * ContainerInfo mesos.
         * @member {(mesos.ContainerInfo.IMesosInfo|null|undefined)}mesos
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.mesos = null;

        /**
         * ContainerInfo networkInfos.
         * @member {Array.<mesos.INetworkInfo>}networkInfos
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.networkInfos = $util.emptyArray;

        /**
         * ContainerInfo linuxInfo.
         * @member {(mesos.ILinuxInfo|null|undefined)}linuxInfo
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.linuxInfo = null;

        /**
         * ContainerInfo rlimitInfo.
         * @member {(mesos.IRLimitInfo|null|undefined)}rlimitInfo
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.rlimitInfo = null;

        /**
         * ContainerInfo ttyInfo.
         * @member {(mesos.ITTYInfo|null|undefined)}ttyInfo
         * @memberof mesos.ContainerInfo
         * @instance
         */
        ContainerInfo.prototype.ttyInfo = null;

        /**
         * Creates a new ContainerInfo instance using the specified properties.
         * @function create
         * @memberof mesos.ContainerInfo
         * @static
         * @param {mesos.IContainerInfo=} [properties] Properties to set
         * @returns {mesos.ContainerInfo} ContainerInfo instance
         */
        ContainerInfo.create = function create(properties) {
            return new ContainerInfo(properties);
        };

        /**
         * Encodes the specified ContainerInfo message. Does not implicitly {@link mesos.ContainerInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.ContainerInfo
         * @static
         * @param {mesos.IContainerInfo} message ContainerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.volumes != null && message.volumes.length)
                for (let i = 0; i < message.volumes.length; ++i)
                    $root.mesos.Volume.encode(message.volumes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.docker != null && message.hasOwnProperty("docker"))
                $root.mesos.ContainerInfo.DockerInfo.encode(message.docker, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.hostname);
            if (message.mesos != null && message.hasOwnProperty("mesos"))
                $root.mesos.ContainerInfo.MesosInfo.encode(message.mesos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.networkInfos != null && message.networkInfos.length)
                for (let i = 0; i < message.networkInfos.length; ++i)
                    $root.mesos.NetworkInfo.encode(message.networkInfos[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.linuxInfo != null && message.hasOwnProperty("linuxInfo"))
                $root.mesos.LinuxInfo.encode(message.linuxInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.rlimitInfo != null && message.hasOwnProperty("rlimitInfo"))
                $root.mesos.RLimitInfo.encode(message.rlimitInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.ttyInfo != null && message.hasOwnProperty("ttyInfo"))
                $root.mesos.TTYInfo.encode(message.ttyInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContainerInfo message, length delimited. Does not implicitly {@link mesos.ContainerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ContainerInfo
         * @static
         * @param {mesos.IContainerInfo} message ContainerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContainerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ContainerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ContainerInfo} ContainerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.volumes && message.volumes.length))
                        message.volumes = [];
                    message.volumes.push($root.mesos.Volume.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.hostname = reader.string();
                    break;
                case 3:
                    message.docker = $root.mesos.ContainerInfo.DockerInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.mesos = $root.mesos.ContainerInfo.MesosInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.networkInfos && message.networkInfos.length))
                        message.networkInfos = [];
                    message.networkInfos.push($root.mesos.NetworkInfo.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.linuxInfo = $root.mesos.LinuxInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.rlimitInfo = $root.mesos.RLimitInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.ttyInfo = $root.mesos.TTYInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ContainerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ContainerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ContainerInfo} ContainerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContainerInfo message.
         * @function verify
         * @memberof mesos.ContainerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContainerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
                break;
            }
            if (message.volumes != null && message.hasOwnProperty("volumes")) {
                if (!Array.isArray(message.volumes))
                    return "volumes: array expected";
                for (let i = 0; i < message.volumes.length; ++i) {
                    let error = $root.mesos.Volume.verify(message.volumes[i]);
                    if (error)
                        return "volumes." + error;
                }
            }
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                if (!$util.isString(message.hostname))
                    return "hostname: string expected";
            if (message.docker != null && message.hasOwnProperty("docker")) {
                error = $root.mesos.ContainerInfo.DockerInfo.verify(message.docker);
                if (error)
                    return "docker." + error;
            }
            if (message.mesos != null && message.hasOwnProperty("mesos")) {
                error = $root.mesos.ContainerInfo.MesosInfo.verify(message.mesos);
                if (error)
                    return "mesos." + error;
            }
            if (message.networkInfos != null && message.hasOwnProperty("networkInfos")) {
                if (!Array.isArray(message.networkInfos))
                    return "networkInfos: array expected";
                for (let i = 0; i < message.networkInfos.length; ++i) {
                    error = $root.mesos.NetworkInfo.verify(message.networkInfos[i]);
                    if (error)
                        return "networkInfos." + error;
                }
            }
            if (message.linuxInfo != null && message.hasOwnProperty("linuxInfo")) {
                error = $root.mesos.LinuxInfo.verify(message.linuxInfo);
                if (error)
                    return "linuxInfo." + error;
            }
            if (message.rlimitInfo != null && message.hasOwnProperty("rlimitInfo")) {
                error = $root.mesos.RLimitInfo.verify(message.rlimitInfo);
                if (error)
                    return "rlimitInfo." + error;
            }
            if (message.ttyInfo != null && message.hasOwnProperty("ttyInfo")) {
                error = $root.mesos.TTYInfo.verify(message.ttyInfo);
                if (error)
                    return "ttyInfo." + error;
            }
            return null;
        };

        /**
         * Creates a ContainerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ContainerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ContainerInfo} ContainerInfo
         */
        ContainerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ContainerInfo)
                return object;
            let message = new $root.mesos.ContainerInfo();
            switch (object.type) {
            case "DOCKER":
            case 1:
                message.type = 1;
                break;
            case "MESOS":
            case 2:
                message.type = 2;
                break;
            }
            if (object.volumes) {
                if (!Array.isArray(object.volumes))
                    throw TypeError(".mesos.ContainerInfo.volumes: array expected");
                message.volumes = [];
                for (let i = 0; i < object.volumes.length; ++i) {
                    if (typeof object.volumes[i] !== "object")
                        throw TypeError(".mesos.ContainerInfo.volumes: object expected");
                    message.volumes[i] = $root.mesos.Volume.fromObject(object.volumes[i]);
                }
            }
            if (object.hostname != null)
                message.hostname = String(object.hostname);
            if (object.docker != null) {
                if (typeof object.docker !== "object")
                    throw TypeError(".mesos.ContainerInfo.docker: object expected");
                message.docker = $root.mesos.ContainerInfo.DockerInfo.fromObject(object.docker);
            }
            if (object.mesos != null) {
                if (typeof object.mesos !== "object")
                    throw TypeError(".mesos.ContainerInfo.mesos: object expected");
                message.mesos = $root.mesos.ContainerInfo.MesosInfo.fromObject(object.mesos);
            }
            if (object.networkInfos) {
                if (!Array.isArray(object.networkInfos))
                    throw TypeError(".mesos.ContainerInfo.networkInfos: array expected");
                message.networkInfos = [];
                for (let i = 0; i < object.networkInfos.length; ++i) {
                    if (typeof object.networkInfos[i] !== "object")
                        throw TypeError(".mesos.ContainerInfo.networkInfos: object expected");
                    message.networkInfos[i] = $root.mesos.NetworkInfo.fromObject(object.networkInfos[i]);
                }
            }
            if (object.linuxInfo != null) {
                if (typeof object.linuxInfo !== "object")
                    throw TypeError(".mesos.ContainerInfo.linuxInfo: object expected");
                message.linuxInfo = $root.mesos.LinuxInfo.fromObject(object.linuxInfo);
            }
            if (object.rlimitInfo != null) {
                if (typeof object.rlimitInfo !== "object")
                    throw TypeError(".mesos.ContainerInfo.rlimitInfo: object expected");
                message.rlimitInfo = $root.mesos.RLimitInfo.fromObject(object.rlimitInfo);
            }
            if (object.ttyInfo != null) {
                if (typeof object.ttyInfo !== "object")
                    throw TypeError(".mesos.ContainerInfo.ttyInfo: object expected");
                message.ttyInfo = $root.mesos.TTYInfo.fromObject(object.ttyInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContainerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ContainerInfo
         * @static
         * @param {mesos.ContainerInfo} message ContainerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContainerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.volumes = [];
                object.networkInfos = [];
            }
            if (options.defaults) {
                object.type = options.enums === String ? "DOCKER" : 1;
                object.docker = null;
                object.hostname = "";
                object.mesos = null;
                object.linuxInfo = null;
                object.rlimitInfo = null;
                object.ttyInfo = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.mesos.ContainerInfo.Type[message.type] : message.type;
            if (message.volumes && message.volumes.length) {
                object.volumes = [];
                for (let j = 0; j < message.volumes.length; ++j)
                    object.volumes[j] = $root.mesos.Volume.toObject(message.volumes[j], options);
            }
            if (message.docker != null && message.hasOwnProperty("docker"))
                object.docker = $root.mesos.ContainerInfo.DockerInfo.toObject(message.docker, options);
            if (message.hostname != null && message.hasOwnProperty("hostname"))
                object.hostname = message.hostname;
            if (message.mesos != null && message.hasOwnProperty("mesos"))
                object.mesos = $root.mesos.ContainerInfo.MesosInfo.toObject(message.mesos, options);
            if (message.networkInfos && message.networkInfos.length) {
                object.networkInfos = [];
                for (let j = 0; j < message.networkInfos.length; ++j)
                    object.networkInfos[j] = $root.mesos.NetworkInfo.toObject(message.networkInfos[j], options);
            }
            if (message.linuxInfo != null && message.hasOwnProperty("linuxInfo"))
                object.linuxInfo = $root.mesos.LinuxInfo.toObject(message.linuxInfo, options);
            if (message.rlimitInfo != null && message.hasOwnProperty("rlimitInfo"))
                object.rlimitInfo = $root.mesos.RLimitInfo.toObject(message.rlimitInfo, options);
            if (message.ttyInfo != null && message.hasOwnProperty("ttyInfo"))
                object.ttyInfo = $root.mesos.TTYInfo.toObject(message.ttyInfo, options);
            return object;
        };

        /**
         * Converts this ContainerInfo to JSON.
         * @function toJSON
         * @memberof mesos.ContainerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContainerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @enum {string}
         * @property {number} DOCKER=1 DOCKER value
         * @property {number} MESOS=2 MESOS value
         */
        ContainerInfo.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "DOCKER"] = 1;
            values[valuesById[2] = "MESOS"] = 2;
            return values;
        })();

        ContainerInfo.DockerInfo = (function() {

            /**
             * Properties of a DockerInfo.
             * @memberof mesos.ContainerInfo
             * @interface IDockerInfo
             * @property {string} image DockerInfo image
             * @property {mesos.ContainerInfo.DockerInfo.Network} [network] DockerInfo network
             * @property {Array.<mesos.ContainerInfo.DockerInfo.IPortMapping>} [portMappings] DockerInfo portMappings
             * @property {boolean} [privileged] DockerInfo privileged
             * @property {Array.<mesos.IParameter>} [parameters] DockerInfo parameters
             * @property {boolean} [forcePullImage] DockerInfo forcePullImage
             * @property {string} [volumeDriver] DockerInfo volumeDriver
             */

            /**
             * Constructs a new DockerInfo.
             * @memberof mesos.ContainerInfo
             * @classdesc Represents a DockerInfo.
             * @constructor
             * @param {mesos.ContainerInfo.IDockerInfo=} [properties] Properties to set
             */
            function DockerInfo(properties) {
                this.portMappings = [];
                this.parameters = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DockerInfo image.
             * @member {string}image
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.image = "";

            /**
             * DockerInfo network.
             * @member {mesos.ContainerInfo.DockerInfo.Network}network
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.network = 1;

            /**
             * DockerInfo portMappings.
             * @member {Array.<mesos.ContainerInfo.DockerInfo.IPortMapping>}portMappings
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.portMappings = $util.emptyArray;

            /**
             * DockerInfo privileged.
             * @member {boolean}privileged
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.privileged = false;

            /**
             * DockerInfo parameters.
             * @member {Array.<mesos.IParameter>}parameters
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.parameters = $util.emptyArray;

            /**
             * DockerInfo forcePullImage.
             * @member {boolean}forcePullImage
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.forcePullImage = false;

            /**
             * DockerInfo volumeDriver.
             * @member {string}volumeDriver
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             */
            DockerInfo.prototype.volumeDriver = "";

            /**
             * Creates a new DockerInfo instance using the specified properties.
             * @function create
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {mesos.ContainerInfo.IDockerInfo=} [properties] Properties to set
             * @returns {mesos.ContainerInfo.DockerInfo} DockerInfo instance
             */
            DockerInfo.create = function create(properties) {
                return new DockerInfo(properties);
            };

            /**
             * Encodes the specified DockerInfo message. Does not implicitly {@link mesos.ContainerInfo.DockerInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {mesos.ContainerInfo.IDockerInfo} message DockerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DockerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.image);
                if (message.network != null && message.hasOwnProperty("network"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.network);
                if (message.portMappings != null && message.portMappings.length)
                    for (let i = 0; i < message.portMappings.length; ++i)
                        $root.mesos.ContainerInfo.DockerInfo.PortMapping.encode(message.portMappings[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.privileged != null && message.hasOwnProperty("privileged"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.privileged);
                if (message.parameters != null && message.parameters.length)
                    for (let i = 0; i < message.parameters.length; ++i)
                        $root.mesos.Parameter.encode(message.parameters[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.forcePullImage != null && message.hasOwnProperty("forcePullImage"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.forcePullImage);
                if (message.volumeDriver != null && message.hasOwnProperty("volumeDriver"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.volumeDriver);
                return writer;
            };

            /**
             * Encodes the specified DockerInfo message, length delimited. Does not implicitly {@link mesos.ContainerInfo.DockerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {mesos.ContainerInfo.IDockerInfo} message DockerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DockerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DockerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.ContainerInfo.DockerInfo} DockerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DockerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerInfo.DockerInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.image = reader.string();
                        break;
                    case 2:
                        message.network = reader.int32();
                        break;
                    case 3:
                        if (!(message.portMappings && message.portMappings.length))
                            message.portMappings = [];
                        message.portMappings.push($root.mesos.ContainerInfo.DockerInfo.PortMapping.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.privileged = reader.bool();
                        break;
                    case 5:
                        if (!(message.parameters && message.parameters.length))
                            message.parameters = [];
                        message.parameters.push($root.mesos.Parameter.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.forcePullImage = reader.bool();
                        break;
                    case 7:
                        message.volumeDriver = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("image"))
                    throw $util.ProtocolError("missing required 'image'", { instance: message });
                return message;
            };

            /**
             * Decodes a DockerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.ContainerInfo.DockerInfo} DockerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DockerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DockerInfo message.
             * @function verify
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DockerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.image))
                    return "image: string expected";
                if (message.network != null && message.hasOwnProperty("network"))
                    switch (message.network) {
                    default:
                        return "network: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.portMappings != null && message.hasOwnProperty("portMappings")) {
                    if (!Array.isArray(message.portMappings))
                        return "portMappings: array expected";
                    for (let i = 0; i < message.portMappings.length; ++i) {
                        let error = $root.mesos.ContainerInfo.DockerInfo.PortMapping.verify(message.portMappings[i]);
                        if (error)
                            return "portMappings." + error;
                    }
                }
                if (message.privileged != null && message.hasOwnProperty("privileged"))
                    if (typeof message.privileged !== "boolean")
                        return "privileged: boolean expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!Array.isArray(message.parameters))
                        return "parameters: array expected";
                    for (let i = 0; i < message.parameters.length; ++i) {
                        error = $root.mesos.Parameter.verify(message.parameters[i]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.forcePullImage != null && message.hasOwnProperty("forcePullImage"))
                    if (typeof message.forcePullImage !== "boolean")
                        return "forcePullImage: boolean expected";
                if (message.volumeDriver != null && message.hasOwnProperty("volumeDriver"))
                    if (!$util.isString(message.volumeDriver))
                        return "volumeDriver: string expected";
                return null;
            };

            /**
             * Creates a DockerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.ContainerInfo.DockerInfo} DockerInfo
             */
            DockerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.ContainerInfo.DockerInfo)
                    return object;
                let message = new $root.mesos.ContainerInfo.DockerInfo();
                if (object.image != null)
                    message.image = String(object.image);
                switch (object.network) {
                case "HOST":
                case 1:
                    message.network = 1;
                    break;
                case "BRIDGE":
                case 2:
                    message.network = 2;
                    break;
                case "NONE":
                case 3:
                    message.network = 3;
                    break;
                case "USER":
                case 4:
                    message.network = 4;
                    break;
                }
                if (object.portMappings) {
                    if (!Array.isArray(object.portMappings))
                        throw TypeError(".mesos.ContainerInfo.DockerInfo.portMappings: array expected");
                    message.portMappings = [];
                    for (let i = 0; i < object.portMappings.length; ++i) {
                        if (typeof object.portMappings[i] !== "object")
                            throw TypeError(".mesos.ContainerInfo.DockerInfo.portMappings: object expected");
                        message.portMappings[i] = $root.mesos.ContainerInfo.DockerInfo.PortMapping.fromObject(object.portMappings[i]);
                    }
                }
                if (object.privileged != null)
                    message.privileged = Boolean(object.privileged);
                if (object.parameters) {
                    if (!Array.isArray(object.parameters))
                        throw TypeError(".mesos.ContainerInfo.DockerInfo.parameters: array expected");
                    message.parameters = [];
                    for (let i = 0; i < object.parameters.length; ++i) {
                        if (typeof object.parameters[i] !== "object")
                            throw TypeError(".mesos.ContainerInfo.DockerInfo.parameters: object expected");
                        message.parameters[i] = $root.mesos.Parameter.fromObject(object.parameters[i]);
                    }
                }
                if (object.forcePullImage != null)
                    message.forcePullImage = Boolean(object.forcePullImage);
                if (object.volumeDriver != null)
                    message.volumeDriver = String(object.volumeDriver);
                return message;
            };

            /**
             * Creates a plain object from a DockerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.ContainerInfo.DockerInfo
             * @static
             * @param {mesos.ContainerInfo.DockerInfo} message DockerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DockerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.portMappings = [];
                    object.parameters = [];
                }
                if (options.defaults) {
                    object.image = "";
                    object.network = options.enums === String ? "HOST" : 1;
                    object.privileged = false;
                    object.forcePullImage = false;
                    object.volumeDriver = "";
                }
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                if (message.network != null && message.hasOwnProperty("network"))
                    object.network = options.enums === String ? $root.mesos.ContainerInfo.DockerInfo.Network[message.network] : message.network;
                if (message.portMappings && message.portMappings.length) {
                    object.portMappings = [];
                    for (let j = 0; j < message.portMappings.length; ++j)
                        object.portMappings[j] = $root.mesos.ContainerInfo.DockerInfo.PortMapping.toObject(message.portMappings[j], options);
                }
                if (message.privileged != null && message.hasOwnProperty("privileged"))
                    object.privileged = message.privileged;
                if (message.parameters && message.parameters.length) {
                    object.parameters = [];
                    for (let j = 0; j < message.parameters.length; ++j)
                        object.parameters[j] = $root.mesos.Parameter.toObject(message.parameters[j], options);
                }
                if (message.forcePullImage != null && message.hasOwnProperty("forcePullImage"))
                    object.forcePullImage = message.forcePullImage;
                if (message.volumeDriver != null && message.hasOwnProperty("volumeDriver"))
                    object.volumeDriver = message.volumeDriver;
                return object;
            };

            /**
             * Converts this DockerInfo to JSON.
             * @function toJSON
             * @memberof mesos.ContainerInfo.DockerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DockerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Network enum.
             * @enum {string}
             * @property {number} HOST=1 HOST value
             * @property {number} BRIDGE=2 BRIDGE value
             * @property {number} NONE=3 NONE value
             * @property {number} USER=4 USER value
             */
            DockerInfo.Network = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "HOST"] = 1;
                values[valuesById[2] = "BRIDGE"] = 2;
                values[valuesById[3] = "NONE"] = 3;
                values[valuesById[4] = "USER"] = 4;
                return values;
            })();

            DockerInfo.PortMapping = (function() {

                /**
                 * Properties of a PortMapping.
                 * @memberof mesos.ContainerInfo.DockerInfo
                 * @interface IPortMapping
                 * @property {number} hostPort PortMapping hostPort
                 * @property {number} containerPort PortMapping containerPort
                 * @property {string} [protocol] PortMapping protocol
                 */

                /**
                 * Constructs a new PortMapping.
                 * @memberof mesos.ContainerInfo.DockerInfo
                 * @classdesc Represents a PortMapping.
                 * @constructor
                 * @param {mesos.ContainerInfo.DockerInfo.IPortMapping=} [properties] Properties to set
                 */
                function PortMapping(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PortMapping hostPort.
                 * @member {number}hostPort
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @instance
                 */
                PortMapping.prototype.hostPort = 0;

                /**
                 * PortMapping containerPort.
                 * @member {number}containerPort
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @instance
                 */
                PortMapping.prototype.containerPort = 0;

                /**
                 * PortMapping protocol.
                 * @member {string}protocol
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @instance
                 */
                PortMapping.prototype.protocol = "";

                /**
                 * Creates a new PortMapping instance using the specified properties.
                 * @function create
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {mesos.ContainerInfo.DockerInfo.IPortMapping=} [properties] Properties to set
                 * @returns {mesos.ContainerInfo.DockerInfo.PortMapping} PortMapping instance
                 */
                PortMapping.create = function create(properties) {
                    return new PortMapping(properties);
                };

                /**
                 * Encodes the specified PortMapping message. Does not implicitly {@link mesos.ContainerInfo.DockerInfo.PortMapping.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {mesos.ContainerInfo.DockerInfo.IPortMapping} message PortMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PortMapping.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hostPort);
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.containerPort);
                    if (message.protocol != null && message.hasOwnProperty("protocol"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.protocol);
                    return writer;
                };

                /**
                 * Encodes the specified PortMapping message, length delimited. Does not implicitly {@link mesos.ContainerInfo.DockerInfo.PortMapping.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {mesos.ContainerInfo.DockerInfo.IPortMapping} message PortMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PortMapping.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PortMapping message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.ContainerInfo.DockerInfo.PortMapping} PortMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PortMapping.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerInfo.DockerInfo.PortMapping();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hostPort = reader.uint32();
                            break;
                        case 2:
                            message.containerPort = reader.uint32();
                            break;
                        case 3:
                            message.protocol = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("hostPort"))
                        throw $util.ProtocolError("missing required 'hostPort'", { instance: message });
                    if (!message.hasOwnProperty("containerPort"))
                        throw $util.ProtocolError("missing required 'containerPort'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a PortMapping message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.ContainerInfo.DockerInfo.PortMapping} PortMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PortMapping.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PortMapping message.
                 * @function verify
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PortMapping.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.hostPort))
                        return "hostPort: integer expected";
                    if (!$util.isInteger(message.containerPort))
                        return "containerPort: integer expected";
                    if (message.protocol != null && message.hasOwnProperty("protocol"))
                        if (!$util.isString(message.protocol))
                            return "protocol: string expected";
                    return null;
                };

                /**
                 * Creates a PortMapping message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.ContainerInfo.DockerInfo.PortMapping} PortMapping
                 */
                PortMapping.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.ContainerInfo.DockerInfo.PortMapping)
                        return object;
                    let message = new $root.mesos.ContainerInfo.DockerInfo.PortMapping();
                    if (object.hostPort != null)
                        message.hostPort = object.hostPort >>> 0;
                    if (object.containerPort != null)
                        message.containerPort = object.containerPort >>> 0;
                    if (object.protocol != null)
                        message.protocol = String(object.protocol);
                    return message;
                };

                /**
                 * Creates a plain object from a PortMapping message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @static
                 * @param {mesos.ContainerInfo.DockerInfo.PortMapping} message PortMapping
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PortMapping.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.hostPort = 0;
                        object.containerPort = 0;
                        object.protocol = "";
                    }
                    if (message.hostPort != null && message.hasOwnProperty("hostPort"))
                        object.hostPort = message.hostPort;
                    if (message.containerPort != null && message.hasOwnProperty("containerPort"))
                        object.containerPort = message.containerPort;
                    if (message.protocol != null && message.hasOwnProperty("protocol"))
                        object.protocol = message.protocol;
                    return object;
                };

                /**
                 * Converts this PortMapping to JSON.
                 * @function toJSON
                 * @memberof mesos.ContainerInfo.DockerInfo.PortMapping
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PortMapping.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PortMapping;
            })();

            return DockerInfo;
        })();

        ContainerInfo.MesosInfo = (function() {

            /**
             * Properties of a MesosInfo.
             * @memberof mesos.ContainerInfo
             * @interface IMesosInfo
             * @property {mesos.IImage} [image] MesosInfo image
             */

            /**
             * Constructs a new MesosInfo.
             * @memberof mesos.ContainerInfo
             * @classdesc Represents a MesosInfo.
             * @constructor
             * @param {mesos.ContainerInfo.IMesosInfo=} [properties] Properties to set
             */
            function MesosInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MesosInfo image.
             * @member {(mesos.IImage|null|undefined)}image
             * @memberof mesos.ContainerInfo.MesosInfo
             * @instance
             */
            MesosInfo.prototype.image = null;

            /**
             * Creates a new MesosInfo instance using the specified properties.
             * @function create
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {mesos.ContainerInfo.IMesosInfo=} [properties] Properties to set
             * @returns {mesos.ContainerInfo.MesosInfo} MesosInfo instance
             */
            MesosInfo.create = function create(properties) {
                return new MesosInfo(properties);
            };

            /**
             * Encodes the specified MesosInfo message. Does not implicitly {@link mesos.ContainerInfo.MesosInfo.verify|verify} messages.
             * @function encode
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {mesos.ContainerInfo.IMesosInfo} message MesosInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MesosInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.image != null && message.hasOwnProperty("image"))
                    $root.mesos.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MesosInfo message, length delimited. Does not implicitly {@link mesos.ContainerInfo.MesosInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {mesos.ContainerInfo.IMesosInfo} message MesosInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MesosInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MesosInfo message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.ContainerInfo.MesosInfo} MesosInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MesosInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerInfo.MesosInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.image = $root.mesos.Image.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MesosInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.ContainerInfo.MesosInfo} MesosInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MesosInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MesosInfo message.
             * @function verify
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MesosInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.image != null && message.hasOwnProperty("image")) {
                    let error = $root.mesos.Image.verify(message.image);
                    if (error)
                        return "image." + error;
                }
                return null;
            };

            /**
             * Creates a MesosInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.ContainerInfo.MesosInfo} MesosInfo
             */
            MesosInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.ContainerInfo.MesosInfo)
                    return object;
                let message = new $root.mesos.ContainerInfo.MesosInfo();
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".mesos.ContainerInfo.MesosInfo.image: object expected");
                    message.image = $root.mesos.Image.fromObject(object.image);
                }
                return message;
            };

            /**
             * Creates a plain object from a MesosInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.ContainerInfo.MesosInfo
             * @static
             * @param {mesos.ContainerInfo.MesosInfo} message MesosInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MesosInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.image = null;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.mesos.Image.toObject(message.image, options);
                return object;
            };

            /**
             * Converts this MesosInfo to JSON.
             * @function toJSON
             * @memberof mesos.ContainerInfo.MesosInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MesosInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MesosInfo;
        })();

        return ContainerInfo;
    })();

    mesos.ContainerStatus = (function() {

        /**
         * Properties of a ContainerStatus.
         * @memberof mesos
         * @interface IContainerStatus
         * @property {mesos.IContainerID} [containerId] ContainerStatus containerId
         * @property {Array.<mesos.INetworkInfo>} [networkInfos] ContainerStatus networkInfos
         * @property {mesos.ICgroupInfo} [cgroupInfo] ContainerStatus cgroupInfo
         * @property {number} [executorPid] ContainerStatus executorPid
         */

        /**
         * Constructs a new ContainerStatus.
         * @memberof mesos
         * @classdesc Container related information that is resolved during container
         * setup. The information is sent back to the framework as part of the
         * TaskStatus message.
         * @constructor
         * @param {mesos.IContainerStatus=} [properties] Properties to set
         */
        function ContainerStatus(properties) {
            this.networkInfos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContainerStatus containerId.
         * @member {(mesos.IContainerID|null|undefined)}containerId
         * @memberof mesos.ContainerStatus
         * @instance
         */
        ContainerStatus.prototype.containerId = null;

        /**
         * ContainerStatus networkInfos.
         * @member {Array.<mesos.INetworkInfo>}networkInfos
         * @memberof mesos.ContainerStatus
         * @instance
         */
        ContainerStatus.prototype.networkInfos = $util.emptyArray;

        /**
         * ContainerStatus cgroupInfo.
         * @member {(mesos.ICgroupInfo|null|undefined)}cgroupInfo
         * @memberof mesos.ContainerStatus
         * @instance
         */
        ContainerStatus.prototype.cgroupInfo = null;

        /**
         * ContainerStatus executorPid.
         * @member {number}executorPid
         * @memberof mesos.ContainerStatus
         * @instance
         */
        ContainerStatus.prototype.executorPid = 0;

        /**
         * Creates a new ContainerStatus instance using the specified properties.
         * @function create
         * @memberof mesos.ContainerStatus
         * @static
         * @param {mesos.IContainerStatus=} [properties] Properties to set
         * @returns {mesos.ContainerStatus} ContainerStatus instance
         */
        ContainerStatus.create = function create(properties) {
            return new ContainerStatus(properties);
        };

        /**
         * Encodes the specified ContainerStatus message. Does not implicitly {@link mesos.ContainerStatus.verify|verify} messages.
         * @function encode
         * @memberof mesos.ContainerStatus
         * @static
         * @param {mesos.IContainerStatus} message ContainerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.networkInfos != null && message.networkInfos.length)
                for (let i = 0; i < message.networkInfos.length; ++i)
                    $root.mesos.NetworkInfo.encode(message.networkInfos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.cgroupInfo != null && message.hasOwnProperty("cgroupInfo"))
                $root.mesos.CgroupInfo.encode(message.cgroupInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.executorPid != null && message.hasOwnProperty("executorPid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.executorPid);
            if (message.containerId != null && message.hasOwnProperty("containerId"))
                $root.mesos.ContainerID.encode(message.containerId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContainerStatus message, length delimited. Does not implicitly {@link mesos.ContainerStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.ContainerStatus
         * @static
         * @param {mesos.IContainerStatus} message ContainerStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContainerStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContainerStatus message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.ContainerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.ContainerStatus} ContainerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.ContainerStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.containerId = $root.mesos.ContainerID.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.networkInfos && message.networkInfos.length))
                        message.networkInfos = [];
                    message.networkInfos.push($root.mesos.NetworkInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.cgroupInfo = $root.mesos.CgroupInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.executorPid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContainerStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.ContainerStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.ContainerStatus} ContainerStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContainerStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContainerStatus message.
         * @function verify
         * @memberof mesos.ContainerStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContainerStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.containerId != null && message.hasOwnProperty("containerId")) {
                let error = $root.mesos.ContainerID.verify(message.containerId);
                if (error)
                    return "containerId." + error;
            }
            if (message.networkInfos != null && message.hasOwnProperty("networkInfos")) {
                if (!Array.isArray(message.networkInfos))
                    return "networkInfos: array expected";
                for (let i = 0; i < message.networkInfos.length; ++i) {
                    error = $root.mesos.NetworkInfo.verify(message.networkInfos[i]);
                    if (error)
                        return "networkInfos." + error;
                }
            }
            if (message.cgroupInfo != null && message.hasOwnProperty("cgroupInfo")) {
                error = $root.mesos.CgroupInfo.verify(message.cgroupInfo);
                if (error)
                    return "cgroupInfo." + error;
            }
            if (message.executorPid != null && message.hasOwnProperty("executorPid"))
                if (!$util.isInteger(message.executorPid))
                    return "executorPid: integer expected";
            return null;
        };

        /**
         * Creates a ContainerStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.ContainerStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.ContainerStatus} ContainerStatus
         */
        ContainerStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.ContainerStatus)
                return object;
            let message = new $root.mesos.ContainerStatus();
            if (object.containerId != null) {
                if (typeof object.containerId !== "object")
                    throw TypeError(".mesos.ContainerStatus.containerId: object expected");
                message.containerId = $root.mesos.ContainerID.fromObject(object.containerId);
            }
            if (object.networkInfos) {
                if (!Array.isArray(object.networkInfos))
                    throw TypeError(".mesos.ContainerStatus.networkInfos: array expected");
                message.networkInfos = [];
                for (let i = 0; i < object.networkInfos.length; ++i) {
                    if (typeof object.networkInfos[i] !== "object")
                        throw TypeError(".mesos.ContainerStatus.networkInfos: object expected");
                    message.networkInfos[i] = $root.mesos.NetworkInfo.fromObject(object.networkInfos[i]);
                }
            }
            if (object.cgroupInfo != null) {
                if (typeof object.cgroupInfo !== "object")
                    throw TypeError(".mesos.ContainerStatus.cgroupInfo: object expected");
                message.cgroupInfo = $root.mesos.CgroupInfo.fromObject(object.cgroupInfo);
            }
            if (object.executorPid != null)
                message.executorPid = object.executorPid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ContainerStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.ContainerStatus
         * @static
         * @param {mesos.ContainerStatus} message ContainerStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContainerStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.networkInfos = [];
            if (options.defaults) {
                object.cgroupInfo = null;
                object.executorPid = 0;
                object.containerId = null;
            }
            if (message.networkInfos && message.networkInfos.length) {
                object.networkInfos = [];
                for (let j = 0; j < message.networkInfos.length; ++j)
                    object.networkInfos[j] = $root.mesos.NetworkInfo.toObject(message.networkInfos[j], options);
            }
            if (message.cgroupInfo != null && message.hasOwnProperty("cgroupInfo"))
                object.cgroupInfo = $root.mesos.CgroupInfo.toObject(message.cgroupInfo, options);
            if (message.executorPid != null && message.hasOwnProperty("executorPid"))
                object.executorPid = message.executorPid;
            if (message.containerId != null && message.hasOwnProperty("containerId"))
                object.containerId = $root.mesos.ContainerID.toObject(message.containerId, options);
            return object;
        };

        /**
         * Converts this ContainerStatus to JSON.
         * @function toJSON
         * @memberof mesos.ContainerStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContainerStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContainerStatus;
    })();

    mesos.CgroupInfo = (function() {

        /**
         * Properties of a CgroupInfo.
         * @memberof mesos
         * @interface ICgroupInfo
         * @property {mesos.CgroupInfo.INetCls} [netCls] CgroupInfo netCls
         */

        /**
         * Constructs a new CgroupInfo.
         * @memberof mesos
         * @classdesc Linux control group (cgroup) information.
         * @constructor
         * @param {mesos.ICgroupInfo=} [properties] Properties to set
         */
        function CgroupInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CgroupInfo netCls.
         * @member {(mesos.CgroupInfo.INetCls|null|undefined)}netCls
         * @memberof mesos.CgroupInfo
         * @instance
         */
        CgroupInfo.prototype.netCls = null;

        /**
         * Creates a new CgroupInfo instance using the specified properties.
         * @function create
         * @memberof mesos.CgroupInfo
         * @static
         * @param {mesos.ICgroupInfo=} [properties] Properties to set
         * @returns {mesos.CgroupInfo} CgroupInfo instance
         */
        CgroupInfo.create = function create(properties) {
            return new CgroupInfo(properties);
        };

        /**
         * Encodes the specified CgroupInfo message. Does not implicitly {@link mesos.CgroupInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.CgroupInfo
         * @static
         * @param {mesos.ICgroupInfo} message CgroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CgroupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.netCls != null && message.hasOwnProperty("netCls"))
                $root.mesos.CgroupInfo.NetCls.encode(message.netCls, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CgroupInfo message, length delimited. Does not implicitly {@link mesos.CgroupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.CgroupInfo
         * @static
         * @param {mesos.ICgroupInfo} message CgroupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CgroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CgroupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.CgroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.CgroupInfo} CgroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CgroupInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CgroupInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.netCls = $root.mesos.CgroupInfo.NetCls.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CgroupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.CgroupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.CgroupInfo} CgroupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CgroupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CgroupInfo message.
         * @function verify
         * @memberof mesos.CgroupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CgroupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.netCls != null && message.hasOwnProperty("netCls")) {
                let error = $root.mesos.CgroupInfo.NetCls.verify(message.netCls);
                if (error)
                    return "netCls." + error;
            }
            return null;
        };

        /**
         * Creates a CgroupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.CgroupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.CgroupInfo} CgroupInfo
         */
        CgroupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.CgroupInfo)
                return object;
            let message = new $root.mesos.CgroupInfo();
            if (object.netCls != null) {
                if (typeof object.netCls !== "object")
                    throw TypeError(".mesos.CgroupInfo.netCls: object expected");
                message.netCls = $root.mesos.CgroupInfo.NetCls.fromObject(object.netCls);
            }
            return message;
        };

        /**
         * Creates a plain object from a CgroupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.CgroupInfo
         * @static
         * @param {mesos.CgroupInfo} message CgroupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CgroupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.netCls = null;
            if (message.netCls != null && message.hasOwnProperty("netCls"))
                object.netCls = $root.mesos.CgroupInfo.NetCls.toObject(message.netCls, options);
            return object;
        };

        /**
         * Converts this CgroupInfo to JSON.
         * @function toJSON
         * @memberof mesos.CgroupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CgroupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        CgroupInfo.NetCls = (function() {

            /**
             * Properties of a NetCls.
             * @memberof mesos.CgroupInfo
             * @interface INetCls
             * @property {number} [classid] NetCls classid
             */

            /**
             * Constructs a new NetCls.
             * @memberof mesos.CgroupInfo
             * @classdesc Represents a NetCls.
             * @constructor
             * @param {mesos.CgroupInfo.INetCls=} [properties] Properties to set
             */
            function NetCls(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NetCls classid.
             * @member {number}classid
             * @memberof mesos.CgroupInfo.NetCls
             * @instance
             */
            NetCls.prototype.classid = 0;

            /**
             * Creates a new NetCls instance using the specified properties.
             * @function create
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {mesos.CgroupInfo.INetCls=} [properties] Properties to set
             * @returns {mesos.CgroupInfo.NetCls} NetCls instance
             */
            NetCls.create = function create(properties) {
                return new NetCls(properties);
            };

            /**
             * Encodes the specified NetCls message. Does not implicitly {@link mesos.CgroupInfo.NetCls.verify|verify} messages.
             * @function encode
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {mesos.CgroupInfo.INetCls} message NetCls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetCls.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.classid != null && message.hasOwnProperty("classid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.classid);
                return writer;
            };

            /**
             * Encodes the specified NetCls message, length delimited. Does not implicitly {@link mesos.CgroupInfo.NetCls.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {mesos.CgroupInfo.INetCls} message NetCls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetCls.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NetCls message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.CgroupInfo.NetCls} NetCls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetCls.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.CgroupInfo.NetCls();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.classid = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NetCls message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.CgroupInfo.NetCls} NetCls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetCls.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NetCls message.
             * @function verify
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NetCls.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.classid != null && message.hasOwnProperty("classid"))
                    if (!$util.isInteger(message.classid))
                        return "classid: integer expected";
                return null;
            };

            /**
             * Creates a NetCls message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.CgroupInfo.NetCls} NetCls
             */
            NetCls.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.CgroupInfo.NetCls)
                    return object;
                let message = new $root.mesos.CgroupInfo.NetCls();
                if (object.classid != null)
                    message.classid = object.classid >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a NetCls message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.CgroupInfo.NetCls
             * @static
             * @param {mesos.CgroupInfo.NetCls} message NetCls
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NetCls.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.classid = 0;
                if (message.classid != null && message.hasOwnProperty("classid"))
                    object.classid = message.classid;
                return object;
            };

            /**
             * Converts this NetCls to JSON.
             * @function toJSON
             * @memberof mesos.CgroupInfo.NetCls
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NetCls.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NetCls;
        })();

        return CgroupInfo;
    })();

    mesos.Labels = (function() {

        /**
         * Properties of a Labels.
         * @memberof mesos
         * @interface ILabels
         * @property {Array.<mesos.ILabel>} [labels] Labels labels
         */

        /**
         * Constructs a new Labels.
         * @memberof mesos
         * @classdesc Collection of labels. Labels should not contain duplicate key-value
         * pairs.
         * @constructor
         * @param {mesos.ILabels=} [properties] Properties to set
         */
        function Labels(properties) {
            this.labels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Labels labels.
         * @member {Array.<mesos.ILabel>}labels
         * @memberof mesos.Labels
         * @instance
         */
        Labels.prototype.labels = $util.emptyArray;

        /**
         * Creates a new Labels instance using the specified properties.
         * @function create
         * @memberof mesos.Labels
         * @static
         * @param {mesos.ILabels=} [properties] Properties to set
         * @returns {mesos.Labels} Labels instance
         */
        Labels.create = function create(properties) {
            return new Labels(properties);
        };

        /**
         * Encodes the specified Labels message. Does not implicitly {@link mesos.Labels.verify|verify} messages.
         * @function encode
         * @memberof mesos.Labels
         * @static
         * @param {mesos.ILabels} message Labels message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Labels.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labels != null && message.labels.length)
                for (let i = 0; i < message.labels.length; ++i)
                    $root.mesos.Label.encode(message.labels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Labels message, length delimited. Does not implicitly {@link mesos.Labels.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Labels
         * @static
         * @param {mesos.ILabels} message Labels message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Labels.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Labels message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Labels
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Labels} Labels
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Labels.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Labels();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.labels && message.labels.length))
                        message.labels = [];
                    message.labels.push($root.mesos.Label.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Labels message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Labels
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Labels} Labels
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Labels.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Labels message.
         * @function verify
         * @memberof mesos.Labels
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Labels.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!Array.isArray(message.labels))
                    return "labels: array expected";
                for (let i = 0; i < message.labels.length; ++i) {
                    let error = $root.mesos.Label.verify(message.labels[i]);
                    if (error)
                        return "labels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Labels message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Labels
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Labels} Labels
         */
        Labels.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Labels)
                return object;
            let message = new $root.mesos.Labels();
            if (object.labels) {
                if (!Array.isArray(object.labels))
                    throw TypeError(".mesos.Labels.labels: array expected");
                message.labels = [];
                for (let i = 0; i < object.labels.length; ++i) {
                    if (typeof object.labels[i] !== "object")
                        throw TypeError(".mesos.Labels.labels: object expected");
                    message.labels[i] = $root.mesos.Label.fromObject(object.labels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Labels message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Labels
         * @static
         * @param {mesos.Labels} message Labels
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Labels.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.labels = [];
            if (message.labels && message.labels.length) {
                object.labels = [];
                for (let j = 0; j < message.labels.length; ++j)
                    object.labels[j] = $root.mesos.Label.toObject(message.labels[j], options);
            }
            return object;
        };

        /**
         * Converts this Labels to JSON.
         * @function toJSON
         * @memberof mesos.Labels
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Labels.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Labels;
    })();

    mesos.Label = (function() {

        /**
         * Properties of a Label.
         * @memberof mesos
         * @interface ILabel
         * @property {string} key Label key
         * @property {string} [value] Label value
         */

        /**
         * Constructs a new Label.
         * @memberof mesos
         * @classdesc Key, value pair used to store free form user-data.
         * @constructor
         * @param {mesos.ILabel=} [properties] Properties to set
         */
        function Label(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Label key.
         * @member {string}key
         * @memberof mesos.Label
         * @instance
         */
        Label.prototype.key = "";

        /**
         * Label value.
         * @member {string}value
         * @memberof mesos.Label
         * @instance
         */
        Label.prototype.value = "";

        /**
         * Creates a new Label instance using the specified properties.
         * @function create
         * @memberof mesos.Label
         * @static
         * @param {mesos.ILabel=} [properties] Properties to set
         * @returns {mesos.Label} Label instance
         */
        Label.create = function create(properties) {
            return new Label(properties);
        };

        /**
         * Encodes the specified Label message. Does not implicitly {@link mesos.Label.verify|verify} messages.
         * @function encode
         * @memberof mesos.Label
         * @static
         * @param {mesos.ILabel} message Label message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Label.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Label message, length delimited. Does not implicitly {@link mesos.Label.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Label
         * @static
         * @param {mesos.ILabel} message Label message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Label.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Label message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Label
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Label} Label
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Label.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Label();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a Label message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Label
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Label} Label
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Label.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Label message.
         * @function verify
         * @memberof mesos.Label
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Label.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.key))
                return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Label message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Label
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Label} Label
         */
        Label.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Label)
                return object;
            let message = new $root.mesos.Label();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Label message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Label
         * @static
         * @param {mesos.Label} message Label
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Label.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Label to JSON.
         * @function toJSON
         * @memberof mesos.Label
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Label.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Label;
    })();

    mesos.Port = (function() {

        /**
         * Properties of a Port.
         * @memberof mesos
         * @interface IPort
         * @property {number} number Port number
         * @property {string} [name] Port name
         * @property {string} [protocol] Port protocol
         * @property {mesos.DiscoveryInfo.Visibility} [visibility] Port visibility
         * @property {mesos.ILabels} [labels] Port labels
         */

        /**
         * Constructs a new Port.
         * @memberof mesos
         * @classdesc Named port used for service discovery.
         * @constructor
         * @param {mesos.IPort=} [properties] Properties to set
         */
        function Port(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Port number.
         * @member {number}number
         * @memberof mesos.Port
         * @instance
         */
        Port.prototype.number = 0;

        /**
         * Port name.
         * @member {string}name
         * @memberof mesos.Port
         * @instance
         */
        Port.prototype.name = "";

        /**
         * Port protocol.
         * @member {string}protocol
         * @memberof mesos.Port
         * @instance
         */
        Port.prototype.protocol = "";

        /**
         * Port visibility.
         * @member {mesos.DiscoveryInfo.Visibility}visibility
         * @memberof mesos.Port
         * @instance
         */
        Port.prototype.visibility = 0;

        /**
         * Port labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.Port
         * @instance
         */
        Port.prototype.labels = null;

        /**
         * Creates a new Port instance using the specified properties.
         * @function create
         * @memberof mesos.Port
         * @static
         * @param {mesos.IPort=} [properties] Properties to set
         * @returns {mesos.Port} Port instance
         */
        Port.create = function create(properties) {
            return new Port(properties);
        };

        /**
         * Encodes the specified Port message. Does not implicitly {@link mesos.Port.verify|verify} messages.
         * @function encode
         * @memberof mesos.Port
         * @static
         * @param {mesos.IPort} message Port message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Port.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.number);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.protocol);
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.visibility);
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Port message, length delimited. Does not implicitly {@link mesos.Port.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Port
         * @static
         * @param {mesos.IPort} message Port message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Port.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Port message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Port
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Port} Port
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Port.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Port();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.number = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.protocol = reader.string();
                    break;
                case 4:
                    message.visibility = reader.int32();
                    break;
                case 5:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("number"))
                throw $util.ProtocolError("missing required 'number'", { instance: message });
            return message;
        };

        /**
         * Decodes a Port message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Port
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Port} Port
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Port.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Port message.
         * @function verify
         * @memberof mesos.Port
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Port.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.number))
                return "number: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isString(message.protocol))
                    return "protocol: string expected";
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                switch (message.visibility) {
                default:
                    return "visibility: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                let error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            return null;
        };

        /**
         * Creates a Port message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Port
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Port} Port
         */
        Port.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Port)
                return object;
            let message = new $root.mesos.Port();
            if (object.number != null)
                message.number = object.number >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.protocol != null)
                message.protocol = String(object.protocol);
            switch (object.visibility) {
            case "FRAMEWORK":
            case 0:
                message.visibility = 0;
                break;
            case "CLUSTER":
            case 1:
                message.visibility = 1;
                break;
            case "EXTERNAL":
            case 2:
                message.visibility = 2;
                break;
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.Port.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            return message;
        };

        /**
         * Creates a plain object from a Port message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Port
         * @static
         * @param {mesos.Port} message Port
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Port.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.number = 0;
                object.name = "";
                object.protocol = "";
                object.visibility = options.enums === String ? "FRAMEWORK" : 0;
                object.labels = null;
            }
            if (message.number != null && message.hasOwnProperty("number"))
                object.number = message.number;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                object.visibility = options.enums === String ? $root.mesos.DiscoveryInfo.Visibility[message.visibility] : message.visibility;
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            return object;
        };

        /**
         * Converts this Port to JSON.
         * @function toJSON
         * @memberof mesos.Port
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Port.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Port;
    })();

    mesos.Ports = (function() {

        /**
         * Properties of a Ports.
         * @memberof mesos
         * @interface IPorts
         * @property {Array.<mesos.IPort>} [ports] Ports ports
         */

        /**
         * Constructs a new Ports.
         * @memberof mesos
         * @classdesc Collection of ports.
         * @constructor
         * @param {mesos.IPorts=} [properties] Properties to set
         */
        function Ports(properties) {
            this.ports = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ports ports.
         * @member {Array.<mesos.IPort>}ports
         * @memberof mesos.Ports
         * @instance
         */
        Ports.prototype.ports = $util.emptyArray;

        /**
         * Creates a new Ports instance using the specified properties.
         * @function create
         * @memberof mesos.Ports
         * @static
         * @param {mesos.IPorts=} [properties] Properties to set
         * @returns {mesos.Ports} Ports instance
         */
        Ports.create = function create(properties) {
            return new Ports(properties);
        };

        /**
         * Encodes the specified Ports message. Does not implicitly {@link mesos.Ports.verify|verify} messages.
         * @function encode
         * @memberof mesos.Ports
         * @static
         * @param {mesos.IPorts} message Ports message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ports.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ports != null && message.ports.length)
                for (let i = 0; i < message.ports.length; ++i)
                    $root.mesos.Port.encode(message.ports[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Ports message, length delimited. Does not implicitly {@link mesos.Ports.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Ports
         * @static
         * @param {mesos.IPorts} message Ports message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ports.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ports message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Ports
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Ports} Ports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ports.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Ports();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ports && message.ports.length))
                        message.ports = [];
                    message.ports.push($root.mesos.Port.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Ports message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Ports
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Ports} Ports
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ports.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ports message.
         * @function verify
         * @memberof mesos.Ports
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ports.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                if (!Array.isArray(message.ports))
                    return "ports: array expected";
                for (let i = 0; i < message.ports.length; ++i) {
                    let error = $root.mesos.Port.verify(message.ports[i]);
                    if (error)
                        return "ports." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Ports message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Ports
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Ports} Ports
         */
        Ports.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Ports)
                return object;
            let message = new $root.mesos.Ports();
            if (object.ports) {
                if (!Array.isArray(object.ports))
                    throw TypeError(".mesos.Ports.ports: array expected");
                message.ports = [];
                for (let i = 0; i < object.ports.length; ++i) {
                    if (typeof object.ports[i] !== "object")
                        throw TypeError(".mesos.Ports.ports: object expected");
                    message.ports[i] = $root.mesos.Port.fromObject(object.ports[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Ports message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Ports
         * @static
         * @param {mesos.Ports} message Ports
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ports.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ports = [];
            if (message.ports && message.ports.length) {
                object.ports = [];
                for (let j = 0; j < message.ports.length; ++j)
                    object.ports[j] = $root.mesos.Port.toObject(message.ports[j], options);
            }
            return object;
        };

        /**
         * Converts this Ports to JSON.
         * @function toJSON
         * @memberof mesos.Ports
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ports.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ports;
    })();

    mesos.DiscoveryInfo = (function() {

        /**
         * Properties of a DiscoveryInfo.
         * @memberof mesos
         * @interface IDiscoveryInfo
         * @property {mesos.DiscoveryInfo.Visibility} visibility DiscoveryInfo visibility
         * @property {string} [name] DiscoveryInfo name
         * @property {string} [environment] DiscoveryInfo environment
         * @property {string} [location] DiscoveryInfo location
         * @property {string} [version] DiscoveryInfo version
         * @property {mesos.IPorts} [ports] DiscoveryInfo ports
         * @property {mesos.ILabels} [labels] DiscoveryInfo labels
         */

        /**
         * Constructs a new DiscoveryInfo.
         * @memberof mesos
         * @classdesc Service discovery information.
         * The visibility field restricts discovery within a framework (FRAMEWORK),
         * within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
         * Each port in the ports field also has an optional visibility field.
         * If visibility is specified for a port, it overrides the default service-wide
         * DiscoveryInfo.visibility for that port.
         * The environment, location, and version fields provide first class support for
         * common attributes used to differentiate between similar services. The
         * environment may receive values such as PROD/QA/DEV, the location field may
         * receive values like EAST-US/WEST-US/EUROPE/AMEA, and the version field may
         * receive values like v2.0/v0.9. The exact use of these fields is up to each
         * service discovery system.
         * @constructor
         * @param {mesos.IDiscoveryInfo=} [properties] Properties to set
         */
        function DiscoveryInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiscoveryInfo visibility.
         * @member {mesos.DiscoveryInfo.Visibility}visibility
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.visibility = 0;

        /**
         * DiscoveryInfo name.
         * @member {string}name
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.name = "";

        /**
         * DiscoveryInfo environment.
         * @member {string}environment
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.environment = "";

        /**
         * DiscoveryInfo location.
         * @member {string}location
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.location = "";

        /**
         * DiscoveryInfo version.
         * @member {string}version
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.version = "";

        /**
         * DiscoveryInfo ports.
         * @member {(mesos.IPorts|null|undefined)}ports
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.ports = null;

        /**
         * DiscoveryInfo labels.
         * @member {(mesos.ILabels|null|undefined)}labels
         * @memberof mesos.DiscoveryInfo
         * @instance
         */
        DiscoveryInfo.prototype.labels = null;

        /**
         * Creates a new DiscoveryInfo instance using the specified properties.
         * @function create
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {mesos.IDiscoveryInfo=} [properties] Properties to set
         * @returns {mesos.DiscoveryInfo} DiscoveryInfo instance
         */
        DiscoveryInfo.create = function create(properties) {
            return new DiscoveryInfo(properties);
        };

        /**
         * Encodes the specified DiscoveryInfo message. Does not implicitly {@link mesos.DiscoveryInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {mesos.IDiscoveryInfo} message DiscoveryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiscoveryInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.visibility);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.environment != null && message.hasOwnProperty("environment"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.environment);
            if (message.location != null && message.hasOwnProperty("location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
            if (message.ports != null && message.hasOwnProperty("ports"))
                $root.mesos.Ports.encode(message.ports, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.labels != null && message.hasOwnProperty("labels"))
                $root.mesos.Labels.encode(message.labels, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DiscoveryInfo message, length delimited. Does not implicitly {@link mesos.DiscoveryInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {mesos.IDiscoveryInfo} message DiscoveryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiscoveryInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiscoveryInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.DiscoveryInfo} DiscoveryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiscoveryInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.DiscoveryInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.visibility = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.environment = reader.string();
                    break;
                case 4:
                    message.location = reader.string();
                    break;
                case 5:
                    message.version = reader.string();
                    break;
                case 6:
                    message.ports = $root.mesos.Ports.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.labels = $root.mesos.Labels.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("visibility"))
                throw $util.ProtocolError("missing required 'visibility'", { instance: message });
            return message;
        };

        /**
         * Decodes a DiscoveryInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.DiscoveryInfo} DiscoveryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiscoveryInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiscoveryInfo message.
         * @function verify
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiscoveryInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.visibility) {
            default:
                return "visibility: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.environment != null && message.hasOwnProperty("environment"))
                if (!$util.isString(message.environment))
                    return "environment: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.ports != null && message.hasOwnProperty("ports")) {
                let error = $root.mesos.Ports.verify(message.ports);
                if (error)
                    return "ports." + error;
            }
            if (message.labels != null && message.hasOwnProperty("labels")) {
                error = $root.mesos.Labels.verify(message.labels);
                if (error)
                    return "labels." + error;
            }
            return null;
        };

        /**
         * Creates a DiscoveryInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.DiscoveryInfo} DiscoveryInfo
         */
        DiscoveryInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.DiscoveryInfo)
                return object;
            let message = new $root.mesos.DiscoveryInfo();
            switch (object.visibility) {
            case "FRAMEWORK":
            case 0:
                message.visibility = 0;
                break;
            case "CLUSTER":
            case 1:
                message.visibility = 1;
                break;
            case "EXTERNAL":
            case 2:
                message.visibility = 2;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.environment != null)
                message.environment = String(object.environment);
            if (object.location != null)
                message.location = String(object.location);
            if (object.version != null)
                message.version = String(object.version);
            if (object.ports != null) {
                if (typeof object.ports !== "object")
                    throw TypeError(".mesos.DiscoveryInfo.ports: object expected");
                message.ports = $root.mesos.Ports.fromObject(object.ports);
            }
            if (object.labels != null) {
                if (typeof object.labels !== "object")
                    throw TypeError(".mesos.DiscoveryInfo.labels: object expected");
                message.labels = $root.mesos.Labels.fromObject(object.labels);
            }
            return message;
        };

        /**
         * Creates a plain object from a DiscoveryInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.DiscoveryInfo
         * @static
         * @param {mesos.DiscoveryInfo} message DiscoveryInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DiscoveryInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.visibility = options.enums === String ? "FRAMEWORK" : 0;
                object.name = "";
                object.environment = "";
                object.location = "";
                object.version = "";
                object.ports = null;
                object.labels = null;
            }
            if (message.visibility != null && message.hasOwnProperty("visibility"))
                object.visibility = options.enums === String ? $root.mesos.DiscoveryInfo.Visibility[message.visibility] : message.visibility;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.environment != null && message.hasOwnProperty("environment"))
                object.environment = message.environment;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.ports != null && message.hasOwnProperty("ports"))
                object.ports = $root.mesos.Ports.toObject(message.ports, options);
            if (message.labels != null && message.hasOwnProperty("labels"))
                object.labels = $root.mesos.Labels.toObject(message.labels, options);
            return object;
        };

        /**
         * Converts this DiscoveryInfo to JSON.
         * @function toJSON
         * @memberof mesos.DiscoveryInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DiscoveryInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Visibility enum.
         * @enum {string}
         * @property {number} FRAMEWORK=0 FRAMEWORK value
         * @property {number} CLUSTER=1 CLUSTER value
         * @property {number} EXTERNAL=2 EXTERNAL value
         */
        DiscoveryInfo.Visibility = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FRAMEWORK"] = 0;
            values[valuesById[1] = "CLUSTER"] = 1;
            values[valuesById[2] = "EXTERNAL"] = 2;
            return values;
        })();

        return DiscoveryInfo;
    })();

    mesos.WeightInfo = (function() {

        /**
         * Properties of a WeightInfo.
         * @memberof mesos
         * @interface IWeightInfo
         * @property {number} weight WeightInfo weight
         * @property {string} [role] WeightInfo role
         */

        /**
         * Constructs a new WeightInfo.
         * @memberof mesos
         * @classdesc Named WeightInfo to indicate resource allocation
         * priority between the different roles.
         * @constructor
         * @param {mesos.IWeightInfo=} [properties] Properties to set
         */
        function WeightInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WeightInfo weight.
         * @member {number}weight
         * @memberof mesos.WeightInfo
         * @instance
         */
        WeightInfo.prototype.weight = 0;

        /**
         * WeightInfo role.
         * @member {string}role
         * @memberof mesos.WeightInfo
         * @instance
         */
        WeightInfo.prototype.role = "";

        /**
         * Creates a new WeightInfo instance using the specified properties.
         * @function create
         * @memberof mesos.WeightInfo
         * @static
         * @param {mesos.IWeightInfo=} [properties] Properties to set
         * @returns {mesos.WeightInfo} WeightInfo instance
         */
        WeightInfo.create = function create(properties) {
            return new WeightInfo(properties);
        };

        /**
         * Encodes the specified WeightInfo message. Does not implicitly {@link mesos.WeightInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.WeightInfo
         * @static
         * @param {mesos.IWeightInfo} message WeightInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeightInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.weight);
            if (message.role != null && message.hasOwnProperty("role"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.role);
            return writer;
        };

        /**
         * Encodes the specified WeightInfo message, length delimited. Does not implicitly {@link mesos.WeightInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.WeightInfo
         * @static
         * @param {mesos.IWeightInfo} message WeightInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WeightInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WeightInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.WeightInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.WeightInfo} WeightInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeightInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.WeightInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.weight = reader.double();
                    break;
                case 2:
                    message.role = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("weight"))
                throw $util.ProtocolError("missing required 'weight'", { instance: message });
            return message;
        };

        /**
         * Decodes a WeightInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.WeightInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.WeightInfo} WeightInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WeightInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WeightInfo message.
         * @function verify
         * @memberof mesos.WeightInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WeightInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.weight !== "number")
                return "weight: number expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            return null;
        };

        /**
         * Creates a WeightInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.WeightInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.WeightInfo} WeightInfo
         */
        WeightInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.WeightInfo)
                return object;
            let message = new $root.mesos.WeightInfo();
            if (object.weight != null)
                message.weight = Number(object.weight);
            if (object.role != null)
                message.role = String(object.role);
            return message;
        };

        /**
         * Creates a plain object from a WeightInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.WeightInfo
         * @static
         * @param {mesos.WeightInfo} message WeightInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WeightInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.weight = 0;
                object.role = "";
            }
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            return object;
        };

        /**
         * Converts this WeightInfo to JSON.
         * @function toJSON
         * @memberof mesos.WeightInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WeightInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WeightInfo;
    })();

    mesos.VersionInfo = (function() {

        /**
         * Properties of a VersionInfo.
         * @memberof mesos
         * @interface IVersionInfo
         * @property {string} version VersionInfo version
         * @property {string} [buildDate] VersionInfo buildDate
         * @property {number} [buildTime] VersionInfo buildTime
         * @property {string} [buildUser] VersionInfo buildUser
         * @property {string} [gitSha] VersionInfo gitSha
         * @property {string} [gitBranch] VersionInfo gitBranch
         * @property {string} [gitTag] VersionInfo gitTag
         */

        /**
         * Constructs a new VersionInfo.
         * @memberof mesos
         * @classdesc Version information of a component.
         * @constructor
         * @param {mesos.IVersionInfo=} [properties] Properties to set
         */
        function VersionInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VersionInfo version.
         * @member {string}version
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.version = "";

        /**
         * VersionInfo buildDate.
         * @member {string}buildDate
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.buildDate = "";

        /**
         * VersionInfo buildTime.
         * @member {number}buildTime
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.buildTime = 0;

        /**
         * VersionInfo buildUser.
         * @member {string}buildUser
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.buildUser = "";

        /**
         * VersionInfo gitSha.
         * @member {string}gitSha
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.gitSha = "";

        /**
         * VersionInfo gitBranch.
         * @member {string}gitBranch
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.gitBranch = "";

        /**
         * VersionInfo gitTag.
         * @member {string}gitTag
         * @memberof mesos.VersionInfo
         * @instance
         */
        VersionInfo.prototype.gitTag = "";

        /**
         * Creates a new VersionInfo instance using the specified properties.
         * @function create
         * @memberof mesos.VersionInfo
         * @static
         * @param {mesos.IVersionInfo=} [properties] Properties to set
         * @returns {mesos.VersionInfo} VersionInfo instance
         */
        VersionInfo.create = function create(properties) {
            return new VersionInfo(properties);
        };

        /**
         * Encodes the specified VersionInfo message. Does not implicitly {@link mesos.VersionInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.VersionInfo
         * @static
         * @param {mesos.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.buildDate);
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.buildTime);
            if (message.buildUser != null && message.hasOwnProperty("buildUser"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.buildUser);
            if (message.gitSha != null && message.hasOwnProperty("gitSha"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.gitSha);
            if (message.gitBranch != null && message.hasOwnProperty("gitBranch"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gitBranch);
            if (message.gitTag != null && message.hasOwnProperty("gitTag"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.gitTag);
            return writer;
        };

        /**
         * Encodes the specified VersionInfo message, length delimited. Does not implicitly {@link mesos.VersionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.VersionInfo
         * @static
         * @param {mesos.IVersionInfo} message VersionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.VersionInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.string();
                    break;
                case 2:
                    message.buildDate = reader.string();
                    break;
                case 3:
                    message.buildTime = reader.double();
                    break;
                case 4:
                    message.buildUser = reader.string();
                    break;
                case 5:
                    message.gitSha = reader.string();
                    break;
                case 6:
                    message.gitBranch = reader.string();
                    break;
                case 7:
                    message.gitTag = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("version"))
                throw $util.ProtocolError("missing required 'version'", { instance: message });
            return message;
        };

        /**
         * Decodes a VersionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.VersionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.VersionInfo} VersionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionInfo message.
         * @function verify
         * @memberof mesos.VersionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.version))
                return "version: string expected";
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                if (!$util.isString(message.buildDate))
                    return "buildDate: string expected";
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                if (typeof message.buildTime !== "number")
                    return "buildTime: number expected";
            if (message.buildUser != null && message.hasOwnProperty("buildUser"))
                if (!$util.isString(message.buildUser))
                    return "buildUser: string expected";
            if (message.gitSha != null && message.hasOwnProperty("gitSha"))
                if (!$util.isString(message.gitSha))
                    return "gitSha: string expected";
            if (message.gitBranch != null && message.hasOwnProperty("gitBranch"))
                if (!$util.isString(message.gitBranch))
                    return "gitBranch: string expected";
            if (message.gitTag != null && message.hasOwnProperty("gitTag"))
                if (!$util.isString(message.gitTag))
                    return "gitTag: string expected";
            return null;
        };

        /**
         * Creates a VersionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.VersionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.VersionInfo} VersionInfo
         */
        VersionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.VersionInfo)
                return object;
            let message = new $root.mesos.VersionInfo();
            if (object.version != null)
                message.version = String(object.version);
            if (object.buildDate != null)
                message.buildDate = String(object.buildDate);
            if (object.buildTime != null)
                message.buildTime = Number(object.buildTime);
            if (object.buildUser != null)
                message.buildUser = String(object.buildUser);
            if (object.gitSha != null)
                message.gitSha = String(object.gitSha);
            if (object.gitBranch != null)
                message.gitBranch = String(object.gitBranch);
            if (object.gitTag != null)
                message.gitTag = String(object.gitTag);
            return message;
        };

        /**
         * Creates a plain object from a VersionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.VersionInfo
         * @static
         * @param {mesos.VersionInfo} message VersionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.version = "";
                object.buildDate = "";
                object.buildTime = 0;
                object.buildUser = "";
                object.gitSha = "";
                object.gitBranch = "";
                object.gitTag = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                object.buildDate = message.buildDate;
            if (message.buildTime != null && message.hasOwnProperty("buildTime"))
                object.buildTime = options.json && !isFinite(message.buildTime) ? String(message.buildTime) : message.buildTime;
            if (message.buildUser != null && message.hasOwnProperty("buildUser"))
                object.buildUser = message.buildUser;
            if (message.gitSha != null && message.hasOwnProperty("gitSha"))
                object.gitSha = message.gitSha;
            if (message.gitBranch != null && message.hasOwnProperty("gitBranch"))
                object.gitBranch = message.gitBranch;
            if (message.gitTag != null && message.hasOwnProperty("gitTag"))
                object.gitTag = message.gitTag;
            return object;
        };

        /**
         * Converts this VersionInfo to JSON.
         * @function toJSON
         * @memberof mesos.VersionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionInfo;
    })();

    mesos.Flag = (function() {

        /**
         * Properties of a Flag.
         * @memberof mesos
         * @interface IFlag
         * @property {string} name Flag name
         * @property {string} [value] Flag value
         */

        /**
         * Constructs a new Flag.
         * @memberof mesos
         * @classdesc Flag consists of a name and optionally its value.
         * @constructor
         * @param {mesos.IFlag=} [properties] Properties to set
         */
        function Flag(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Flag name.
         * @member {string}name
         * @memberof mesos.Flag
         * @instance
         */
        Flag.prototype.name = "";

        /**
         * Flag value.
         * @member {string}value
         * @memberof mesos.Flag
         * @instance
         */
        Flag.prototype.value = "";

        /**
         * Creates a new Flag instance using the specified properties.
         * @function create
         * @memberof mesos.Flag
         * @static
         * @param {mesos.IFlag=} [properties] Properties to set
         * @returns {mesos.Flag} Flag instance
         */
        Flag.create = function create(properties) {
            return new Flag(properties);
        };

        /**
         * Encodes the specified Flag message. Does not implicitly {@link mesos.Flag.verify|verify} messages.
         * @function encode
         * @memberof mesos.Flag
         * @static
         * @param {mesos.IFlag} message Flag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Flag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified Flag message, length delimited. Does not implicitly {@link mesos.Flag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Flag
         * @static
         * @param {mesos.IFlag} message Flag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Flag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Flag message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Flag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Flag} Flag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Flag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Flag();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a Flag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Flag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Flag} Flag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Flag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Flag message.
         * @function verify
         * @memberof mesos.Flag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Flag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a Flag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Flag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Flag} Flag
         */
        Flag.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Flag)
                return object;
            let message = new $root.mesos.Flag();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Flag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Flag
         * @static
         * @param {mesos.Flag} message Flag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Flag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this Flag to JSON.
         * @function toJSON
         * @memberof mesos.Flag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Flag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Flag;
    })();

    mesos.Role = (function() {

        /**
         * Properties of a Role.
         * @memberof mesos
         * @interface IRole
         * @property {string} name Role name
         * @property {number} weight Role weight
         * @property {Array.<mesos.IFrameworkID>} [frameworks] Role frameworks
         * @property {Array.<mesos.IResource>} [resources] Role resources
         */

        /**
         * Constructs a new Role.
         * @memberof mesos
         * @classdesc Describes a Role. Roles can be used to specify that certain resources are
         * reserved for the use of one or more frameworks.
         * @constructor
         * @param {mesos.IRole=} [properties] Properties to set
         */
        function Role(properties) {
            this.frameworks = [];
            this.resources = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Role name.
         * @member {string}name
         * @memberof mesos.Role
         * @instance
         */
        Role.prototype.name = "";

        /**
         * Role weight.
         * @member {number}weight
         * @memberof mesos.Role
         * @instance
         */
        Role.prototype.weight = 0;

        /**
         * Role frameworks.
         * @member {Array.<mesos.IFrameworkID>}frameworks
         * @memberof mesos.Role
         * @instance
         */
        Role.prototype.frameworks = $util.emptyArray;

        /**
         * Role resources.
         * @member {Array.<mesos.IResource>}resources
         * @memberof mesos.Role
         * @instance
         */
        Role.prototype.resources = $util.emptyArray;

        /**
         * Creates a new Role instance using the specified properties.
         * @function create
         * @memberof mesos.Role
         * @static
         * @param {mesos.IRole=} [properties] Properties to set
         * @returns {mesos.Role} Role instance
         */
        Role.create = function create(properties) {
            return new Role(properties);
        };

        /**
         * Encodes the specified Role message. Does not implicitly {@link mesos.Role.verify|verify} messages.
         * @function encode
         * @memberof mesos.Role
         * @static
         * @param {mesos.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.weight);
            if (message.frameworks != null && message.frameworks.length)
                for (let i = 0; i < message.frameworks.length; ++i)
                    $root.mesos.FrameworkID.encode(message.frameworks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                    $root.mesos.Resource.encode(message.resources[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Role message, length delimited. Does not implicitly {@link mesos.Role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Role
         * @static
         * @param {mesos.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Role message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Role();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.weight = reader.double();
                    break;
                case 3:
                    if (!(message.frameworks && message.frameworks.length))
                        message.frameworks = [];
                    message.frameworks.push($root.mesos.FrameworkID.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.resources && message.resources.length))
                        message.resources = [];
                    message.resources.push($root.mesos.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("weight"))
                throw $util.ProtocolError("missing required 'weight'", { instance: message });
            return message;
        };

        /**
         * Decodes a Role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Role message.
         * @function verify
         * @memberof mesos.Role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.weight !== "number")
                return "weight: number expected";
            if (message.frameworks != null && message.hasOwnProperty("frameworks")) {
                if (!Array.isArray(message.frameworks))
                    return "frameworks: array expected";
                for (let i = 0; i < message.frameworks.length; ++i) {
                    let error = $root.mesos.FrameworkID.verify(message.frameworks[i]);
                    if (error)
                        return "frameworks." + error;
                }
            }
            if (message.resources != null && message.hasOwnProperty("resources")) {
                if (!Array.isArray(message.resources))
                    return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                    error = $root.mesos.Resource.verify(message.resources[i]);
                    if (error)
                        return "resources." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Role} Role
         */
        Role.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Role)
                return object;
            let message = new $root.mesos.Role();
            if (object.name != null)
                message.name = String(object.name);
            if (object.weight != null)
                message.weight = Number(object.weight);
            if (object.frameworks) {
                if (!Array.isArray(object.frameworks))
                    throw TypeError(".mesos.Role.frameworks: array expected");
                message.frameworks = [];
                for (let i = 0; i < object.frameworks.length; ++i) {
                    if (typeof object.frameworks[i] !== "object")
                        throw TypeError(".mesos.Role.frameworks: object expected");
                    message.frameworks[i] = $root.mesos.FrameworkID.fromObject(object.frameworks[i]);
                }
            }
            if (object.resources) {
                if (!Array.isArray(object.resources))
                    throw TypeError(".mesos.Role.resources: array expected");
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                    if (typeof object.resources[i] !== "object")
                        throw TypeError(".mesos.Role.resources: object expected");
                    message.resources[i] = $root.mesos.Resource.fromObject(object.resources[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Role
         * @static
         * @param {mesos.Role} message Role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.frameworks = [];
                object.resources = [];
            }
            if (options.defaults) {
                object.name = "";
                object.weight = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
            if (message.frameworks && message.frameworks.length) {
                object.frameworks = [];
                for (let j = 0; j < message.frameworks.length; ++j)
                    object.frameworks[j] = $root.mesos.FrameworkID.toObject(message.frameworks[j], options);
            }
            if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                    object.resources[j] = $root.mesos.Resource.toObject(message.resources[j], options);
            }
            return object;
        };

        /**
         * Converts this Role to JSON.
         * @function toJSON
         * @memberof mesos.Role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Role;
    })();

    mesos.Metric = (function() {

        /**
         * Properties of a Metric.
         * @memberof mesos
         * @interface IMetric
         * @property {string} name Metric name
         * @property {number} [value] Metric value
         */

        /**
         * Constructs a new Metric.
         * @memberof mesos
         * @classdesc Metric consists of a name and optionally its value.
         * @constructor
         * @param {mesos.IMetric=} [properties] Properties to set
         */
        function Metric(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metric name.
         * @member {string}name
         * @memberof mesos.Metric
         * @instance
         */
        Metric.prototype.name = "";

        /**
         * Metric value.
         * @member {number}value
         * @memberof mesos.Metric
         * @instance
         */
        Metric.prototype.value = 0;

        /**
         * Creates a new Metric instance using the specified properties.
         * @function create
         * @memberof mesos.Metric
         * @static
         * @param {mesos.IMetric=} [properties] Properties to set
         * @returns {mesos.Metric} Metric instance
         */
        Metric.create = function create(properties) {
            return new Metric(properties);
        };

        /**
         * Encodes the specified Metric message. Does not implicitly {@link mesos.Metric.verify|verify} messages.
         * @function encode
         * @memberof mesos.Metric
         * @static
         * @param {mesos.IMetric} message Metric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metric.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
            return writer;
        };

        /**
         * Encodes the specified Metric message, length delimited. Does not implicitly {@link mesos.Metric.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.Metric
         * @static
         * @param {mesos.IMetric} message Metric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metric.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metric message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.Metric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.Metric} Metric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metric.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.Metric();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a Metric message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.Metric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.Metric} Metric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metric.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metric message.
         * @function verify
         * @memberof mesos.Metric
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metric.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            return null;
        };

        /**
         * Creates a Metric message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.Metric
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.Metric} Metric
         */
        Metric.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.Metric)
                return object;
            let message = new $root.mesos.Metric();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = Number(object.value);
            return message;
        };

        /**
         * Creates a plain object from a Metric message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.Metric
         * @static
         * @param {mesos.Metric} message Metric
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metric.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.value = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            return object;
        };

        /**
         * Converts this Metric to JSON.
         * @function toJSON
         * @memberof mesos.Metric
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metric.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Metric;
    })();

    mesos.FileInfo = (function() {

        /**
         * Properties of a FileInfo.
         * @memberof mesos
         * @interface IFileInfo
         * @property {string} path FileInfo path
         * @property {number} [nlink] FileInfo nlink
         * @property {number} [size] FileInfo size
         * @property {mesos.ITimeInfo} [mtime] FileInfo mtime
         * @property {number} [mode] FileInfo mode
         * @property {string} [uid] FileInfo uid
         * @property {string} [gid] FileInfo gid
         */

        /**
         * Constructs a new FileInfo.
         * @memberof mesos
         * @classdesc Describes a File.
         * @constructor
         * @param {mesos.IFileInfo=} [properties] Properties to set
         */
        function FileInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileInfo path.
         * @member {string}path
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.path = "";

        /**
         * FileInfo nlink.
         * @member {number}nlink
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.nlink = 0;

        /**
         * FileInfo size.
         * @member {number}size
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.size = 0;

        /**
         * FileInfo mtime.
         * @member {(mesos.ITimeInfo|null|undefined)}mtime
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.mtime = null;

        /**
         * FileInfo mode.
         * @member {number}mode
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.mode = 0;

        /**
         * FileInfo uid.
         * @member {string}uid
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.uid = "";

        /**
         * FileInfo gid.
         * @member {string}gid
         * @memberof mesos.FileInfo
         * @instance
         */
        FileInfo.prototype.gid = "";

        /**
         * Creates a new FileInfo instance using the specified properties.
         * @function create
         * @memberof mesos.FileInfo
         * @static
         * @param {mesos.IFileInfo=} [properties] Properties to set
         * @returns {mesos.FileInfo} FileInfo instance
         */
        FileInfo.create = function create(properties) {
            return new FileInfo(properties);
        };

        /**
         * Encodes the specified FileInfo message. Does not implicitly {@link mesos.FileInfo.verify|verify} messages.
         * @function encode
         * @memberof mesos.FileInfo
         * @static
         * @param {mesos.IFileInfo} message FileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
            if (message.nlink != null && message.hasOwnProperty("nlink"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nlink);
            if (message.size != null && message.hasOwnProperty("size"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.size);
            if (message.mtime != null && message.hasOwnProperty("mtime"))
                $root.mesos.TimeInfo.encode(message.mtime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.mode != null && message.hasOwnProperty("mode"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.mode);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.uid);
            if (message.gid != null && message.hasOwnProperty("gid"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.gid);
            return writer;
        };

        /**
         * Encodes the specified FileInfo message, length delimited. Does not implicitly {@link mesos.FileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mesos.FileInfo
         * @static
         * @param {mesos.IFileInfo} message FileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mesos.FileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mesos.FileInfo} FileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.FileInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.path = reader.string();
                    break;
                case 2:
                    message.nlink = reader.int32();
                    break;
                case 3:
                    message.size = reader.uint32();
                    break;
                case 4:
                    message.mtime = $root.mesos.TimeInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.mode = reader.uint32();
                    break;
                case 6:
                    message.uid = reader.string();
                    break;
                case 7:
                    message.gid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("path"))
                throw $util.ProtocolError("missing required 'path'", { instance: message });
            return message;
        };

        /**
         * Decodes a FileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mesos.FileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mesos.FileInfo} FileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileInfo message.
         * @function verify
         * @memberof mesos.FileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.path))
                return "path: string expected";
            if (message.nlink != null && message.hasOwnProperty("nlink"))
                if (!$util.isInteger(message.nlink))
                    return "nlink: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.mtime != null && message.hasOwnProperty("mtime")) {
                let error = $root.mesos.TimeInfo.verify(message.mtime);
                if (error)
                    return "mtime." + error;
            }
            if (message.mode != null && message.hasOwnProperty("mode"))
                if (!$util.isInteger(message.mode))
                    return "mode: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isString(message.uid))
                    return "uid: string expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isString(message.gid))
                    return "gid: string expected";
            return null;
        };

        /**
         * Creates a FileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mesos.FileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mesos.FileInfo} FileInfo
         */
        FileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mesos.FileInfo)
                return object;
            let message = new $root.mesos.FileInfo();
            if (object.path != null)
                message.path = String(object.path);
            if (object.nlink != null)
                message.nlink = object.nlink | 0;
            if (object.size != null)
                message.size = object.size >>> 0;
            if (object.mtime != null) {
                if (typeof object.mtime !== "object")
                    throw TypeError(".mesos.FileInfo.mtime: object expected");
                message.mtime = $root.mesos.TimeInfo.fromObject(object.mtime);
            }
            if (object.mode != null)
                message.mode = object.mode >>> 0;
            if (object.uid != null)
                message.uid = String(object.uid);
            if (object.gid != null)
                message.gid = String(object.gid);
            return message;
        };

        /**
         * Creates a plain object from a FileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mesos.FileInfo
         * @static
         * @param {mesos.FileInfo} message FileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.path = "";
                object.nlink = 0;
                object.size = 0;
                object.mtime = null;
                object.mode = 0;
                object.uid = "";
                object.gid = "";
            }
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.nlink != null && message.hasOwnProperty("nlink"))
                object.nlink = message.nlink;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.mtime != null && message.hasOwnProperty("mtime"))
                object.mtime = $root.mesos.TimeInfo.toObject(message.mtime, options);
            if (message.mode != null && message.hasOwnProperty("mode"))
                object.mode = message.mode;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            return object;
        };

        /**
         * Converts this FileInfo to JSON.
         * @function toJSON
         * @memberof mesos.FileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileInfo;
    })();

    mesos.scheduler = (function() {

        /**
         * Namespace scheduler.
         * @memberof mesos
         * @namespace
         */
        const scheduler = {};

        scheduler.Event = (function() {

            /**
             * Properties of an Event.
             * @memberof mesos.scheduler
             * @interface IEvent
             * @property {mesos.scheduler.Event.Type} [type] Event type
             * @property {mesos.scheduler.Event.ISubscribed} [subscribed] Event subscribed
             * @property {mesos.scheduler.Event.IOffers} [offers] Event offers
             * @property {mesos.scheduler.Event.IInverseOffers} [inverseOffers] Event inverseOffers
             * @property {mesos.scheduler.Event.IRescind} [rescind] Event rescind
             * @property {mesos.scheduler.Event.IRescindInverseOffer} [rescindInverseOffer] Event rescindInverseOffer
             * @property {mesos.scheduler.Event.IUpdate} [update] Event update
             * @property {mesos.scheduler.Event.IMessage} [message] Event message
             * @property {mesos.scheduler.Event.IFailure} [failure] Event failure
             * @property {mesos.scheduler.Event.IError} [error] Event error
             */

            /**
             * Constructs a new Event.
             * @memberof mesos.scheduler
             * @classdesc Scheduler event API.
             * 
             * An event is described using the standard protocol buffer "union"
             * trick, see:
             * https://developers.google.com/protocol-buffers/docs/techniques#union.
             * @constructor
             * @param {mesos.scheduler.IEvent=} [properties] Properties to set
             */
            function Event(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Event type.
             * @member {mesos.scheduler.Event.Type}type
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.type = 0;

            /**
             * Event subscribed.
             * @member {(mesos.scheduler.Event.ISubscribed|null|undefined)}subscribed
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.subscribed = null;

            /**
             * Event offers.
             * @member {(mesos.scheduler.Event.IOffers|null|undefined)}offers
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.offers = null;

            /**
             * Event inverseOffers.
             * @member {(mesos.scheduler.Event.IInverseOffers|null|undefined)}inverseOffers
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.inverseOffers = null;

            /**
             * Event rescind.
             * @member {(mesos.scheduler.Event.IRescind|null|undefined)}rescind
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.rescind = null;

            /**
             * Event rescindInverseOffer.
             * @member {(mesos.scheduler.Event.IRescindInverseOffer|null|undefined)}rescindInverseOffer
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.rescindInverseOffer = null;

            /**
             * Event update.
             * @member {(mesos.scheduler.Event.IUpdate|null|undefined)}update
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.update = null;

            /**
             * Event message.
             * @member {(mesos.scheduler.Event.IMessage|null|undefined)}message
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.message = null;

            /**
             * Event failure.
             * @member {(mesos.scheduler.Event.IFailure|null|undefined)}failure
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.failure = null;

            /**
             * Event error.
             * @member {(mesos.scheduler.Event.IError|null|undefined)}error
             * @memberof mesos.scheduler.Event
             * @instance
             */
            Event.prototype.error = null;

            /**
             * Creates a new Event instance using the specified properties.
             * @function create
             * @memberof mesos.scheduler.Event
             * @static
             * @param {mesos.scheduler.IEvent=} [properties] Properties to set
             * @returns {mesos.scheduler.Event} Event instance
             */
            Event.create = function create(properties) {
                return new Event(properties);
            };

            /**
             * Encodes the specified Event message. Does not implicitly {@link mesos.scheduler.Event.verify|verify} messages.
             * @function encode
             * @memberof mesos.scheduler.Event
             * @static
             * @param {mesos.scheduler.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.subscribed != null && message.hasOwnProperty("subscribed"))
                    $root.mesos.scheduler.Event.Subscribed.encode(message.subscribed, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.offers != null && message.hasOwnProperty("offers"))
                    $root.mesos.scheduler.Event.Offers.encode(message.offers, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.rescind != null && message.hasOwnProperty("rescind"))
                    $root.mesos.scheduler.Event.Rescind.encode(message.rescind, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.update != null && message.hasOwnProperty("update"))
                    $root.mesos.scheduler.Event.Update.encode(message.update, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    $root.mesos.scheduler.Event.Message.encode(message.message, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.failure != null && message.hasOwnProperty("failure"))
                    $root.mesos.scheduler.Event.Failure.encode(message.failure, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.mesos.scheduler.Event.Error.encode(message.error, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.inverseOffers != null && message.hasOwnProperty("inverseOffers"))
                    $root.mesos.scheduler.Event.InverseOffers.encode(message.inverseOffers, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.rescindInverseOffer != null && message.hasOwnProperty("rescindInverseOffer"))
                    $root.mesos.scheduler.Event.RescindInverseOffer.encode(message.rescindInverseOffer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Event message, length delimited. Does not implicitly {@link mesos.scheduler.Event.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.scheduler.Event
             * @static
             * @param {mesos.scheduler.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Event message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.scheduler.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.scheduler.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.subscribed = $root.mesos.scheduler.Event.Subscribed.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.offers = $root.mesos.scheduler.Event.Offers.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.inverseOffers = $root.mesos.scheduler.Event.InverseOffers.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.rescind = $root.mesos.scheduler.Event.Rescind.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.rescindInverseOffer = $root.mesos.scheduler.Event.RescindInverseOffer.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.update = $root.mesos.scheduler.Event.Update.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.message = $root.mesos.scheduler.Event.Message.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.failure = $root.mesos.scheduler.Event.Failure.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.error = $root.mesos.scheduler.Event.Error.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Event message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.scheduler.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.scheduler.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Event message.
             * @function verify
             * @memberof mesos.scheduler.Event
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 9:
                    case 3:
                    case 10:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.subscribed != null && message.hasOwnProperty("subscribed")) {
                    let error = $root.mesos.scheduler.Event.Subscribed.verify(message.subscribed);
                    if (error)
                        return "subscribed." + error;
                }
                if (message.offers != null && message.hasOwnProperty("offers")) {
                    error = $root.mesos.scheduler.Event.Offers.verify(message.offers);
                    if (error)
                        return "offers." + error;
                }
                if (message.inverseOffers != null && message.hasOwnProperty("inverseOffers")) {
                    error = $root.mesos.scheduler.Event.InverseOffers.verify(message.inverseOffers);
                    if (error)
                        return "inverseOffers." + error;
                }
                if (message.rescind != null && message.hasOwnProperty("rescind")) {
                    error = $root.mesos.scheduler.Event.Rescind.verify(message.rescind);
                    if (error)
                        return "rescind." + error;
                }
                if (message.rescindInverseOffer != null && message.hasOwnProperty("rescindInverseOffer")) {
                    error = $root.mesos.scheduler.Event.RescindInverseOffer.verify(message.rescindInverseOffer);
                    if (error)
                        return "rescindInverseOffer." + error;
                }
                if (message.update != null && message.hasOwnProperty("update")) {
                    error = $root.mesos.scheduler.Event.Update.verify(message.update);
                    if (error)
                        return "update." + error;
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    error = $root.mesos.scheduler.Event.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                if (message.failure != null && message.hasOwnProperty("failure")) {
                    error = $root.mesos.scheduler.Event.Failure.verify(message.failure);
                    if (error)
                        return "failure." + error;
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    error = $root.mesos.scheduler.Event.Error.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                return null;
            };

            /**
             * Creates an Event message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.scheduler.Event
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.scheduler.Event} Event
             */
            Event.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.scheduler.Event)
                    return object;
                let message = new $root.mesos.scheduler.Event();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "SUBSCRIBED":
                case 1:
                    message.type = 1;
                    break;
                case "OFFERS":
                case 2:
                    message.type = 2;
                    break;
                case "INVERSE_OFFERS":
                case 9:
                    message.type = 9;
                    break;
                case "RESCIND":
                case 3:
                    message.type = 3;
                    break;
                case "RESCIND_INVERSE_OFFER":
                case 10:
                    message.type = 10;
                    break;
                case "UPDATE":
                case 4:
                    message.type = 4;
                    break;
                case "MESSAGE":
                case 5:
                    message.type = 5;
                    break;
                case "FAILURE":
                case 6:
                    message.type = 6;
                    break;
                case "ERROR":
                case 7:
                    message.type = 7;
                    break;
                case "HEARTBEAT":
                case 8:
                    message.type = 8;
                    break;
                }
                if (object.subscribed != null) {
                    if (typeof object.subscribed !== "object")
                        throw TypeError(".mesos.scheduler.Event.subscribed: object expected");
                    message.subscribed = $root.mesos.scheduler.Event.Subscribed.fromObject(object.subscribed);
                }
                if (object.offers != null) {
                    if (typeof object.offers !== "object")
                        throw TypeError(".mesos.scheduler.Event.offers: object expected");
                    message.offers = $root.mesos.scheduler.Event.Offers.fromObject(object.offers);
                }
                if (object.inverseOffers != null) {
                    if (typeof object.inverseOffers !== "object")
                        throw TypeError(".mesos.scheduler.Event.inverseOffers: object expected");
                    message.inverseOffers = $root.mesos.scheduler.Event.InverseOffers.fromObject(object.inverseOffers);
                }
                if (object.rescind != null) {
                    if (typeof object.rescind !== "object")
                        throw TypeError(".mesos.scheduler.Event.rescind: object expected");
                    message.rescind = $root.mesos.scheduler.Event.Rescind.fromObject(object.rescind);
                }
                if (object.rescindInverseOffer != null) {
                    if (typeof object.rescindInverseOffer !== "object")
                        throw TypeError(".mesos.scheduler.Event.rescindInverseOffer: object expected");
                    message.rescindInverseOffer = $root.mesos.scheduler.Event.RescindInverseOffer.fromObject(object.rescindInverseOffer);
                }
                if (object.update != null) {
                    if (typeof object.update !== "object")
                        throw TypeError(".mesos.scheduler.Event.update: object expected");
                    message.update = $root.mesos.scheduler.Event.Update.fromObject(object.update);
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".mesos.scheduler.Event.message: object expected");
                    message.message = $root.mesos.scheduler.Event.Message.fromObject(object.message);
                }
                if (object.failure != null) {
                    if (typeof object.failure !== "object")
                        throw TypeError(".mesos.scheduler.Event.failure: object expected");
                    message.failure = $root.mesos.scheduler.Event.Failure.fromObject(object.failure);
                }
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".mesos.scheduler.Event.error: object expected");
                    message.error = $root.mesos.scheduler.Event.Error.fromObject(object.error);
                }
                return message;
            };

            /**
             * Creates a plain object from an Event message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.scheduler.Event
             * @static
             * @param {mesos.scheduler.Event} message Event
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Event.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.subscribed = null;
                    object.offers = null;
                    object.rescind = null;
                    object.update = null;
                    object.message = null;
                    object.failure = null;
                    object.error = null;
                    object.inverseOffers = null;
                    object.rescindInverseOffer = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.scheduler.Event.Type[message.type] : message.type;
                if (message.subscribed != null && message.hasOwnProperty("subscribed"))
                    object.subscribed = $root.mesos.scheduler.Event.Subscribed.toObject(message.subscribed, options);
                if (message.offers != null && message.hasOwnProperty("offers"))
                    object.offers = $root.mesos.scheduler.Event.Offers.toObject(message.offers, options);
                if (message.rescind != null && message.hasOwnProperty("rescind"))
                    object.rescind = $root.mesos.scheduler.Event.Rescind.toObject(message.rescind, options);
                if (message.update != null && message.hasOwnProperty("update"))
                    object.update = $root.mesos.scheduler.Event.Update.toObject(message.update, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.mesos.scheduler.Event.Message.toObject(message.message, options);
                if (message.failure != null && message.hasOwnProperty("failure"))
                    object.failure = $root.mesos.scheduler.Event.Failure.toObject(message.failure, options);
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.mesos.scheduler.Event.Error.toObject(message.error, options);
                if (message.inverseOffers != null && message.hasOwnProperty("inverseOffers"))
                    object.inverseOffers = $root.mesos.scheduler.Event.InverseOffers.toObject(message.inverseOffers, options);
                if (message.rescindInverseOffer != null && message.hasOwnProperty("rescindInverseOffer"))
                    object.rescindInverseOffer = $root.mesos.scheduler.Event.RescindInverseOffer.toObject(message.rescindInverseOffer, options);
                return object;
            };

            /**
             * Converts this Event to JSON.
             * @function toJSON
             * @memberof mesos.scheduler.Event
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUBSCRIBED=1 SUBSCRIBED value
             * @property {number} OFFERS=2 OFFERS value
             * @property {number} INVERSE_OFFERS=9 INVERSE_OFFERS value
             * @property {number} RESCIND=3 RESCIND value
             * @property {number} RESCIND_INVERSE_OFFER=10 RESCIND_INVERSE_OFFER value
             * @property {number} UPDATE=4 UPDATE value
             * @property {number} MESSAGE=5 MESSAGE value
             * @property {number} FAILURE=6 FAILURE value
             * @property {number} ERROR=7 ERROR value
             * @property {number} HEARTBEAT=8 HEARTBEAT value
             */
            Event.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUBSCRIBED"] = 1;
                values[valuesById[2] = "OFFERS"] = 2;
                values[valuesById[9] = "INVERSE_OFFERS"] = 9;
                values[valuesById[3] = "RESCIND"] = 3;
                values[valuesById[10] = "RESCIND_INVERSE_OFFER"] = 10;
                values[valuesById[4] = "UPDATE"] = 4;
                values[valuesById[5] = "MESSAGE"] = 5;
                values[valuesById[6] = "FAILURE"] = 6;
                values[valuesById[7] = "ERROR"] = 7;
                values[valuesById[8] = "HEARTBEAT"] = 8;
                return values;
            })();

            Event.Subscribed = (function() {

                /**
                 * Properties of a Subscribed.
                 * @memberof mesos.scheduler.Event
                 * @interface ISubscribed
                 * @property {mesos.IFrameworkID} frameworkId Subscribed frameworkId
                 * @property {number} [heartbeatIntervalSeconds] Subscribed heartbeatIntervalSeconds
                 * @property {mesos.IMasterInfo} [masterInfo] Subscribed masterInfo
                 */

                /**
                 * Constructs a new Subscribed.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents a Subscribed.
                 * @constructor
                 * @param {mesos.scheduler.Event.ISubscribed=} [properties] Properties to set
                 */
                function Subscribed(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subscribed frameworkId.
                 * @member {mesos.IFrameworkID}frameworkId
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.frameworkId = null;

                /**
                 * Subscribed heartbeatIntervalSeconds.
                 * @member {number}heartbeatIntervalSeconds
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.heartbeatIntervalSeconds = 0;

                /**
                 * Subscribed masterInfo.
                 * @member {(mesos.IMasterInfo|null|undefined)}masterInfo
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.masterInfo = null;

                /**
                 * Creates a new Subscribed instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {mesos.scheduler.Event.ISubscribed=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Subscribed} Subscribed instance
                 */
                Subscribed.create = function create(properties) {
                    return new Subscribed(properties);
                };

                /**
                 * Encodes the specified Subscribed message. Does not implicitly {@link mesos.scheduler.Event.Subscribed.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {mesos.scheduler.Event.ISubscribed} message Subscribed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribed.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.heartbeatIntervalSeconds != null && message.hasOwnProperty("heartbeatIntervalSeconds"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.heartbeatIntervalSeconds);
                    if (message.masterInfo != null && message.hasOwnProperty("masterInfo"))
                        $root.mesos.MasterInfo.encode(message.masterInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Subscribed message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Subscribed.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {mesos.scheduler.Event.ISubscribed} message Subscribed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribed.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subscribed message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Subscribed} Subscribed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribed.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Subscribed();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.heartbeatIntervalSeconds = reader.double();
                            break;
                        case 3:
                            message.masterInfo = $root.mesos.MasterInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("frameworkId"))
                        throw $util.ProtocolError("missing required 'frameworkId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Subscribed message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Subscribed} Subscribed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribed.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subscribed message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subscribed.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.FrameworkID.verify(message.frameworkId);
                    if (error)
                        return "frameworkId." + error;
                    if (message.heartbeatIntervalSeconds != null && message.hasOwnProperty("heartbeatIntervalSeconds"))
                        if (typeof message.heartbeatIntervalSeconds !== "number")
                            return "heartbeatIntervalSeconds: number expected";
                    if (message.masterInfo != null && message.hasOwnProperty("masterInfo")) {
                        error = $root.mesos.MasterInfo.verify(message.masterInfo);
                        if (error)
                            return "masterInfo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Subscribed message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Subscribed} Subscribed
                 */
                Subscribed.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Subscribed)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Subscribed();
                    if (object.frameworkId != null) {
                        if (typeof object.frameworkId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Subscribed.frameworkId: object expected");
                        message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
                    }
                    if (object.heartbeatIntervalSeconds != null)
                        message.heartbeatIntervalSeconds = Number(object.heartbeatIntervalSeconds);
                    if (object.masterInfo != null) {
                        if (typeof object.masterInfo !== "object")
                            throw TypeError(".mesos.scheduler.Event.Subscribed.masterInfo: object expected");
                        message.masterInfo = $root.mesos.MasterInfo.fromObject(object.masterInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subscribed message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @static
                 * @param {mesos.scheduler.Event.Subscribed} message Subscribed
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subscribed.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.frameworkId = null;
                        object.heartbeatIntervalSeconds = 0;
                        object.masterInfo = null;
                    }
                    if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                        object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
                    if (message.heartbeatIntervalSeconds != null && message.hasOwnProperty("heartbeatIntervalSeconds"))
                        object.heartbeatIntervalSeconds = options.json && !isFinite(message.heartbeatIntervalSeconds) ? String(message.heartbeatIntervalSeconds) : message.heartbeatIntervalSeconds;
                    if (message.masterInfo != null && message.hasOwnProperty("masterInfo"))
                        object.masterInfo = $root.mesos.MasterInfo.toObject(message.masterInfo, options);
                    return object;
                };

                /**
                 * Converts this Subscribed to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Subscribed
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subscribed.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subscribed;
            })();

            Event.Offers = (function() {

                /**
                 * Properties of an Offers.
                 * @memberof mesos.scheduler.Event
                 * @interface IOffers
                 * @property {Array.<mesos.IOffer>} [offers] Offers offers
                 */

                /**
                 * Constructs a new Offers.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents an Offers.
                 * @constructor
                 * @param {mesos.scheduler.Event.IOffers=} [properties] Properties to set
                 */
                function Offers(properties) {
                    this.offers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Offers offers.
                 * @member {Array.<mesos.IOffer>}offers
                 * @memberof mesos.scheduler.Event.Offers
                 * @instance
                 */
                Offers.prototype.offers = $util.emptyArray;

                /**
                 * Creates a new Offers instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {mesos.scheduler.Event.IOffers=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Offers} Offers instance
                 */
                Offers.create = function create(properties) {
                    return new Offers(properties);
                };

                /**
                 * Encodes the specified Offers message. Does not implicitly {@link mesos.scheduler.Event.Offers.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {mesos.scheduler.Event.IOffers} message Offers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Offers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.offers != null && message.offers.length)
                        for (let i = 0; i < message.offers.length; ++i)
                            $root.mesos.Offer.encode(message.offers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Offers message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Offers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {mesos.scheduler.Event.IOffers} message Offers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Offers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Offers message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Offers} Offers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Offers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Offers();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.offers && message.offers.length))
                                message.offers = [];
                            message.offers.push($root.mesos.Offer.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Offers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Offers} Offers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Offers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Offers message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Offers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.offers != null && message.hasOwnProperty("offers")) {
                        if (!Array.isArray(message.offers))
                            return "offers: array expected";
                        for (let i = 0; i < message.offers.length; ++i) {
                            let error = $root.mesos.Offer.verify(message.offers[i]);
                            if (error)
                                return "offers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Offers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Offers} Offers
                 */
                Offers.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Offers)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Offers();
                    if (object.offers) {
                        if (!Array.isArray(object.offers))
                            throw TypeError(".mesos.scheduler.Event.Offers.offers: array expected");
                        message.offers = [];
                        for (let i = 0; i < object.offers.length; ++i) {
                            if (typeof object.offers[i] !== "object")
                                throw TypeError(".mesos.scheduler.Event.Offers.offers: object expected");
                            message.offers[i] = $root.mesos.Offer.fromObject(object.offers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Offers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Offers
                 * @static
                 * @param {mesos.scheduler.Event.Offers} message Offers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Offers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.offers = [];
                    if (message.offers && message.offers.length) {
                        object.offers = [];
                        for (let j = 0; j < message.offers.length; ++j)
                            object.offers[j] = $root.mesos.Offer.toObject(message.offers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Offers to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Offers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Offers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Offers;
            })();

            Event.InverseOffers = (function() {

                /**
                 * Properties of an InverseOffers.
                 * @memberof mesos.scheduler.Event
                 * @interface IInverseOffers
                 * @property {Array.<mesos.IInverseOffer>} [inverseOffers] InverseOffers inverseOffers
                 */

                /**
                 * Constructs a new InverseOffers.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents an InverseOffers.
                 * @constructor
                 * @param {mesos.scheduler.Event.IInverseOffers=} [properties] Properties to set
                 */
                function InverseOffers(properties) {
                    this.inverseOffers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InverseOffers inverseOffers.
                 * @member {Array.<mesos.IInverseOffer>}inverseOffers
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @instance
                 */
                InverseOffers.prototype.inverseOffers = $util.emptyArray;

                /**
                 * Creates a new InverseOffers instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {mesos.scheduler.Event.IInverseOffers=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.InverseOffers} InverseOffers instance
                 */
                InverseOffers.create = function create(properties) {
                    return new InverseOffers(properties);
                };

                /**
                 * Encodes the specified InverseOffers message. Does not implicitly {@link mesos.scheduler.Event.InverseOffers.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {mesos.scheduler.Event.IInverseOffers} message InverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InverseOffers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inverseOffers != null && message.inverseOffers.length)
                        for (let i = 0; i < message.inverseOffers.length; ++i)
                            $root.mesos.InverseOffer.encode(message.inverseOffers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified InverseOffers message, length delimited. Does not implicitly {@link mesos.scheduler.Event.InverseOffers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {mesos.scheduler.Event.IInverseOffers} message InverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InverseOffers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InverseOffers message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.InverseOffers} InverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InverseOffers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.InverseOffers();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.inverseOffers && message.inverseOffers.length))
                                message.inverseOffers = [];
                            message.inverseOffers.push($root.mesos.InverseOffer.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InverseOffers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.InverseOffers} InverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InverseOffers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InverseOffers message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InverseOffers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inverseOffers != null && message.hasOwnProperty("inverseOffers")) {
                        if (!Array.isArray(message.inverseOffers))
                            return "inverseOffers: array expected";
                        for (let i = 0; i < message.inverseOffers.length; ++i) {
                            let error = $root.mesos.InverseOffer.verify(message.inverseOffers[i]);
                            if (error)
                                return "inverseOffers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an InverseOffers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.InverseOffers} InverseOffers
                 */
                InverseOffers.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.InverseOffers)
                        return object;
                    let message = new $root.mesos.scheduler.Event.InverseOffers();
                    if (object.inverseOffers) {
                        if (!Array.isArray(object.inverseOffers))
                            throw TypeError(".mesos.scheduler.Event.InverseOffers.inverseOffers: array expected");
                        message.inverseOffers = [];
                        for (let i = 0; i < object.inverseOffers.length; ++i) {
                            if (typeof object.inverseOffers[i] !== "object")
                                throw TypeError(".mesos.scheduler.Event.InverseOffers.inverseOffers: object expected");
                            message.inverseOffers[i] = $root.mesos.InverseOffer.fromObject(object.inverseOffers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an InverseOffers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @static
                 * @param {mesos.scheduler.Event.InverseOffers} message InverseOffers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InverseOffers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.inverseOffers = [];
                    if (message.inverseOffers && message.inverseOffers.length) {
                        object.inverseOffers = [];
                        for (let j = 0; j < message.inverseOffers.length; ++j)
                            object.inverseOffers[j] = $root.mesos.InverseOffer.toObject(message.inverseOffers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this InverseOffers to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.InverseOffers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InverseOffers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InverseOffers;
            })();

            Event.Rescind = (function() {

                /**
                 * Properties of a Rescind.
                 * @memberof mesos.scheduler.Event
                 * @interface IRescind
                 * @property {mesos.IOfferID} offerId Rescind offerId
                 */

                /**
                 * Constructs a new Rescind.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents a Rescind.
                 * @constructor
                 * @param {mesos.scheduler.Event.IRescind=} [properties] Properties to set
                 */
                function Rescind(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Rescind offerId.
                 * @member {mesos.IOfferID}offerId
                 * @memberof mesos.scheduler.Event.Rescind
                 * @instance
                 */
                Rescind.prototype.offerId = null;

                /**
                 * Creates a new Rescind instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {mesos.scheduler.Event.IRescind=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Rescind} Rescind instance
                 */
                Rescind.create = function create(properties) {
                    return new Rescind(properties);
                };

                /**
                 * Encodes the specified Rescind message. Does not implicitly {@link mesos.scheduler.Event.Rescind.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {mesos.scheduler.Event.IRescind} message Rescind message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rescind.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.OfferID.encode(message.offerId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Rescind message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Rescind.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {mesos.scheduler.Event.IRescind} message Rescind message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Rescind.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Rescind message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Rescind} Rescind
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rescind.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Rescind();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.offerId = $root.mesos.OfferID.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("offerId"))
                        throw $util.ProtocolError("missing required 'offerId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Rescind message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Rescind} Rescind
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Rescind.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Rescind message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Rescind.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.OfferID.verify(message.offerId);
                    if (error)
                        return "offerId." + error;
                    return null;
                };

                /**
                 * Creates a Rescind message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Rescind} Rescind
                 */
                Rescind.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Rescind)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Rescind();
                    if (object.offerId != null) {
                        if (typeof object.offerId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Rescind.offerId: object expected");
                        message.offerId = $root.mesos.OfferID.fromObject(object.offerId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Rescind message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Rescind
                 * @static
                 * @param {mesos.scheduler.Event.Rescind} message Rescind
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Rescind.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.offerId = null;
                    if (message.offerId != null && message.hasOwnProperty("offerId"))
                        object.offerId = $root.mesos.OfferID.toObject(message.offerId, options);
                    return object;
                };

                /**
                 * Converts this Rescind to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Rescind
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Rescind.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Rescind;
            })();

            Event.RescindInverseOffer = (function() {

                /**
                 * Properties of a RescindInverseOffer.
                 * @memberof mesos.scheduler.Event
                 * @interface IRescindInverseOffer
                 * @property {mesos.IOfferID} inverseOfferId RescindInverseOffer inverseOfferId
                 */

                /**
                 * Constructs a new RescindInverseOffer.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents a RescindInverseOffer.
                 * @constructor
                 * @param {mesos.scheduler.Event.IRescindInverseOffer=} [properties] Properties to set
                 */
                function RescindInverseOffer(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RescindInverseOffer inverseOfferId.
                 * @member {mesos.IOfferID}inverseOfferId
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @instance
                 */
                RescindInverseOffer.prototype.inverseOfferId = null;

                /**
                 * Creates a new RescindInverseOffer instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {mesos.scheduler.Event.IRescindInverseOffer=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.RescindInverseOffer} RescindInverseOffer instance
                 */
                RescindInverseOffer.create = function create(properties) {
                    return new RescindInverseOffer(properties);
                };

                /**
                 * Encodes the specified RescindInverseOffer message. Does not implicitly {@link mesos.scheduler.Event.RescindInverseOffer.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {mesos.scheduler.Event.IRescindInverseOffer} message RescindInverseOffer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RescindInverseOffer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.OfferID.encode(message.inverseOfferId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RescindInverseOffer message, length delimited. Does not implicitly {@link mesos.scheduler.Event.RescindInverseOffer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {mesos.scheduler.Event.IRescindInverseOffer} message RescindInverseOffer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RescindInverseOffer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RescindInverseOffer message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.RescindInverseOffer} RescindInverseOffer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RescindInverseOffer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.RescindInverseOffer();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inverseOfferId = $root.mesos.OfferID.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("inverseOfferId"))
                        throw $util.ProtocolError("missing required 'inverseOfferId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a RescindInverseOffer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.RescindInverseOffer} RescindInverseOffer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RescindInverseOffer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RescindInverseOffer message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RescindInverseOffer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.OfferID.verify(message.inverseOfferId);
                    if (error)
                        return "inverseOfferId." + error;
                    return null;
                };

                /**
                 * Creates a RescindInverseOffer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.RescindInverseOffer} RescindInverseOffer
                 */
                RescindInverseOffer.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.RescindInverseOffer)
                        return object;
                    let message = new $root.mesos.scheduler.Event.RescindInverseOffer();
                    if (object.inverseOfferId != null) {
                        if (typeof object.inverseOfferId !== "object")
                            throw TypeError(".mesos.scheduler.Event.RescindInverseOffer.inverseOfferId: object expected");
                        message.inverseOfferId = $root.mesos.OfferID.fromObject(object.inverseOfferId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RescindInverseOffer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @static
                 * @param {mesos.scheduler.Event.RescindInverseOffer} message RescindInverseOffer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RescindInverseOffer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.inverseOfferId = null;
                    if (message.inverseOfferId != null && message.hasOwnProperty("inverseOfferId"))
                        object.inverseOfferId = $root.mesos.OfferID.toObject(message.inverseOfferId, options);
                    return object;
                };

                /**
                 * Converts this RescindInverseOffer to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.RescindInverseOffer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RescindInverseOffer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RescindInverseOffer;
            })();

            Event.Update = (function() {

                /**
                 * Properties of an Update.
                 * @memberof mesos.scheduler.Event
                 * @interface IUpdate
                 * @property {mesos.ITaskStatus} status Update status
                 */

                /**
                 * Constructs a new Update.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents an Update.
                 * @constructor
                 * @param {mesos.scheduler.Event.IUpdate=} [properties] Properties to set
                 */
                function Update(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Update status.
                 * @member {mesos.ITaskStatus}status
                 * @memberof mesos.scheduler.Event.Update
                 * @instance
                 */
                Update.prototype.status = null;

                /**
                 * Creates a new Update instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {mesos.scheduler.Event.IUpdate=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Update} Update instance
                 */
                Update.create = function create(properties) {
                    return new Update(properties);
                };

                /**
                 * Encodes the specified Update message. Does not implicitly {@link mesos.scheduler.Event.Update.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {mesos.scheduler.Event.IUpdate} message Update message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Update.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskStatus.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Update message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Update.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {mesos.scheduler.Event.IUpdate} message Update message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Update.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Update message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Update} Update
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Update.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Update();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = $root.mesos.TaskStatus.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("status"))
                        throw $util.ProtocolError("missing required 'status'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Update message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Update} Update
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Update.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Update message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Update.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskStatus.verify(message.status);
                    if (error)
                        return "status." + error;
                    return null;
                };

                /**
                 * Creates an Update message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Update} Update
                 */
                Update.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Update)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Update();
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".mesos.scheduler.Event.Update.status: object expected");
                        message.status = $root.mesos.TaskStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Update message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Update
                 * @static
                 * @param {mesos.scheduler.Event.Update} message Update
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Update.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.status = null;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.mesos.TaskStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this Update to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Update
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Update.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Update;
            })();

            Event.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof mesos.scheduler.Event
                 * @interface IMessage
                 * @property {mesos.IAgentID} agentId Message agentId
                 * @property {mesos.IExecutorID} executorId Message executorId
                 * @property {Uint8Array} data Message data
                 */

                /**
                 * Constructs a new Message.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents a Message.
                 * @constructor
                 * @param {mesos.scheduler.Event.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message agentId.
                 * @member {mesos.IAgentID}agentId
                 * @memberof mesos.scheduler.Event.Message
                 * @instance
                 */
                Message.prototype.agentId = null;

                /**
                 * Message executorId.
                 * @member {mesos.IExecutorID}executorId
                 * @memberof mesos.scheduler.Event.Message
                 * @instance
                 */
                Message.prototype.executorId = null;

                /**
                 * Message data.
                 * @member {Uint8Array}data
                 * @memberof mesos.scheduler.Event.Message
                 * @instance
                 */
                Message.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {mesos.scheduler.Event.IMessage=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link mesos.scheduler.Event.Message.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {mesos.scheduler.Event.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {mesos.scheduler.Event.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("agentId"))
                        throw $util.ProtocolError("missing required 'agentId'", { instance: message });
                    if (!message.hasOwnProperty("executorId"))
                        throw $util.ProtocolError("missing required 'executorId'", { instance: message });
                    if (!message.hasOwnProperty("data"))
                        throw $util.ProtocolError("missing required 'data'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.AgentID.verify(message.agentId);
                    if (error)
                        return "agentId." + error;
                    error = $root.mesos.ExecutorID.verify(message.executorId);
                    if (error)
                        return "executorId." + error;
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Message)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Message();
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Message.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    if (object.executorId != null) {
                        if (typeof object.executorId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Message.executorId: object expected");
                        message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
                    }
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Message
                 * @static
                 * @param {mesos.scheduler.Event.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.agentId = null;
                        object.executorId = null;
                        object.data = options.bytes === String ? "" : [];
                    }
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    if (message.executorId != null && message.hasOwnProperty("executorId"))
                        object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            Event.Failure = (function() {

                /**
                 * Properties of a Failure.
                 * @memberof mesos.scheduler.Event
                 * @interface IFailure
                 * @property {mesos.IAgentID} [agentId] Failure agentId
                 * @property {mesos.IExecutorID} [executorId] Failure executorId
                 * @property {number} [status] Failure status
                 */

                /**
                 * Constructs a new Failure.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents a Failure.
                 * @constructor
                 * @param {mesos.scheduler.Event.IFailure=} [properties] Properties to set
                 */
                function Failure(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Failure agentId.
                 * @member {(mesos.IAgentID|null|undefined)}agentId
                 * @memberof mesos.scheduler.Event.Failure
                 * @instance
                 */
                Failure.prototype.agentId = null;

                /**
                 * Failure executorId.
                 * @member {(mesos.IExecutorID|null|undefined)}executorId
                 * @memberof mesos.scheduler.Event.Failure
                 * @instance
                 */
                Failure.prototype.executorId = null;

                /**
                 * Failure status.
                 * @member {number}status
                 * @memberof mesos.scheduler.Event.Failure
                 * @instance
                 */
                Failure.prototype.status = 0;

                /**
                 * Creates a new Failure instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {mesos.scheduler.Event.IFailure=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Failure} Failure instance
                 */
                Failure.create = function create(properties) {
                    return new Failure(properties);
                };

                /**
                 * Encodes the specified Failure message. Does not implicitly {@link mesos.scheduler.Event.Failure.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {mesos.scheduler.Event.IFailure} message Failure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Failure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.executorId != null && message.hasOwnProperty("executorId"))
                        $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                    return writer;
                };

                /**
                 * Encodes the specified Failure message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Failure.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {mesos.scheduler.Event.IFailure} message Failure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Failure.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Failure message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Failure} Failure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Failure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Failure();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.status = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Failure message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Failure} Failure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Failure.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Failure message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Failure.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.agentId != null && message.hasOwnProperty("agentId")) {
                        let error = $root.mesos.AgentID.verify(message.agentId);
                        if (error)
                            return "agentId." + error;
                    }
                    if (message.executorId != null && message.hasOwnProperty("executorId")) {
                        error = $root.mesos.ExecutorID.verify(message.executorId);
                        if (error)
                            return "executorId." + error;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        if (!$util.isInteger(message.status))
                            return "status: integer expected";
                    return null;
                };

                /**
                 * Creates a Failure message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Failure} Failure
                 */
                Failure.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Failure)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Failure();
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Failure.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    if (object.executorId != null) {
                        if (typeof object.executorId !== "object")
                            throw TypeError(".mesos.scheduler.Event.Failure.executorId: object expected");
                        message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
                    }
                    if (object.status != null)
                        message.status = object.status | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Failure message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Failure
                 * @static
                 * @param {mesos.scheduler.Event.Failure} message Failure
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Failure.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.agentId = null;
                        object.executorId = null;
                        object.status = 0;
                    }
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    if (message.executorId != null && message.hasOwnProperty("executorId"))
                        object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    return object;
                };

                /**
                 * Converts this Failure to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Failure
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Failure.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Failure;
            })();

            Event.Error = (function() {

                /**
                 * Properties of an Error.
                 * @memberof mesos.scheduler.Event
                 * @interface IError
                 * @property {string} message Error message
                 */

                /**
                 * Constructs a new Error.
                 * @memberof mesos.scheduler.Event
                 * @classdesc Represents an Error.
                 * @constructor
                 * @param {mesos.scheduler.Event.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Error message.
                 * @member {string}message
                 * @memberof mesos.scheduler.Event.Error
                 * @instance
                 */
                Error.prototype.message = "";

                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {mesos.scheduler.Event.IError=} [properties] Properties to set
                 * @returns {mesos.scheduler.Event.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };

                /**
                 * Encodes the specified Error message. Does not implicitly {@link mesos.scheduler.Event.Error.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {mesos.scheduler.Event.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified Error message, length delimited. Does not implicitly {@link mesos.scheduler.Event.Error.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {mesos.scheduler.Event.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Event.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Event.Error();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("message"))
                        throw $util.ProtocolError("missing required 'message'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Error message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Event.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.message))
                        return "message: string expected";
                    return null;
                };

                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Event.Error} Error
                 */
                Error.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Event.Error)
                        return object;
                    let message = new $root.mesos.scheduler.Event.Error();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Event.Error
                 * @static
                 * @param {mesos.scheduler.Event.Error} message Error
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Error.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.message = "";
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this Error to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Event.Error
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Error.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Error;
            })();

            return Event;
        })();

        scheduler.Call = (function() {

            /**
             * Properties of a Call.
             * @memberof mesos.scheduler
             * @interface ICall
             * @property {mesos.IFrameworkID} [frameworkId] Call frameworkId
             * @property {mesos.scheduler.Call.Type} [type] Call type
             * @property {mesos.scheduler.Call.ISubscribe} [subscribe] Call subscribe
             * @property {mesos.scheduler.Call.IAccept} [accept] Call accept
             * @property {mesos.scheduler.Call.IDecline} [decline] Call decline
             * @property {mesos.scheduler.Call.IAcceptInverseOffers} [acceptInverseOffers] Call acceptInverseOffers
             * @property {mesos.scheduler.Call.IDeclineInverseOffers} [declineInverseOffers] Call declineInverseOffers
             * @property {mesos.scheduler.Call.IRevive} [revive] Call revive
             * @property {mesos.scheduler.Call.IKill} [kill] Call kill
             * @property {mesos.scheduler.Call.IShutdown} [shutdown] Call shutdown
             * @property {mesos.scheduler.Call.IAcknowledge} [acknowledge] Call acknowledge
             * @property {mesos.scheduler.Call.IReconcile} [reconcile] Call reconcile
             * @property {mesos.scheduler.Call.IMessage} [message] Call message
             * @property {mesos.scheduler.Call.IRequest} [request] Call request
             * @property {mesos.scheduler.Call.ISuppress} [suppress] Call suppress
             */

            /**
             * Constructs a new Call.
             * @memberof mesos.scheduler
             * @classdesc Scheduler call API.
             * 
             * Like Event, a Call is described using the standard protocol buffer
             * "union" trick (see above).
             * @constructor
             * @param {mesos.scheduler.ICall=} [properties] Properties to set
             */
            function Call(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Call frameworkId.
             * @member {(mesos.IFrameworkID|null|undefined)}frameworkId
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.frameworkId = null;

            /**
             * Call type.
             * @member {mesos.scheduler.Call.Type}type
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.type = 0;

            /**
             * Call subscribe.
             * @member {(mesos.scheduler.Call.ISubscribe|null|undefined)}subscribe
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.subscribe = null;

            /**
             * Call accept.
             * @member {(mesos.scheduler.Call.IAccept|null|undefined)}accept
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.accept = null;

            /**
             * Call decline.
             * @member {(mesos.scheduler.Call.IDecline|null|undefined)}decline
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.decline = null;

            /**
             * Call acceptInverseOffers.
             * @member {(mesos.scheduler.Call.IAcceptInverseOffers|null|undefined)}acceptInverseOffers
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.acceptInverseOffers = null;

            /**
             * Call declineInverseOffers.
             * @member {(mesos.scheduler.Call.IDeclineInverseOffers|null|undefined)}declineInverseOffers
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.declineInverseOffers = null;

            /**
             * Call revive.
             * @member {(mesos.scheduler.Call.IRevive|null|undefined)}revive
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.revive = null;

            /**
             * Call kill.
             * @member {(mesos.scheduler.Call.IKill|null|undefined)}kill
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.kill = null;

            /**
             * Call shutdown.
             * @member {(mesos.scheduler.Call.IShutdown|null|undefined)}shutdown
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.shutdown = null;

            /**
             * Call acknowledge.
             * @member {(mesos.scheduler.Call.IAcknowledge|null|undefined)}acknowledge
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.acknowledge = null;

            /**
             * Call reconcile.
             * @member {(mesos.scheduler.Call.IReconcile|null|undefined)}reconcile
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.reconcile = null;

            /**
             * Call message.
             * @member {(mesos.scheduler.Call.IMessage|null|undefined)}message
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.message = null;

            /**
             * Call request.
             * @member {(mesos.scheduler.Call.IRequest|null|undefined)}request
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.request = null;

            /**
             * Call suppress.
             * @member {(mesos.scheduler.Call.ISuppress|null|undefined)}suppress
             * @memberof mesos.scheduler.Call
             * @instance
             */
            Call.prototype.suppress = null;

            /**
             * Creates a new Call instance using the specified properties.
             * @function create
             * @memberof mesos.scheduler.Call
             * @static
             * @param {mesos.scheduler.ICall=} [properties] Properties to set
             * @returns {mesos.scheduler.Call} Call instance
             */
            Call.create = function create(properties) {
                return new Call(properties);
            };

            /**
             * Encodes the specified Call message. Does not implicitly {@link mesos.scheduler.Call.verify|verify} messages.
             * @function encode
             * @memberof mesos.scheduler.Call
             * @static
             * @param {mesos.scheduler.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                    $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.subscribe != null && message.hasOwnProperty("subscribe"))
                    $root.mesos.scheduler.Call.Subscribe.encode(message.subscribe, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.accept != null && message.hasOwnProperty("accept"))
                    $root.mesos.scheduler.Call.Accept.encode(message.accept, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.decline != null && message.hasOwnProperty("decline"))
                    $root.mesos.scheduler.Call.Decline.encode(message.decline, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.kill != null && message.hasOwnProperty("kill"))
                    $root.mesos.scheduler.Call.Kill.encode(message.kill, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.shutdown != null && message.hasOwnProperty("shutdown"))
                    $root.mesos.scheduler.Call.Shutdown.encode(message.shutdown, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.acknowledge != null && message.hasOwnProperty("acknowledge"))
                    $root.mesos.scheduler.Call.Acknowledge.encode(message.acknowledge, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reconcile != null && message.hasOwnProperty("reconcile"))
                    $root.mesos.scheduler.Call.Reconcile.encode(message.reconcile, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    $root.mesos.scheduler.Call.Message.encode(message.message, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.request != null && message.hasOwnProperty("request"))
                    $root.mesos.scheduler.Call.Request.encode(message.request, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.acceptInverseOffers != null && message.hasOwnProperty("acceptInverseOffers"))
                    $root.mesos.scheduler.Call.AcceptInverseOffers.encode(message.acceptInverseOffers, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.declineInverseOffers != null && message.hasOwnProperty("declineInverseOffers"))
                    $root.mesos.scheduler.Call.DeclineInverseOffers.encode(message.declineInverseOffers, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.revive != null && message.hasOwnProperty("revive"))
                    $root.mesos.scheduler.Call.Revive.encode(message.revive, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.suppress != null && message.hasOwnProperty("suppress"))
                    $root.mesos.scheduler.Call.Suppress.encode(message.suppress, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Call message, length delimited. Does not implicitly {@link mesos.scheduler.Call.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.scheduler.Call
             * @static
             * @param {mesos.scheduler.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Call message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.scheduler.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.scheduler.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.subscribe = $root.mesos.scheduler.Call.Subscribe.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.accept = $root.mesos.scheduler.Call.Accept.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.decline = $root.mesos.scheduler.Call.Decline.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.acceptInverseOffers = $root.mesos.scheduler.Call.AcceptInverseOffers.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.declineInverseOffers = $root.mesos.scheduler.Call.DeclineInverseOffers.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.revive = $root.mesos.scheduler.Call.Revive.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.kill = $root.mesos.scheduler.Call.Kill.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.shutdown = $root.mesos.scheduler.Call.Shutdown.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.acknowledge = $root.mesos.scheduler.Call.Acknowledge.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.reconcile = $root.mesos.scheduler.Call.Reconcile.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.message = $root.mesos.scheduler.Call.Message.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.request = $root.mesos.scheduler.Call.Request.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.suppress = $root.mesos.scheduler.Call.Suppress.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Call message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.scheduler.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.scheduler.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Call message.
             * @function verify
             * @memberof mesos.scheduler.Call
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Call.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frameworkId != null && message.hasOwnProperty("frameworkId")) {
                    let error = $root.mesos.FrameworkID.verify(message.frameworkId);
                    if (error)
                        return "frameworkId." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 13:
                    case 14:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.subscribe != null && message.hasOwnProperty("subscribe")) {
                    error = $root.mesos.scheduler.Call.Subscribe.verify(message.subscribe);
                    if (error)
                        return "subscribe." + error;
                }
                if (message.accept != null && message.hasOwnProperty("accept")) {
                    error = $root.mesos.scheduler.Call.Accept.verify(message.accept);
                    if (error)
                        return "accept." + error;
                }
                if (message.decline != null && message.hasOwnProperty("decline")) {
                    error = $root.mesos.scheduler.Call.Decline.verify(message.decline);
                    if (error)
                        return "decline." + error;
                }
                if (message.acceptInverseOffers != null && message.hasOwnProperty("acceptInverseOffers")) {
                    error = $root.mesos.scheduler.Call.AcceptInverseOffers.verify(message.acceptInverseOffers);
                    if (error)
                        return "acceptInverseOffers." + error;
                }
                if (message.declineInverseOffers != null && message.hasOwnProperty("declineInverseOffers")) {
                    error = $root.mesos.scheduler.Call.DeclineInverseOffers.verify(message.declineInverseOffers);
                    if (error)
                        return "declineInverseOffers." + error;
                }
                if (message.revive != null && message.hasOwnProperty("revive")) {
                    error = $root.mesos.scheduler.Call.Revive.verify(message.revive);
                    if (error)
                        return "revive." + error;
                }
                if (message.kill != null && message.hasOwnProperty("kill")) {
                    error = $root.mesos.scheduler.Call.Kill.verify(message.kill);
                    if (error)
                        return "kill." + error;
                }
                if (message.shutdown != null && message.hasOwnProperty("shutdown")) {
                    error = $root.mesos.scheduler.Call.Shutdown.verify(message.shutdown);
                    if (error)
                        return "shutdown." + error;
                }
                if (message.acknowledge != null && message.hasOwnProperty("acknowledge")) {
                    error = $root.mesos.scheduler.Call.Acknowledge.verify(message.acknowledge);
                    if (error)
                        return "acknowledge." + error;
                }
                if (message.reconcile != null && message.hasOwnProperty("reconcile")) {
                    error = $root.mesos.scheduler.Call.Reconcile.verify(message.reconcile);
                    if (error)
                        return "reconcile." + error;
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    error = $root.mesos.scheduler.Call.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    error = $root.mesos.scheduler.Call.Request.verify(message.request);
                    if (error)
                        return "request." + error;
                }
                if (message.suppress != null && message.hasOwnProperty("suppress")) {
                    error = $root.mesos.scheduler.Call.Suppress.verify(message.suppress);
                    if (error)
                        return "suppress." + error;
                }
                return null;
            };

            /**
             * Creates a Call message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.scheduler.Call
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.scheduler.Call} Call
             */
            Call.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.scheduler.Call)
                    return object;
                let message = new $root.mesos.scheduler.Call();
                if (object.frameworkId != null) {
                    if (typeof object.frameworkId !== "object")
                        throw TypeError(".mesos.scheduler.Call.frameworkId: object expected");
                    message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
                }
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "SUBSCRIBE":
                case 1:
                    message.type = 1;
                    break;
                case "TEARDOWN":
                case 2:
                    message.type = 2;
                    break;
                case "ACCEPT":
                case 3:
                    message.type = 3;
                    break;
                case "DECLINE":
                case 4:
                    message.type = 4;
                    break;
                case "ACCEPT_INVERSE_OFFERS":
                case 13:
                    message.type = 13;
                    break;
                case "DECLINE_INVERSE_OFFERS":
                case 14:
                    message.type = 14;
                    break;
                case "REVIVE":
                case 5:
                    message.type = 5;
                    break;
                case "KILL":
                case 6:
                    message.type = 6;
                    break;
                case "SHUTDOWN":
                case 7:
                    message.type = 7;
                    break;
                case "ACKNOWLEDGE":
                case 8:
                    message.type = 8;
                    break;
                case "RECONCILE":
                case 9:
                    message.type = 9;
                    break;
                case "MESSAGE":
                case 10:
                    message.type = 10;
                    break;
                case "REQUEST":
                case 11:
                    message.type = 11;
                    break;
                case "SUPPRESS":
                case 12:
                    message.type = 12;
                    break;
                }
                if (object.subscribe != null) {
                    if (typeof object.subscribe !== "object")
                        throw TypeError(".mesos.scheduler.Call.subscribe: object expected");
                    message.subscribe = $root.mesos.scheduler.Call.Subscribe.fromObject(object.subscribe);
                }
                if (object.accept != null) {
                    if (typeof object.accept !== "object")
                        throw TypeError(".mesos.scheduler.Call.accept: object expected");
                    message.accept = $root.mesos.scheduler.Call.Accept.fromObject(object.accept);
                }
                if (object.decline != null) {
                    if (typeof object.decline !== "object")
                        throw TypeError(".mesos.scheduler.Call.decline: object expected");
                    message.decline = $root.mesos.scheduler.Call.Decline.fromObject(object.decline);
                }
                if (object.acceptInverseOffers != null) {
                    if (typeof object.acceptInverseOffers !== "object")
                        throw TypeError(".mesos.scheduler.Call.acceptInverseOffers: object expected");
                    message.acceptInverseOffers = $root.mesos.scheduler.Call.AcceptInverseOffers.fromObject(object.acceptInverseOffers);
                }
                if (object.declineInverseOffers != null) {
                    if (typeof object.declineInverseOffers !== "object")
                        throw TypeError(".mesos.scheduler.Call.declineInverseOffers: object expected");
                    message.declineInverseOffers = $root.mesos.scheduler.Call.DeclineInverseOffers.fromObject(object.declineInverseOffers);
                }
                if (object.revive != null) {
                    if (typeof object.revive !== "object")
                        throw TypeError(".mesos.scheduler.Call.revive: object expected");
                    message.revive = $root.mesos.scheduler.Call.Revive.fromObject(object.revive);
                }
                if (object.kill != null) {
                    if (typeof object.kill !== "object")
                        throw TypeError(".mesos.scheduler.Call.kill: object expected");
                    message.kill = $root.mesos.scheduler.Call.Kill.fromObject(object.kill);
                }
                if (object.shutdown != null) {
                    if (typeof object.shutdown !== "object")
                        throw TypeError(".mesos.scheduler.Call.shutdown: object expected");
                    message.shutdown = $root.mesos.scheduler.Call.Shutdown.fromObject(object.shutdown);
                }
                if (object.acknowledge != null) {
                    if (typeof object.acknowledge !== "object")
                        throw TypeError(".mesos.scheduler.Call.acknowledge: object expected");
                    message.acknowledge = $root.mesos.scheduler.Call.Acknowledge.fromObject(object.acknowledge);
                }
                if (object.reconcile != null) {
                    if (typeof object.reconcile !== "object")
                        throw TypeError(".mesos.scheduler.Call.reconcile: object expected");
                    message.reconcile = $root.mesos.scheduler.Call.Reconcile.fromObject(object.reconcile);
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".mesos.scheduler.Call.message: object expected");
                    message.message = $root.mesos.scheduler.Call.Message.fromObject(object.message);
                }
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".mesos.scheduler.Call.request: object expected");
                    message.request = $root.mesos.scheduler.Call.Request.fromObject(object.request);
                }
                if (object.suppress != null) {
                    if (typeof object.suppress !== "object")
                        throw TypeError(".mesos.scheduler.Call.suppress: object expected");
                    message.suppress = $root.mesos.scheduler.Call.Suppress.fromObject(object.suppress);
                }
                return message;
            };

            /**
             * Creates a plain object from a Call message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.scheduler.Call
             * @static
             * @param {mesos.scheduler.Call} message Call
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Call.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.frameworkId = null;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.subscribe = null;
                    object.accept = null;
                    object.decline = null;
                    object.kill = null;
                    object.shutdown = null;
                    object.acknowledge = null;
                    object.reconcile = null;
                    object.message = null;
                    object.request = null;
                    object.acceptInverseOffers = null;
                    object.declineInverseOffers = null;
                    object.revive = null;
                    object.suppress = null;
                }
                if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                    object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.scheduler.Call.Type[message.type] : message.type;
                if (message.subscribe != null && message.hasOwnProperty("subscribe"))
                    object.subscribe = $root.mesos.scheduler.Call.Subscribe.toObject(message.subscribe, options);
                if (message.accept != null && message.hasOwnProperty("accept"))
                    object.accept = $root.mesos.scheduler.Call.Accept.toObject(message.accept, options);
                if (message.decline != null && message.hasOwnProperty("decline"))
                    object.decline = $root.mesos.scheduler.Call.Decline.toObject(message.decline, options);
                if (message.kill != null && message.hasOwnProperty("kill"))
                    object.kill = $root.mesos.scheduler.Call.Kill.toObject(message.kill, options);
                if (message.shutdown != null && message.hasOwnProperty("shutdown"))
                    object.shutdown = $root.mesos.scheduler.Call.Shutdown.toObject(message.shutdown, options);
                if (message.acknowledge != null && message.hasOwnProperty("acknowledge"))
                    object.acknowledge = $root.mesos.scheduler.Call.Acknowledge.toObject(message.acknowledge, options);
                if (message.reconcile != null && message.hasOwnProperty("reconcile"))
                    object.reconcile = $root.mesos.scheduler.Call.Reconcile.toObject(message.reconcile, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.mesos.scheduler.Call.Message.toObject(message.message, options);
                if (message.request != null && message.hasOwnProperty("request"))
                    object.request = $root.mesos.scheduler.Call.Request.toObject(message.request, options);
                if (message.acceptInverseOffers != null && message.hasOwnProperty("acceptInverseOffers"))
                    object.acceptInverseOffers = $root.mesos.scheduler.Call.AcceptInverseOffers.toObject(message.acceptInverseOffers, options);
                if (message.declineInverseOffers != null && message.hasOwnProperty("declineInverseOffers"))
                    object.declineInverseOffers = $root.mesos.scheduler.Call.DeclineInverseOffers.toObject(message.declineInverseOffers, options);
                if (message.revive != null && message.hasOwnProperty("revive"))
                    object.revive = $root.mesos.scheduler.Call.Revive.toObject(message.revive, options);
                if (message.suppress != null && message.hasOwnProperty("suppress"))
                    object.suppress = $root.mesos.scheduler.Call.Suppress.toObject(message.suppress, options);
                return object;
            };

            /**
             * Converts this Call to JSON.
             * @function toJSON
             * @memberof mesos.scheduler.Call
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Call.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUBSCRIBE=1 SUBSCRIBE value
             * @property {number} TEARDOWN=2 TEARDOWN value
             * @property {number} ACCEPT=3 ACCEPT value
             * @property {number} DECLINE=4 DECLINE value
             * @property {number} ACCEPT_INVERSE_OFFERS=13 ACCEPT_INVERSE_OFFERS value
             * @property {number} DECLINE_INVERSE_OFFERS=14 DECLINE_INVERSE_OFFERS value
             * @property {number} REVIVE=5 REVIVE value
             * @property {number} KILL=6 KILL value
             * @property {number} SHUTDOWN=7 SHUTDOWN value
             * @property {number} ACKNOWLEDGE=8 ACKNOWLEDGE value
             * @property {number} RECONCILE=9 RECONCILE value
             * @property {number} MESSAGE=10 MESSAGE value
             * @property {number} REQUEST=11 REQUEST value
             * @property {number} SUPPRESS=12 SUPPRESS value
             */
            Call.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUBSCRIBE"] = 1;
                values[valuesById[2] = "TEARDOWN"] = 2;
                values[valuesById[3] = "ACCEPT"] = 3;
                values[valuesById[4] = "DECLINE"] = 4;
                values[valuesById[13] = "ACCEPT_INVERSE_OFFERS"] = 13;
                values[valuesById[14] = "DECLINE_INVERSE_OFFERS"] = 14;
                values[valuesById[5] = "REVIVE"] = 5;
                values[valuesById[6] = "KILL"] = 6;
                values[valuesById[7] = "SHUTDOWN"] = 7;
                values[valuesById[8] = "ACKNOWLEDGE"] = 8;
                values[valuesById[9] = "RECONCILE"] = 9;
                values[valuesById[10] = "MESSAGE"] = 10;
                values[valuesById[11] = "REQUEST"] = 11;
                values[valuesById[12] = "SUPPRESS"] = 12;
                return values;
            })();

            Call.Subscribe = (function() {

                /**
                 * Properties of a Subscribe.
                 * @memberof mesos.scheduler.Call
                 * @interface ISubscribe
                 * @property {mesos.IFrameworkInfo} frameworkInfo Subscribe frameworkInfo
                 */

                /**
                 * Constructs a new Subscribe.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Subscribe.
                 * @constructor
                 * @param {mesos.scheduler.Call.ISubscribe=} [properties] Properties to set
                 */
                function Subscribe(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subscribe frameworkInfo.
                 * @member {mesos.IFrameworkInfo}frameworkInfo
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @instance
                 */
                Subscribe.prototype.frameworkInfo = null;

                /**
                 * Creates a new Subscribe instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {mesos.scheduler.Call.ISubscribe=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Subscribe} Subscribe instance
                 */
                Subscribe.create = function create(properties) {
                    return new Subscribe(properties);
                };

                /**
                 * Encodes the specified Subscribe message. Does not implicitly {@link mesos.scheduler.Call.Subscribe.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {mesos.scheduler.Call.ISubscribe} message Subscribe message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribe.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.FrameworkInfo.encode(message.frameworkInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Subscribe message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Subscribe.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {mesos.scheduler.Call.ISubscribe} message Subscribe message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribe.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subscribe message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Subscribe} Subscribe
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribe.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Subscribe();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.frameworkInfo = $root.mesos.FrameworkInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("frameworkInfo"))
                        throw $util.ProtocolError("missing required 'frameworkInfo'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Subscribe message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Subscribe} Subscribe
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribe.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subscribe message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subscribe.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.FrameworkInfo.verify(message.frameworkInfo);
                    if (error)
                        return "frameworkInfo." + error;
                    return null;
                };

                /**
                 * Creates a Subscribe message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Subscribe} Subscribe
                 */
                Subscribe.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Subscribe)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Subscribe();
                    if (object.frameworkInfo != null) {
                        if (typeof object.frameworkInfo !== "object")
                            throw TypeError(".mesos.scheduler.Call.Subscribe.frameworkInfo: object expected");
                        message.frameworkInfo = $root.mesos.FrameworkInfo.fromObject(object.frameworkInfo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subscribe message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @static
                 * @param {mesos.scheduler.Call.Subscribe} message Subscribe
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subscribe.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.frameworkInfo = null;
                    if (message.frameworkInfo != null && message.hasOwnProperty("frameworkInfo"))
                        object.frameworkInfo = $root.mesos.FrameworkInfo.toObject(message.frameworkInfo, options);
                    return object;
                };

                /**
                 * Converts this Subscribe to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Subscribe
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subscribe.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subscribe;
            })();

            Call.Accept = (function() {

                /**
                 * Properties of an Accept.
                 * @memberof mesos.scheduler.Call
                 * @interface IAccept
                 * @property {Array.<mesos.IOfferID>} [offerIds] Accept offerIds
                 * @property {Array.<mesos.Offer.IOperation>} [operations] Accept operations
                 * @property {mesos.IFilters} [filters] Accept filters
                 */

                /**
                 * Constructs a new Accept.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents an Accept.
                 * @constructor
                 * @param {mesos.scheduler.Call.IAccept=} [properties] Properties to set
                 */
                function Accept(properties) {
                    this.offerIds = [];
                    this.operations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Accept offerIds.
                 * @member {Array.<mesos.IOfferID>}offerIds
                 * @memberof mesos.scheduler.Call.Accept
                 * @instance
                 */
                Accept.prototype.offerIds = $util.emptyArray;

                /**
                 * Accept operations.
                 * @member {Array.<mesos.Offer.IOperation>}operations
                 * @memberof mesos.scheduler.Call.Accept
                 * @instance
                 */
                Accept.prototype.operations = $util.emptyArray;

                /**
                 * Accept filters.
                 * @member {(mesos.IFilters|null|undefined)}filters
                 * @memberof mesos.scheduler.Call.Accept
                 * @instance
                 */
                Accept.prototype.filters = null;

                /**
                 * Creates a new Accept instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {mesos.scheduler.Call.IAccept=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Accept} Accept instance
                 */
                Accept.create = function create(properties) {
                    return new Accept(properties);
                };

                /**
                 * Encodes the specified Accept message. Does not implicitly {@link mesos.scheduler.Call.Accept.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {mesos.scheduler.Call.IAccept} message Accept message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Accept.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.offerIds != null && message.offerIds.length)
                        for (let i = 0; i < message.offerIds.length; ++i)
                            $root.mesos.OfferID.encode(message.offerIds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.operations != null && message.operations.length)
                        for (let i = 0; i < message.operations.length; ++i)
                            $root.mesos.Offer.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        $root.mesos.Filters.encode(message.filters, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Accept message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Accept.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {mesos.scheduler.Call.IAccept} message Accept message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Accept.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Accept message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Accept} Accept
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Accept.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Accept();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.offerIds && message.offerIds.length))
                                message.offerIds = [];
                            message.offerIds.push($root.mesos.OfferID.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.operations && message.operations.length))
                                message.operations = [];
                            message.operations.push($root.mesos.Offer.Operation.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.filters = $root.mesos.Filters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Accept message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Accept} Accept
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Accept.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Accept message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Accept.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.offerIds != null && message.hasOwnProperty("offerIds")) {
                        if (!Array.isArray(message.offerIds))
                            return "offerIds: array expected";
                        for (let i = 0; i < message.offerIds.length; ++i) {
                            let error = $root.mesos.OfferID.verify(message.offerIds[i]);
                            if (error)
                                return "offerIds." + error;
                        }
                    }
                    if (message.operations != null && message.hasOwnProperty("operations")) {
                        if (!Array.isArray(message.operations))
                            return "operations: array expected";
                        for (let i = 0; i < message.operations.length; ++i) {
                            error = $root.mesos.Offer.Operation.verify(message.operations[i]);
                            if (error)
                                return "operations." + error;
                        }
                    }
                    if (message.filters != null && message.hasOwnProperty("filters")) {
                        error = $root.mesos.Filters.verify(message.filters);
                        if (error)
                            return "filters." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Accept message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Accept} Accept
                 */
                Accept.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Accept)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Accept();
                    if (object.offerIds) {
                        if (!Array.isArray(object.offerIds))
                            throw TypeError(".mesos.scheduler.Call.Accept.offerIds: array expected");
                        message.offerIds = [];
                        for (let i = 0; i < object.offerIds.length; ++i) {
                            if (typeof object.offerIds[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.Accept.offerIds: object expected");
                            message.offerIds[i] = $root.mesos.OfferID.fromObject(object.offerIds[i]);
                        }
                    }
                    if (object.operations) {
                        if (!Array.isArray(object.operations))
                            throw TypeError(".mesos.scheduler.Call.Accept.operations: array expected");
                        message.operations = [];
                        for (let i = 0; i < object.operations.length; ++i) {
                            if (typeof object.operations[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.Accept.operations: object expected");
                            message.operations[i] = $root.mesos.Offer.Operation.fromObject(object.operations[i]);
                        }
                    }
                    if (object.filters != null) {
                        if (typeof object.filters !== "object")
                            throw TypeError(".mesos.scheduler.Call.Accept.filters: object expected");
                        message.filters = $root.mesos.Filters.fromObject(object.filters);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Accept message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Accept
                 * @static
                 * @param {mesos.scheduler.Call.Accept} message Accept
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Accept.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.offerIds = [];
                        object.operations = [];
                    }
                    if (options.defaults)
                        object.filters = null;
                    if (message.offerIds && message.offerIds.length) {
                        object.offerIds = [];
                        for (let j = 0; j < message.offerIds.length; ++j)
                            object.offerIds[j] = $root.mesos.OfferID.toObject(message.offerIds[j], options);
                    }
                    if (message.operations && message.operations.length) {
                        object.operations = [];
                        for (let j = 0; j < message.operations.length; ++j)
                            object.operations[j] = $root.mesos.Offer.Operation.toObject(message.operations[j], options);
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        object.filters = $root.mesos.Filters.toObject(message.filters, options);
                    return object;
                };

                /**
                 * Converts this Accept to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Accept
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Accept.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Accept;
            })();

            Call.Decline = (function() {

                /**
                 * Properties of a Decline.
                 * @memberof mesos.scheduler.Call
                 * @interface IDecline
                 * @property {Array.<mesos.IOfferID>} [offerIds] Decline offerIds
                 * @property {mesos.IFilters} [filters] Decline filters
                 */

                /**
                 * Constructs a new Decline.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Decline.
                 * @constructor
                 * @param {mesos.scheduler.Call.IDecline=} [properties] Properties to set
                 */
                function Decline(properties) {
                    this.offerIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Decline offerIds.
                 * @member {Array.<mesos.IOfferID>}offerIds
                 * @memberof mesos.scheduler.Call.Decline
                 * @instance
                 */
                Decline.prototype.offerIds = $util.emptyArray;

                /**
                 * Decline filters.
                 * @member {(mesos.IFilters|null|undefined)}filters
                 * @memberof mesos.scheduler.Call.Decline
                 * @instance
                 */
                Decline.prototype.filters = null;

                /**
                 * Creates a new Decline instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {mesos.scheduler.Call.IDecline=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Decline} Decline instance
                 */
                Decline.create = function create(properties) {
                    return new Decline(properties);
                };

                /**
                 * Encodes the specified Decline message. Does not implicitly {@link mesos.scheduler.Call.Decline.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {mesos.scheduler.Call.IDecline} message Decline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Decline.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.offerIds != null && message.offerIds.length)
                        for (let i = 0; i < message.offerIds.length; ++i)
                            $root.mesos.OfferID.encode(message.offerIds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        $root.mesos.Filters.encode(message.filters, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Decline message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Decline.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {mesos.scheduler.Call.IDecline} message Decline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Decline.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Decline message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Decline} Decline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Decline.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Decline();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.offerIds && message.offerIds.length))
                                message.offerIds = [];
                            message.offerIds.push($root.mesos.OfferID.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.filters = $root.mesos.Filters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Decline message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Decline} Decline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Decline.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Decline message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Decline.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.offerIds != null && message.hasOwnProperty("offerIds")) {
                        if (!Array.isArray(message.offerIds))
                            return "offerIds: array expected";
                        for (let i = 0; i < message.offerIds.length; ++i) {
                            let error = $root.mesos.OfferID.verify(message.offerIds[i]);
                            if (error)
                                return "offerIds." + error;
                        }
                    }
                    if (message.filters != null && message.hasOwnProperty("filters")) {
                        error = $root.mesos.Filters.verify(message.filters);
                        if (error)
                            return "filters." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Decline message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Decline} Decline
                 */
                Decline.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Decline)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Decline();
                    if (object.offerIds) {
                        if (!Array.isArray(object.offerIds))
                            throw TypeError(".mesos.scheduler.Call.Decline.offerIds: array expected");
                        message.offerIds = [];
                        for (let i = 0; i < object.offerIds.length; ++i) {
                            if (typeof object.offerIds[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.Decline.offerIds: object expected");
                            message.offerIds[i] = $root.mesos.OfferID.fromObject(object.offerIds[i]);
                        }
                    }
                    if (object.filters != null) {
                        if (typeof object.filters !== "object")
                            throw TypeError(".mesos.scheduler.Call.Decline.filters: object expected");
                        message.filters = $root.mesos.Filters.fromObject(object.filters);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Decline message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Decline
                 * @static
                 * @param {mesos.scheduler.Call.Decline} message Decline
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Decline.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.offerIds = [];
                    if (options.defaults)
                        object.filters = null;
                    if (message.offerIds && message.offerIds.length) {
                        object.offerIds = [];
                        for (let j = 0; j < message.offerIds.length; ++j)
                            object.offerIds[j] = $root.mesos.OfferID.toObject(message.offerIds[j], options);
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        object.filters = $root.mesos.Filters.toObject(message.filters, options);
                    return object;
                };

                /**
                 * Converts this Decline to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Decline
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Decline.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Decline;
            })();

            Call.AcceptInverseOffers = (function() {

                /**
                 * Properties of an AcceptInverseOffers.
                 * @memberof mesos.scheduler.Call
                 * @interface IAcceptInverseOffers
                 * @property {Array.<mesos.IOfferID>} [inverseOfferIds] AcceptInverseOffers inverseOfferIds
                 * @property {mesos.IFilters} [filters] AcceptInverseOffers filters
                 */

                /**
                 * Constructs a new AcceptInverseOffers.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents an AcceptInverseOffers.
                 * @constructor
                 * @param {mesos.scheduler.Call.IAcceptInverseOffers=} [properties] Properties to set
                 */
                function AcceptInverseOffers(properties) {
                    this.inverseOfferIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AcceptInverseOffers inverseOfferIds.
                 * @member {Array.<mesos.IOfferID>}inverseOfferIds
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @instance
                 */
                AcceptInverseOffers.prototype.inverseOfferIds = $util.emptyArray;

                /**
                 * AcceptInverseOffers filters.
                 * @member {(mesos.IFilters|null|undefined)}filters
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @instance
                 */
                AcceptInverseOffers.prototype.filters = null;

                /**
                 * Creates a new AcceptInverseOffers instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IAcceptInverseOffers=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.AcceptInverseOffers} AcceptInverseOffers instance
                 */
                AcceptInverseOffers.create = function create(properties) {
                    return new AcceptInverseOffers(properties);
                };

                /**
                 * Encodes the specified AcceptInverseOffers message. Does not implicitly {@link mesos.scheduler.Call.AcceptInverseOffers.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IAcceptInverseOffers} message AcceptInverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcceptInverseOffers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inverseOfferIds != null && message.inverseOfferIds.length)
                        for (let i = 0; i < message.inverseOfferIds.length; ++i)
                            $root.mesos.OfferID.encode(message.inverseOfferIds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        $root.mesos.Filters.encode(message.filters, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AcceptInverseOffers message, length delimited. Does not implicitly {@link mesos.scheduler.Call.AcceptInverseOffers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IAcceptInverseOffers} message AcceptInverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AcceptInverseOffers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AcceptInverseOffers message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.AcceptInverseOffers} AcceptInverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcceptInverseOffers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.AcceptInverseOffers();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.inverseOfferIds && message.inverseOfferIds.length))
                                message.inverseOfferIds = [];
                            message.inverseOfferIds.push($root.mesos.OfferID.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.filters = $root.mesos.Filters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AcceptInverseOffers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.AcceptInverseOffers} AcceptInverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AcceptInverseOffers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AcceptInverseOffers message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AcceptInverseOffers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inverseOfferIds != null && message.hasOwnProperty("inverseOfferIds")) {
                        if (!Array.isArray(message.inverseOfferIds))
                            return "inverseOfferIds: array expected";
                        for (let i = 0; i < message.inverseOfferIds.length; ++i) {
                            let error = $root.mesos.OfferID.verify(message.inverseOfferIds[i]);
                            if (error)
                                return "inverseOfferIds." + error;
                        }
                    }
                    if (message.filters != null && message.hasOwnProperty("filters")) {
                        error = $root.mesos.Filters.verify(message.filters);
                        if (error)
                            return "filters." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AcceptInverseOffers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.AcceptInverseOffers} AcceptInverseOffers
                 */
                AcceptInverseOffers.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.AcceptInverseOffers)
                        return object;
                    let message = new $root.mesos.scheduler.Call.AcceptInverseOffers();
                    if (object.inverseOfferIds) {
                        if (!Array.isArray(object.inverseOfferIds))
                            throw TypeError(".mesos.scheduler.Call.AcceptInverseOffers.inverseOfferIds: array expected");
                        message.inverseOfferIds = [];
                        for (let i = 0; i < object.inverseOfferIds.length; ++i) {
                            if (typeof object.inverseOfferIds[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.AcceptInverseOffers.inverseOfferIds: object expected");
                            message.inverseOfferIds[i] = $root.mesos.OfferID.fromObject(object.inverseOfferIds[i]);
                        }
                    }
                    if (object.filters != null) {
                        if (typeof object.filters !== "object")
                            throw TypeError(".mesos.scheduler.Call.AcceptInverseOffers.filters: object expected");
                        message.filters = $root.mesos.Filters.fromObject(object.filters);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AcceptInverseOffers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.AcceptInverseOffers} message AcceptInverseOffers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AcceptInverseOffers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.inverseOfferIds = [];
                    if (options.defaults)
                        object.filters = null;
                    if (message.inverseOfferIds && message.inverseOfferIds.length) {
                        object.inverseOfferIds = [];
                        for (let j = 0; j < message.inverseOfferIds.length; ++j)
                            object.inverseOfferIds[j] = $root.mesos.OfferID.toObject(message.inverseOfferIds[j], options);
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        object.filters = $root.mesos.Filters.toObject(message.filters, options);
                    return object;
                };

                /**
                 * Converts this AcceptInverseOffers to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.AcceptInverseOffers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AcceptInverseOffers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AcceptInverseOffers;
            })();

            Call.DeclineInverseOffers = (function() {

                /**
                 * Properties of a DeclineInverseOffers.
                 * @memberof mesos.scheduler.Call
                 * @interface IDeclineInverseOffers
                 * @property {Array.<mesos.IOfferID>} [inverseOfferIds] DeclineInverseOffers inverseOfferIds
                 * @property {mesos.IFilters} [filters] DeclineInverseOffers filters
                 */

                /**
                 * Constructs a new DeclineInverseOffers.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a DeclineInverseOffers.
                 * @constructor
                 * @param {mesos.scheduler.Call.IDeclineInverseOffers=} [properties] Properties to set
                 */
                function DeclineInverseOffers(properties) {
                    this.inverseOfferIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeclineInverseOffers inverseOfferIds.
                 * @member {Array.<mesos.IOfferID>}inverseOfferIds
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @instance
                 */
                DeclineInverseOffers.prototype.inverseOfferIds = $util.emptyArray;

                /**
                 * DeclineInverseOffers filters.
                 * @member {(mesos.IFilters|null|undefined)}filters
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @instance
                 */
                DeclineInverseOffers.prototype.filters = null;

                /**
                 * Creates a new DeclineInverseOffers instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IDeclineInverseOffers=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.DeclineInverseOffers} DeclineInverseOffers instance
                 */
                DeclineInverseOffers.create = function create(properties) {
                    return new DeclineInverseOffers(properties);
                };

                /**
                 * Encodes the specified DeclineInverseOffers message. Does not implicitly {@link mesos.scheduler.Call.DeclineInverseOffers.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IDeclineInverseOffers} message DeclineInverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeclineInverseOffers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inverseOfferIds != null && message.inverseOfferIds.length)
                        for (let i = 0; i < message.inverseOfferIds.length; ++i)
                            $root.mesos.OfferID.encode(message.inverseOfferIds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        $root.mesos.Filters.encode(message.filters, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DeclineInverseOffers message, length delimited. Does not implicitly {@link mesos.scheduler.Call.DeclineInverseOffers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.IDeclineInverseOffers} message DeclineInverseOffers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeclineInverseOffers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeclineInverseOffers message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.DeclineInverseOffers} DeclineInverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeclineInverseOffers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.DeclineInverseOffers();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.inverseOfferIds && message.inverseOfferIds.length))
                                message.inverseOfferIds = [];
                            message.inverseOfferIds.push($root.mesos.OfferID.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.filters = $root.mesos.Filters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeclineInverseOffers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.DeclineInverseOffers} DeclineInverseOffers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeclineInverseOffers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeclineInverseOffers message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeclineInverseOffers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inverseOfferIds != null && message.hasOwnProperty("inverseOfferIds")) {
                        if (!Array.isArray(message.inverseOfferIds))
                            return "inverseOfferIds: array expected";
                        for (let i = 0; i < message.inverseOfferIds.length; ++i) {
                            let error = $root.mesos.OfferID.verify(message.inverseOfferIds[i]);
                            if (error)
                                return "inverseOfferIds." + error;
                        }
                    }
                    if (message.filters != null && message.hasOwnProperty("filters")) {
                        error = $root.mesos.Filters.verify(message.filters);
                        if (error)
                            return "filters." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DeclineInverseOffers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.DeclineInverseOffers} DeclineInverseOffers
                 */
                DeclineInverseOffers.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.DeclineInverseOffers)
                        return object;
                    let message = new $root.mesos.scheduler.Call.DeclineInverseOffers();
                    if (object.inverseOfferIds) {
                        if (!Array.isArray(object.inverseOfferIds))
                            throw TypeError(".mesos.scheduler.Call.DeclineInverseOffers.inverseOfferIds: array expected");
                        message.inverseOfferIds = [];
                        for (let i = 0; i < object.inverseOfferIds.length; ++i) {
                            if (typeof object.inverseOfferIds[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.DeclineInverseOffers.inverseOfferIds: object expected");
                            message.inverseOfferIds[i] = $root.mesos.OfferID.fromObject(object.inverseOfferIds[i]);
                        }
                    }
                    if (object.filters != null) {
                        if (typeof object.filters !== "object")
                            throw TypeError(".mesos.scheduler.Call.DeclineInverseOffers.filters: object expected");
                        message.filters = $root.mesos.Filters.fromObject(object.filters);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DeclineInverseOffers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @static
                 * @param {mesos.scheduler.Call.DeclineInverseOffers} message DeclineInverseOffers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeclineInverseOffers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.inverseOfferIds = [];
                    if (options.defaults)
                        object.filters = null;
                    if (message.inverseOfferIds && message.inverseOfferIds.length) {
                        object.inverseOfferIds = [];
                        for (let j = 0; j < message.inverseOfferIds.length; ++j)
                            object.inverseOfferIds[j] = $root.mesos.OfferID.toObject(message.inverseOfferIds[j], options);
                    }
                    if (message.filters != null && message.hasOwnProperty("filters"))
                        object.filters = $root.mesos.Filters.toObject(message.filters, options);
                    return object;
                };

                /**
                 * Converts this DeclineInverseOffers to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.DeclineInverseOffers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeclineInverseOffers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeclineInverseOffers;
            })();

            Call.Revive = (function() {

                /**
                 * Properties of a Revive.
                 * @memberof mesos.scheduler.Call
                 * @interface IRevive
                 * @property {string} [role] Revive role
                 */

                /**
                 * Constructs a new Revive.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Revive.
                 * @constructor
                 * @param {mesos.scheduler.Call.IRevive=} [properties] Properties to set
                 */
                function Revive(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Revive role.
                 * @member {string}role
                 * @memberof mesos.scheduler.Call.Revive
                 * @instance
                 */
                Revive.prototype.role = "";

                /**
                 * Creates a new Revive instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {mesos.scheduler.Call.IRevive=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Revive} Revive instance
                 */
                Revive.create = function create(properties) {
                    return new Revive(properties);
                };

                /**
                 * Encodes the specified Revive message. Does not implicitly {@link mesos.scheduler.Call.Revive.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {mesos.scheduler.Call.IRevive} message Revive message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Revive.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.role != null && message.hasOwnProperty("role"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.role);
                    return writer;
                };

                /**
                 * Encodes the specified Revive message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Revive.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {mesos.scheduler.Call.IRevive} message Revive message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Revive.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Revive message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Revive} Revive
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Revive.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Revive();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.role = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Revive message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Revive} Revive
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Revive.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Revive message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Revive.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.role != null && message.hasOwnProperty("role"))
                        if (!$util.isString(message.role))
                            return "role: string expected";
                    return null;
                };

                /**
                 * Creates a Revive message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Revive} Revive
                 */
                Revive.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Revive)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Revive();
                    if (object.role != null)
                        message.role = String(object.role);
                    return message;
                };

                /**
                 * Creates a plain object from a Revive message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Revive
                 * @static
                 * @param {mesos.scheduler.Call.Revive} message Revive
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Revive.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.role = "";
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = message.role;
                    return object;
                };

                /**
                 * Converts this Revive to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Revive
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Revive.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Revive;
            })();

            Call.Kill = (function() {

                /**
                 * Properties of a Kill.
                 * @memberof mesos.scheduler.Call
                 * @interface IKill
                 * @property {mesos.ITaskID} taskId Kill taskId
                 * @property {mesos.IAgentID} [agentId] Kill agentId
                 * @property {mesos.IKillPolicy} [killPolicy] Kill killPolicy
                 */

                /**
                 * Constructs a new Kill.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Kill.
                 * @constructor
                 * @param {mesos.scheduler.Call.IKill=} [properties] Properties to set
                 */
                function Kill(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Kill taskId.
                 * @member {mesos.ITaskID}taskId
                 * @memberof mesos.scheduler.Call.Kill
                 * @instance
                 */
                Kill.prototype.taskId = null;

                /**
                 * Kill agentId.
                 * @member {(mesos.IAgentID|null|undefined)}agentId
                 * @memberof mesos.scheduler.Call.Kill
                 * @instance
                 */
                Kill.prototype.agentId = null;

                /**
                 * Kill killPolicy.
                 * @member {(mesos.IKillPolicy|null|undefined)}killPolicy
                 * @memberof mesos.scheduler.Call.Kill
                 * @instance
                 */
                Kill.prototype.killPolicy = null;

                /**
                 * Creates a new Kill instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {mesos.scheduler.Call.IKill=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Kill} Kill instance
                 */
                Kill.create = function create(properties) {
                    return new Kill(properties);
                };

                /**
                 * Encodes the specified Kill message. Does not implicitly {@link mesos.scheduler.Call.Kill.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {mesos.scheduler.Call.IKill} message Kill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kill.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                        $root.mesos.KillPolicy.encode(message.killPolicy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Kill message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Kill.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {mesos.scheduler.Call.IKill} message Kill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kill.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Kill message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Kill} Kill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kill.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Kill();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.killPolicy = $root.mesos.KillPolicy.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("taskId"))
                        throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Kill message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Kill} Kill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kill.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Kill message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Kill.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskID.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                    if (message.agentId != null && message.hasOwnProperty("agentId")) {
                        error = $root.mesos.AgentID.verify(message.agentId);
                        if (error)
                            return "agentId." + error;
                    }
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy")) {
                        error = $root.mesos.KillPolicy.verify(message.killPolicy);
                        if (error)
                            return "killPolicy." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Kill message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Kill} Kill
                 */
                Kill.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Kill)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Kill();
                    if (object.taskId != null) {
                        if (typeof object.taskId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Kill.taskId: object expected");
                        message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
                    }
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Kill.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    if (object.killPolicy != null) {
                        if (typeof object.killPolicy !== "object")
                            throw TypeError(".mesos.scheduler.Call.Kill.killPolicy: object expected");
                        message.killPolicy = $root.mesos.KillPolicy.fromObject(object.killPolicy);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Kill message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Kill
                 * @static
                 * @param {mesos.scheduler.Call.Kill} message Kill
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Kill.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.taskId = null;
                        object.agentId = null;
                        object.killPolicy = null;
                    }
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                        object.killPolicy = $root.mesos.KillPolicy.toObject(message.killPolicy, options);
                    return object;
                };

                /**
                 * Converts this Kill to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Kill
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Kill.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Kill;
            })();

            Call.Shutdown = (function() {

                /**
                 * Properties of a Shutdown.
                 * @memberof mesos.scheduler.Call
                 * @interface IShutdown
                 * @property {mesos.IExecutorID} executorId Shutdown executorId
                 * @property {mesos.IAgentID} agentId Shutdown agentId
                 */

                /**
                 * Constructs a new Shutdown.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Shutdown.
                 * @constructor
                 * @param {mesos.scheduler.Call.IShutdown=} [properties] Properties to set
                 */
                function Shutdown(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Shutdown executorId.
                 * @member {mesos.IExecutorID}executorId
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @instance
                 */
                Shutdown.prototype.executorId = null;

                /**
                 * Shutdown agentId.
                 * @member {mesos.IAgentID}agentId
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @instance
                 */
                Shutdown.prototype.agentId = null;

                /**
                 * Creates a new Shutdown instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {mesos.scheduler.Call.IShutdown=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Shutdown} Shutdown instance
                 */
                Shutdown.create = function create(properties) {
                    return new Shutdown(properties);
                };

                /**
                 * Encodes the specified Shutdown message. Does not implicitly {@link mesos.scheduler.Call.Shutdown.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {mesos.scheduler.Call.IShutdown} message Shutdown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Shutdown message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Shutdown.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {mesos.scheduler.Call.IShutdown} message Shutdown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Shutdown.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Shutdown message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Shutdown} Shutdown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Shutdown();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("executorId"))
                        throw $util.ProtocolError("missing required 'executorId'", { instance: message });
                    if (!message.hasOwnProperty("agentId"))
                        throw $util.ProtocolError("missing required 'agentId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Shutdown message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Shutdown} Shutdown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Shutdown.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Shutdown message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Shutdown.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.ExecutorID.verify(message.executorId);
                    if (error)
                        return "executorId." + error;
                    error = $root.mesos.AgentID.verify(message.agentId);
                    if (error)
                        return "agentId." + error;
                    return null;
                };

                /**
                 * Creates a Shutdown message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Shutdown} Shutdown
                 */
                Shutdown.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Shutdown)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Shutdown();
                    if (object.executorId != null) {
                        if (typeof object.executorId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Shutdown.executorId: object expected");
                        message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
                    }
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Shutdown.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Shutdown message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @static
                 * @param {mesos.scheduler.Call.Shutdown} message Shutdown
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Shutdown.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.executorId = null;
                        object.agentId = null;
                    }
                    if (message.executorId != null && message.hasOwnProperty("executorId"))
                        object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    return object;
                };

                /**
                 * Converts this Shutdown to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Shutdown
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Shutdown.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Shutdown;
            })();

            Call.Acknowledge = (function() {

                /**
                 * Properties of an Acknowledge.
                 * @memberof mesos.scheduler.Call
                 * @interface IAcknowledge
                 * @property {mesos.IAgentID} agentId Acknowledge agentId
                 * @property {mesos.ITaskID} taskId Acknowledge taskId
                 * @property {Uint8Array} uuid Acknowledge uuid
                 */

                /**
                 * Constructs a new Acknowledge.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents an Acknowledge.
                 * @constructor
                 * @param {mesos.scheduler.Call.IAcknowledge=} [properties] Properties to set
                 */
                function Acknowledge(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Acknowledge agentId.
                 * @member {mesos.IAgentID}agentId
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @instance
                 */
                Acknowledge.prototype.agentId = null;

                /**
                 * Acknowledge taskId.
                 * @member {mesos.ITaskID}taskId
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @instance
                 */
                Acknowledge.prototype.taskId = null;

                /**
                 * Acknowledge uuid.
                 * @member {Uint8Array}uuid
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @instance
                 */
                Acknowledge.prototype.uuid = $util.newBuffer([]);

                /**
                 * Creates a new Acknowledge instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {mesos.scheduler.Call.IAcknowledge=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Acknowledge} Acknowledge instance
                 */
                Acknowledge.create = function create(properties) {
                    return new Acknowledge(properties);
                };

                /**
                 * Encodes the specified Acknowledge message. Does not implicitly {@link mesos.scheduler.Call.Acknowledge.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {mesos.scheduler.Call.IAcknowledge} message Acknowledge message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Acknowledge.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.uuid);
                    return writer;
                };

                /**
                 * Encodes the specified Acknowledge message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Acknowledge.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {mesos.scheduler.Call.IAcknowledge} message Acknowledge message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Acknowledge.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Acknowledge message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Acknowledge} Acknowledge
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Acknowledge.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Acknowledge();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.uuid = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("agentId"))
                        throw $util.ProtocolError("missing required 'agentId'", { instance: message });
                    if (!message.hasOwnProperty("taskId"))
                        throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                    if (!message.hasOwnProperty("uuid"))
                        throw $util.ProtocolError("missing required 'uuid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Acknowledge message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Acknowledge} Acknowledge
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Acknowledge.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Acknowledge message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Acknowledge.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.AgentID.verify(message.agentId);
                    if (error)
                        return "agentId." + error;
                    error = $root.mesos.TaskID.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                    if (!(message.uuid && typeof message.uuid.length === "number" || $util.isString(message.uuid)))
                        return "uuid: buffer expected";
                    return null;
                };

                /**
                 * Creates an Acknowledge message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Acknowledge} Acknowledge
                 */
                Acknowledge.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Acknowledge)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Acknowledge();
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Acknowledge.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    if (object.taskId != null) {
                        if (typeof object.taskId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Acknowledge.taskId: object expected");
                        message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
                    }
                    if (object.uuid != null)
                        if (typeof object.uuid === "string")
                            $util.base64.decode(object.uuid, message.uuid = $util.newBuffer($util.base64.length(object.uuid)), 0);
                        else if (object.uuid.length)
                            message.uuid = object.uuid;
                    return message;
                };

                /**
                 * Creates a plain object from an Acknowledge message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @static
                 * @param {mesos.scheduler.Call.Acknowledge} message Acknowledge
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Acknowledge.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.agentId = null;
                        object.taskId = null;
                        object.uuid = options.bytes === String ? "" : [];
                    }
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = options.bytes === String ? $util.base64.encode(message.uuid, 0, message.uuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uuid) : message.uuid;
                    return object;
                };

                /**
                 * Converts this Acknowledge to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Acknowledge
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Acknowledge.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Acknowledge;
            })();

            Call.Reconcile = (function() {

                /**
                 * Properties of a Reconcile.
                 * @memberof mesos.scheduler.Call
                 * @interface IReconcile
                 * @property {Array.<mesos.scheduler.Call.Reconcile.ITask>} [tasks] Reconcile tasks
                 */

                /**
                 * Constructs a new Reconcile.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Reconcile.
                 * @constructor
                 * @param {mesos.scheduler.Call.IReconcile=} [properties] Properties to set
                 */
                function Reconcile(properties) {
                    this.tasks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reconcile tasks.
                 * @member {Array.<mesos.scheduler.Call.Reconcile.ITask>}tasks
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @instance
                 */
                Reconcile.prototype.tasks = $util.emptyArray;

                /**
                 * Creates a new Reconcile instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {mesos.scheduler.Call.IReconcile=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Reconcile} Reconcile instance
                 */
                Reconcile.create = function create(properties) {
                    return new Reconcile(properties);
                };

                /**
                 * Encodes the specified Reconcile message. Does not implicitly {@link mesos.scheduler.Call.Reconcile.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {mesos.scheduler.Call.IReconcile} message Reconcile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reconcile.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.tasks != null && message.tasks.length)
                        for (let i = 0; i < message.tasks.length; ++i)
                            $root.mesos.scheduler.Call.Reconcile.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Reconcile message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Reconcile.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {mesos.scheduler.Call.IReconcile} message Reconcile message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Reconcile.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Reconcile message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Reconcile} Reconcile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reconcile.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Reconcile();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.mesos.scheduler.Call.Reconcile.Task.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Reconcile message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Reconcile} Reconcile
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Reconcile.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Reconcile message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reconcile.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.tasks != null && message.hasOwnProperty("tasks")) {
                        if (!Array.isArray(message.tasks))
                            return "tasks: array expected";
                        for (let i = 0; i < message.tasks.length; ++i) {
                            let error = $root.mesos.scheduler.Call.Reconcile.Task.verify(message.tasks[i]);
                            if (error)
                                return "tasks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Reconcile message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Reconcile} Reconcile
                 */
                Reconcile.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Reconcile)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Reconcile();
                    if (object.tasks) {
                        if (!Array.isArray(object.tasks))
                            throw TypeError(".mesos.scheduler.Call.Reconcile.tasks: array expected");
                        message.tasks = [];
                        for (let i = 0; i < object.tasks.length; ++i) {
                            if (typeof object.tasks[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.Reconcile.tasks: object expected");
                            message.tasks[i] = $root.mesos.scheduler.Call.Reconcile.Task.fromObject(object.tasks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Reconcile message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @static
                 * @param {mesos.scheduler.Call.Reconcile} message Reconcile
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reconcile.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.tasks = [];
                    if (message.tasks && message.tasks.length) {
                        object.tasks = [];
                        for (let j = 0; j < message.tasks.length; ++j)
                            object.tasks[j] = $root.mesos.scheduler.Call.Reconcile.Task.toObject(message.tasks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Reconcile to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Reconcile
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reconcile.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Reconcile.Task = (function() {

                    /**
                     * Properties of a Task.
                     * @memberof mesos.scheduler.Call.Reconcile
                     * @interface ITask
                     * @property {mesos.ITaskID} taskId Task taskId
                     * @property {mesos.IAgentID} [agentId] Task agentId
                     */

                    /**
                     * Constructs a new Task.
                     * @memberof mesos.scheduler.Call.Reconcile
                     * @classdesc Represents a Task.
                     * @constructor
                     * @param {mesos.scheduler.Call.Reconcile.ITask=} [properties] Properties to set
                     */
                    function Task(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Task taskId.
                     * @member {mesos.ITaskID}taskId
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @instance
                     */
                    Task.prototype.taskId = null;

                    /**
                     * Task agentId.
                     * @member {(mesos.IAgentID|null|undefined)}agentId
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @instance
                     */
                    Task.prototype.agentId = null;

                    /**
                     * Creates a new Task instance using the specified properties.
                     * @function create
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {mesos.scheduler.Call.Reconcile.ITask=} [properties] Properties to set
                     * @returns {mesos.scheduler.Call.Reconcile.Task} Task instance
                     */
                    Task.create = function create(properties) {
                        return new Task(properties);
                    };

                    /**
                     * Encodes the specified Task message. Does not implicitly {@link mesos.scheduler.Call.Reconcile.Task.verify|verify} messages.
                     * @function encode
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {mesos.scheduler.Call.Reconcile.ITask} message Task message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Task.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.agentId != null && message.hasOwnProperty("agentId"))
                            $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Task message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Reconcile.Task.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {mesos.scheduler.Call.Reconcile.ITask} message Task message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Task.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Task message from the specified reader or buffer.
                     * @function decode
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {mesos.scheduler.Call.Reconcile.Task} Task
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Task.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Reconcile.Task();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("taskId"))
                            throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                        return message;
                    };

                    /**
                     * Decodes a Task message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {mesos.scheduler.Call.Reconcile.Task} Task
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Task.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Task message.
                     * @function verify
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Task.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let error = $root.mesos.TaskID.verify(message.taskId);
                        if (error)
                            return "taskId." + error;
                        if (message.agentId != null && message.hasOwnProperty("agentId")) {
                            error = $root.mesos.AgentID.verify(message.agentId);
                            if (error)
                                return "agentId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Task message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {mesos.scheduler.Call.Reconcile.Task} Task
                     */
                    Task.fromObject = function fromObject(object) {
                        if (object instanceof $root.mesos.scheduler.Call.Reconcile.Task)
                            return object;
                        let message = new $root.mesos.scheduler.Call.Reconcile.Task();
                        if (object.taskId != null) {
                            if (typeof object.taskId !== "object")
                                throw TypeError(".mesos.scheduler.Call.Reconcile.Task.taskId: object expected");
                            message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
                        }
                        if (object.agentId != null) {
                            if (typeof object.agentId !== "object")
                                throw TypeError(".mesos.scheduler.Call.Reconcile.Task.agentId: object expected");
                            message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Task message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @static
                     * @param {mesos.scheduler.Call.Reconcile.Task} message Task
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Task.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.taskId = null;
                            object.agentId = null;
                        }
                        if (message.taskId != null && message.hasOwnProperty("taskId"))
                            object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
                        if (message.agentId != null && message.hasOwnProperty("agentId"))
                            object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                        return object;
                    };

                    /**
                     * Converts this Task to JSON.
                     * @function toJSON
                     * @memberof mesos.scheduler.Call.Reconcile.Task
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Task.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Task;
                })();

                return Reconcile;
            })();

            Call.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof mesos.scheduler.Call
                 * @interface IMessage
                 * @property {mesos.IAgentID} agentId Message agentId
                 * @property {mesos.IExecutorID} executorId Message executorId
                 * @property {Uint8Array} data Message data
                 */

                /**
                 * Constructs a new Message.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Message.
                 * @constructor
                 * @param {mesos.scheduler.Call.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message agentId.
                 * @member {mesos.IAgentID}agentId
                 * @memberof mesos.scheduler.Call.Message
                 * @instance
                 */
                Message.prototype.agentId = null;

                /**
                 * Message executorId.
                 * @member {mesos.IExecutorID}executorId
                 * @memberof mesos.scheduler.Call.Message
                 * @instance
                 */
                Message.prototype.executorId = null;

                /**
                 * Message data.
                 * @member {Uint8Array}data
                 * @memberof mesos.scheduler.Call.Message
                 * @instance
                 */
                Message.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {mesos.scheduler.Call.IMessage=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link mesos.scheduler.Call.Message.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {mesos.scheduler.Call.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.AgentID.encode(message.agentId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {mesos.scheduler.Call.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.agentId = $root.mesos.AgentID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("agentId"))
                        throw $util.ProtocolError("missing required 'agentId'", { instance: message });
                    if (!message.hasOwnProperty("executorId"))
                        throw $util.ProtocolError("missing required 'executorId'", { instance: message });
                    if (!message.hasOwnProperty("data"))
                        throw $util.ProtocolError("missing required 'data'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.AgentID.verify(message.agentId);
                    if (error)
                        return "agentId." + error;
                    error = $root.mesos.ExecutorID.verify(message.executorId);
                    if (error)
                        return "executorId." + error;
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Message)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Message();
                    if (object.agentId != null) {
                        if (typeof object.agentId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Message.agentId: object expected");
                        message.agentId = $root.mesos.AgentID.fromObject(object.agentId);
                    }
                    if (object.executorId != null) {
                        if (typeof object.executorId !== "object")
                            throw TypeError(".mesos.scheduler.Call.Message.executorId: object expected");
                        message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
                    }
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Message
                 * @static
                 * @param {mesos.scheduler.Call.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.agentId = null;
                        object.executorId = null;
                        object.data = options.bytes === String ? "" : [];
                    }
                    if (message.agentId != null && message.hasOwnProperty("agentId"))
                        object.agentId = $root.mesos.AgentID.toObject(message.agentId, options);
                    if (message.executorId != null && message.hasOwnProperty("executorId"))
                        object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            Call.Request = (function() {

                /**
                 * Properties of a Request.
                 * @memberof mesos.scheduler.Call
                 * @interface IRequest
                 * @property {Array.<mesos.IRequest>} [requests] Request requests
                 */

                /**
                 * Constructs a new Request.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Request.
                 * @constructor
                 * @param {mesos.scheduler.Call.IRequest=} [properties] Properties to set
                 */
                function Request(properties) {
                    this.requests = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Request requests.
                 * @member {Array.<mesos.IRequest>}requests
                 * @memberof mesos.scheduler.Call.Request
                 * @instance
                 */
                Request.prototype.requests = $util.emptyArray;

                /**
                 * Creates a new Request instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {mesos.scheduler.Call.IRequest=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Request} Request instance
                 */
                Request.create = function create(properties) {
                    return new Request(properties);
                };

                /**
                 * Encodes the specified Request message. Does not implicitly {@link mesos.scheduler.Call.Request.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {mesos.scheduler.Call.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.requests != null && message.requests.length)
                        for (let i = 0; i < message.requests.length; ++i)
                            $root.mesos.Request.encode(message.requests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Request message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Request.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {mesos.scheduler.Call.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Request message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Request();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.requests && message.requests.length))
                                message.requests = [];
                            message.requests.push($root.mesos.Request.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Request message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Request message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Request.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.requests != null && message.hasOwnProperty("requests")) {
                        if (!Array.isArray(message.requests))
                            return "requests: array expected";
                        for (let i = 0; i < message.requests.length; ++i) {
                            let error = $root.mesos.Request.verify(message.requests[i]);
                            if (error)
                                return "requests." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Request message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Request} Request
                 */
                Request.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Request)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Request();
                    if (object.requests) {
                        if (!Array.isArray(object.requests))
                            throw TypeError(".mesos.scheduler.Call.Request.requests: array expected");
                        message.requests = [];
                        for (let i = 0; i < object.requests.length; ++i) {
                            if (typeof object.requests[i] !== "object")
                                throw TypeError(".mesos.scheduler.Call.Request.requests: object expected");
                            message.requests[i] = $root.mesos.Request.fromObject(object.requests[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Request message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Request
                 * @static
                 * @param {mesos.scheduler.Call.Request} message Request
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Request.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.requests = [];
                    if (message.requests && message.requests.length) {
                        object.requests = [];
                        for (let j = 0; j < message.requests.length; ++j)
                            object.requests[j] = $root.mesos.Request.toObject(message.requests[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Request to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Request
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Request.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Request;
            })();

            Call.Suppress = (function() {

                /**
                 * Properties of a Suppress.
                 * @memberof mesos.scheduler.Call
                 * @interface ISuppress
                 * @property {string} [role] Suppress role
                 */

                /**
                 * Constructs a new Suppress.
                 * @memberof mesos.scheduler.Call
                 * @classdesc Represents a Suppress.
                 * @constructor
                 * @param {mesos.scheduler.Call.ISuppress=} [properties] Properties to set
                 */
                function Suppress(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Suppress role.
                 * @member {string}role
                 * @memberof mesos.scheduler.Call.Suppress
                 * @instance
                 */
                Suppress.prototype.role = "";

                /**
                 * Creates a new Suppress instance using the specified properties.
                 * @function create
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {mesos.scheduler.Call.ISuppress=} [properties] Properties to set
                 * @returns {mesos.scheduler.Call.Suppress} Suppress instance
                 */
                Suppress.create = function create(properties) {
                    return new Suppress(properties);
                };

                /**
                 * Encodes the specified Suppress message. Does not implicitly {@link mesos.scheduler.Call.Suppress.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {mesos.scheduler.Call.ISuppress} message Suppress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Suppress.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.role != null && message.hasOwnProperty("role"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.role);
                    return writer;
                };

                /**
                 * Encodes the specified Suppress message, length delimited. Does not implicitly {@link mesos.scheduler.Call.Suppress.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {mesos.scheduler.Call.ISuppress} message Suppress message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Suppress.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Suppress message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.scheduler.Call.Suppress} Suppress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Suppress.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.scheduler.Call.Suppress();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.role = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Suppress message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.scheduler.Call.Suppress} Suppress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Suppress.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Suppress message.
                 * @function verify
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Suppress.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.role != null && message.hasOwnProperty("role"))
                        if (!$util.isString(message.role))
                            return "role: string expected";
                    return null;
                };

                /**
                 * Creates a Suppress message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.scheduler.Call.Suppress} Suppress
                 */
                Suppress.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.scheduler.Call.Suppress)
                        return object;
                    let message = new $root.mesos.scheduler.Call.Suppress();
                    if (object.role != null)
                        message.role = String(object.role);
                    return message;
                };

                /**
                 * Creates a plain object from a Suppress message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.scheduler.Call.Suppress
                 * @static
                 * @param {mesos.scheduler.Call.Suppress} message Suppress
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Suppress.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.role = "";
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = message.role;
                    return object;
                };

                /**
                 * Converts this Suppress to JSON.
                 * @function toJSON
                 * @memberof mesos.scheduler.Call.Suppress
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Suppress.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Suppress;
            })();

            return Call;
        })();

        return scheduler;
    })();

    mesos.executor = (function() {

        /**
         * Namespace executor.
         * @memberof mesos
         * @namespace
         */
        const executor = {};

        executor.Event = (function() {

            /**
             * Properties of an Event.
             * @memberof mesos.executor
             * @interface IEvent
             * @property {mesos.executor.Event.Type} [type] Event type
             * @property {mesos.executor.Event.ISubscribed} [subscribed] Event subscribed
             * @property {mesos.executor.Event.IAcknowledged} [acknowledged] Event acknowledged
             * @property {mesos.executor.Event.ILaunch} [launch] Event launch
             * @property {mesos.executor.Event.ILaunchGroup} [launchGroup] Event launchGroup
             * @property {mesos.executor.Event.IKill} [kill] Event kill
             * @property {mesos.executor.Event.IMessage} [message] Event message
             * @property {mesos.executor.Event.IError} [error] Event error
             */

            /**
             * Constructs a new Event.
             * @memberof mesos.executor
             * @classdesc Executor event API.
             * 
             * An event is described using the standard protocol buffer "union"
             * trick, see https://developers.google.com/protocol-buffers/docs/techniques#union.
             * @constructor
             * @param {mesos.executor.IEvent=} [properties] Properties to set
             */
            function Event(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Event type.
             * @member {mesos.executor.Event.Type}type
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.type = 0;

            /**
             * Event subscribed.
             * @member {(mesos.executor.Event.ISubscribed|null|undefined)}subscribed
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.subscribed = null;

            /**
             * Event acknowledged.
             * @member {(mesos.executor.Event.IAcknowledged|null|undefined)}acknowledged
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.acknowledged = null;

            /**
             * Event launch.
             * @member {(mesos.executor.Event.ILaunch|null|undefined)}launch
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.launch = null;

            /**
             * Event launchGroup.
             * @member {(mesos.executor.Event.ILaunchGroup|null|undefined)}launchGroup
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.launchGroup = null;

            /**
             * Event kill.
             * @member {(mesos.executor.Event.IKill|null|undefined)}kill
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.kill = null;

            /**
             * Event message.
             * @member {(mesos.executor.Event.IMessage|null|undefined)}message
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.message = null;

            /**
             * Event error.
             * @member {(mesos.executor.Event.IError|null|undefined)}error
             * @memberof mesos.executor.Event
             * @instance
             */
            Event.prototype.error = null;

            /**
             * Creates a new Event instance using the specified properties.
             * @function create
             * @memberof mesos.executor.Event
             * @static
             * @param {mesos.executor.IEvent=} [properties] Properties to set
             * @returns {mesos.executor.Event} Event instance
             */
            Event.create = function create(properties) {
                return new Event(properties);
            };

            /**
             * Encodes the specified Event message. Does not implicitly {@link mesos.executor.Event.verify|verify} messages.
             * @function encode
             * @memberof mesos.executor.Event
             * @static
             * @param {mesos.executor.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.subscribed != null && message.hasOwnProperty("subscribed"))
                    $root.mesos.executor.Event.Subscribed.encode(message.subscribed, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.acknowledged != null && message.hasOwnProperty("acknowledged"))
                    $root.mesos.executor.Event.Acknowledged.encode(message.acknowledged, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.launch != null && message.hasOwnProperty("launch"))
                    $root.mesos.executor.Event.Launch.encode(message.launch, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.kill != null && message.hasOwnProperty("kill"))
                    $root.mesos.executor.Event.Kill.encode(message.kill, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    $root.mesos.executor.Event.Message.encode(message.message, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.mesos.executor.Event.Error.encode(message.error, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup"))
                    $root.mesos.executor.Event.LaunchGroup.encode(message.launchGroup, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Event message, length delimited. Does not implicitly {@link mesos.executor.Event.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.executor.Event
             * @static
             * @param {mesos.executor.IEvent} message Event message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Event.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Event message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.executor.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.executor.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.subscribed = $root.mesos.executor.Event.Subscribed.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.acknowledged = $root.mesos.executor.Event.Acknowledged.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.launch = $root.mesos.executor.Event.Launch.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.launchGroup = $root.mesos.executor.Event.LaunchGroup.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.kill = $root.mesos.executor.Event.Kill.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.message = $root.mesos.executor.Event.Message.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.error = $root.mesos.executor.Event.Error.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Event message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.executor.Event
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.executor.Event} Event
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Event.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Event message.
             * @function verify
             * @memberof mesos.executor.Event
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Event.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 8:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.subscribed != null && message.hasOwnProperty("subscribed")) {
                    let error = $root.mesos.executor.Event.Subscribed.verify(message.subscribed);
                    if (error)
                        return "subscribed." + error;
                }
                if (message.acknowledged != null && message.hasOwnProperty("acknowledged")) {
                    error = $root.mesos.executor.Event.Acknowledged.verify(message.acknowledged);
                    if (error)
                        return "acknowledged." + error;
                }
                if (message.launch != null && message.hasOwnProperty("launch")) {
                    error = $root.mesos.executor.Event.Launch.verify(message.launch);
                    if (error)
                        return "launch." + error;
                }
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup")) {
                    error = $root.mesos.executor.Event.LaunchGroup.verify(message.launchGroup);
                    if (error)
                        return "launchGroup." + error;
                }
                if (message.kill != null && message.hasOwnProperty("kill")) {
                    error = $root.mesos.executor.Event.Kill.verify(message.kill);
                    if (error)
                        return "kill." + error;
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    error = $root.mesos.executor.Event.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                if (message.error != null && message.hasOwnProperty("error")) {
                    error = $root.mesos.executor.Event.Error.verify(message.error);
                    if (error)
                        return "error." + error;
                }
                return null;
            };

            /**
             * Creates an Event message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.executor.Event
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.executor.Event} Event
             */
            Event.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.executor.Event)
                    return object;
                let message = new $root.mesos.executor.Event();
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "SUBSCRIBED":
                case 1:
                    message.type = 1;
                    break;
                case "LAUNCH":
                case 2:
                    message.type = 2;
                    break;
                case "LAUNCH_GROUP":
                case 8:
                    message.type = 8;
                    break;
                case "KILL":
                case 3:
                    message.type = 3;
                    break;
                case "ACKNOWLEDGED":
                case 4:
                    message.type = 4;
                    break;
                case "MESSAGE":
                case 5:
                    message.type = 5;
                    break;
                case "ERROR":
                case 6:
                    message.type = 6;
                    break;
                case "SHUTDOWN":
                case 7:
                    message.type = 7;
                    break;
                }
                if (object.subscribed != null) {
                    if (typeof object.subscribed !== "object")
                        throw TypeError(".mesos.executor.Event.subscribed: object expected");
                    message.subscribed = $root.mesos.executor.Event.Subscribed.fromObject(object.subscribed);
                }
                if (object.acknowledged != null) {
                    if (typeof object.acknowledged !== "object")
                        throw TypeError(".mesos.executor.Event.acknowledged: object expected");
                    message.acknowledged = $root.mesos.executor.Event.Acknowledged.fromObject(object.acknowledged);
                }
                if (object.launch != null) {
                    if (typeof object.launch !== "object")
                        throw TypeError(".mesos.executor.Event.launch: object expected");
                    message.launch = $root.mesos.executor.Event.Launch.fromObject(object.launch);
                }
                if (object.launchGroup != null) {
                    if (typeof object.launchGroup !== "object")
                        throw TypeError(".mesos.executor.Event.launchGroup: object expected");
                    message.launchGroup = $root.mesos.executor.Event.LaunchGroup.fromObject(object.launchGroup);
                }
                if (object.kill != null) {
                    if (typeof object.kill !== "object")
                        throw TypeError(".mesos.executor.Event.kill: object expected");
                    message.kill = $root.mesos.executor.Event.Kill.fromObject(object.kill);
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".mesos.executor.Event.message: object expected");
                    message.message = $root.mesos.executor.Event.Message.fromObject(object.message);
                }
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".mesos.executor.Event.error: object expected");
                    message.error = $root.mesos.executor.Event.Error.fromObject(object.error);
                }
                return message;
            };

            /**
             * Creates a plain object from an Event message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.executor.Event
             * @static
             * @param {mesos.executor.Event} message Event
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Event.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.subscribed = null;
                    object.acknowledged = null;
                    object.launch = null;
                    object.kill = null;
                    object.message = null;
                    object.error = null;
                    object.launchGroup = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.executor.Event.Type[message.type] : message.type;
                if (message.subscribed != null && message.hasOwnProperty("subscribed"))
                    object.subscribed = $root.mesos.executor.Event.Subscribed.toObject(message.subscribed, options);
                if (message.acknowledged != null && message.hasOwnProperty("acknowledged"))
                    object.acknowledged = $root.mesos.executor.Event.Acknowledged.toObject(message.acknowledged, options);
                if (message.launch != null && message.hasOwnProperty("launch"))
                    object.launch = $root.mesos.executor.Event.Launch.toObject(message.launch, options);
                if (message.kill != null && message.hasOwnProperty("kill"))
                    object.kill = $root.mesos.executor.Event.Kill.toObject(message.kill, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.mesos.executor.Event.Message.toObject(message.message, options);
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = $root.mesos.executor.Event.Error.toObject(message.error, options);
                if (message.launchGroup != null && message.hasOwnProperty("launchGroup"))
                    object.launchGroup = $root.mesos.executor.Event.LaunchGroup.toObject(message.launchGroup, options);
                return object;
            };

            /**
             * Converts this Event to JSON.
             * @function toJSON
             * @memberof mesos.executor.Event
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Event.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUBSCRIBED=1 SUBSCRIBED value
             * @property {number} LAUNCH=2 LAUNCH value
             * @property {number} LAUNCH_GROUP=8 LAUNCH_GROUP value
             * @property {number} KILL=3 KILL value
             * @property {number} ACKNOWLEDGED=4 ACKNOWLEDGED value
             * @property {number} MESSAGE=5 MESSAGE value
             * @property {number} ERROR=6 ERROR value
             * @property {number} SHUTDOWN=7 SHUTDOWN value
             */
            Event.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUBSCRIBED"] = 1;
                values[valuesById[2] = "LAUNCH"] = 2;
                values[valuesById[8] = "LAUNCH_GROUP"] = 8;
                values[valuesById[3] = "KILL"] = 3;
                values[valuesById[4] = "ACKNOWLEDGED"] = 4;
                values[valuesById[5] = "MESSAGE"] = 5;
                values[valuesById[6] = "ERROR"] = 6;
                values[valuesById[7] = "SHUTDOWN"] = 7;
                return values;
            })();

            Event.Subscribed = (function() {

                /**
                 * Properties of a Subscribed.
                 * @memberof mesos.executor.Event
                 * @interface ISubscribed
                 * @property {mesos.IExecutorInfo} executorInfo Subscribed executorInfo
                 * @property {mesos.IFrameworkInfo} frameworkInfo Subscribed frameworkInfo
                 * @property {mesos.IAgentInfo} agentInfo Subscribed agentInfo
                 * @property {mesos.IContainerID} [containerId] Subscribed containerId
                 */

                /**
                 * Constructs a new Subscribed.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents a Subscribed.
                 * @constructor
                 * @param {mesos.executor.Event.ISubscribed=} [properties] Properties to set
                 */
                function Subscribed(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subscribed executorInfo.
                 * @member {mesos.IExecutorInfo}executorInfo
                 * @memberof mesos.executor.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.executorInfo = null;

                /**
                 * Subscribed frameworkInfo.
                 * @member {mesos.IFrameworkInfo}frameworkInfo
                 * @memberof mesos.executor.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.frameworkInfo = null;

                /**
                 * Subscribed agentInfo.
                 * @member {mesos.IAgentInfo}agentInfo
                 * @memberof mesos.executor.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.agentInfo = null;

                /**
                 * Subscribed containerId.
                 * @member {(mesos.IContainerID|null|undefined)}containerId
                 * @memberof mesos.executor.Event.Subscribed
                 * @instance
                 */
                Subscribed.prototype.containerId = null;

                /**
                 * Creates a new Subscribed instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {mesos.executor.Event.ISubscribed=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Subscribed} Subscribed instance
                 */
                Subscribed.create = function create(properties) {
                    return new Subscribed(properties);
                };

                /**
                 * Encodes the specified Subscribed message. Does not implicitly {@link mesos.executor.Event.Subscribed.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {mesos.executor.Event.ISubscribed} message Subscribed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribed.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.ExecutorInfo.encode(message.executorInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    $root.mesos.FrameworkInfo.encode(message.frameworkInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    $root.mesos.AgentInfo.encode(message.agentInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.containerId != null && message.hasOwnProperty("containerId"))
                        $root.mesos.ContainerID.encode(message.containerId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Subscribed message, length delimited. Does not implicitly {@link mesos.executor.Event.Subscribed.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {mesos.executor.Event.ISubscribed} message Subscribed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribed.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subscribed message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Subscribed} Subscribed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribed.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Subscribed();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.executorInfo = $root.mesos.ExecutorInfo.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.frameworkInfo = $root.mesos.FrameworkInfo.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.agentInfo = $root.mesos.AgentInfo.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.containerId = $root.mesos.ContainerID.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("executorInfo"))
                        throw $util.ProtocolError("missing required 'executorInfo'", { instance: message });
                    if (!message.hasOwnProperty("frameworkInfo"))
                        throw $util.ProtocolError("missing required 'frameworkInfo'", { instance: message });
                    if (!message.hasOwnProperty("agentInfo"))
                        throw $util.ProtocolError("missing required 'agentInfo'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Subscribed message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Subscribed} Subscribed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribed.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subscribed message.
                 * @function verify
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subscribed.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.ExecutorInfo.verify(message.executorInfo);
                    if (error)
                        return "executorInfo." + error;
                    error = $root.mesos.FrameworkInfo.verify(message.frameworkInfo);
                    if (error)
                        return "frameworkInfo." + error;
                    error = $root.mesos.AgentInfo.verify(message.agentInfo);
                    if (error)
                        return "agentInfo." + error;
                    if (message.containerId != null && message.hasOwnProperty("containerId")) {
                        error = $root.mesos.ContainerID.verify(message.containerId);
                        if (error)
                            return "containerId." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Subscribed message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Subscribed} Subscribed
                 */
                Subscribed.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Subscribed)
                        return object;
                    let message = new $root.mesos.executor.Event.Subscribed();
                    if (object.executorInfo != null) {
                        if (typeof object.executorInfo !== "object")
                            throw TypeError(".mesos.executor.Event.Subscribed.executorInfo: object expected");
                        message.executorInfo = $root.mesos.ExecutorInfo.fromObject(object.executorInfo);
                    }
                    if (object.frameworkInfo != null) {
                        if (typeof object.frameworkInfo !== "object")
                            throw TypeError(".mesos.executor.Event.Subscribed.frameworkInfo: object expected");
                        message.frameworkInfo = $root.mesos.FrameworkInfo.fromObject(object.frameworkInfo);
                    }
                    if (object.agentInfo != null) {
                        if (typeof object.agentInfo !== "object")
                            throw TypeError(".mesos.executor.Event.Subscribed.agentInfo: object expected");
                        message.agentInfo = $root.mesos.AgentInfo.fromObject(object.agentInfo);
                    }
                    if (object.containerId != null) {
                        if (typeof object.containerId !== "object")
                            throw TypeError(".mesos.executor.Event.Subscribed.containerId: object expected");
                        message.containerId = $root.mesos.ContainerID.fromObject(object.containerId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subscribed message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Subscribed
                 * @static
                 * @param {mesos.executor.Event.Subscribed} message Subscribed
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subscribed.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.executorInfo = null;
                        object.frameworkInfo = null;
                        object.agentInfo = null;
                        object.containerId = null;
                    }
                    if (message.executorInfo != null && message.hasOwnProperty("executorInfo"))
                        object.executorInfo = $root.mesos.ExecutorInfo.toObject(message.executorInfo, options);
                    if (message.frameworkInfo != null && message.hasOwnProperty("frameworkInfo"))
                        object.frameworkInfo = $root.mesos.FrameworkInfo.toObject(message.frameworkInfo, options);
                    if (message.agentInfo != null && message.hasOwnProperty("agentInfo"))
                        object.agentInfo = $root.mesos.AgentInfo.toObject(message.agentInfo, options);
                    if (message.containerId != null && message.hasOwnProperty("containerId"))
                        object.containerId = $root.mesos.ContainerID.toObject(message.containerId, options);
                    return object;
                };

                /**
                 * Converts this Subscribed to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Subscribed
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subscribed.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subscribed;
            })();

            Event.Launch = (function() {

                /**
                 * Properties of a Launch.
                 * @memberof mesos.executor.Event
                 * @interface ILaunch
                 * @property {mesos.ITaskInfo} task Launch task
                 */

                /**
                 * Constructs a new Launch.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents a Launch.
                 * @constructor
                 * @param {mesos.executor.Event.ILaunch=} [properties] Properties to set
                 */
                function Launch(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Launch task.
                 * @member {mesos.ITaskInfo}task
                 * @memberof mesos.executor.Event.Launch
                 * @instance
                 */
                Launch.prototype.task = null;

                /**
                 * Creates a new Launch instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {mesos.executor.Event.ILaunch=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Launch} Launch instance
                 */
                Launch.create = function create(properties) {
                    return new Launch(properties);
                };

                /**
                 * Encodes the specified Launch message. Does not implicitly {@link mesos.executor.Event.Launch.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {mesos.executor.Event.ILaunch} message Launch message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Launch.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskInfo.encode(message.task, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Launch message, length delimited. Does not implicitly {@link mesos.executor.Event.Launch.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {mesos.executor.Event.ILaunch} message Launch message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Launch.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Launch message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Launch} Launch
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Launch.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Launch();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.task = $root.mesos.TaskInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("task"))
                        throw $util.ProtocolError("missing required 'task'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Launch message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Launch} Launch
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Launch.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Launch message.
                 * @function verify
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Launch.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskInfo.verify(message.task);
                    if (error)
                        return "task." + error;
                    return null;
                };

                /**
                 * Creates a Launch message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Launch} Launch
                 */
                Launch.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Launch)
                        return object;
                    let message = new $root.mesos.executor.Event.Launch();
                    if (object.task != null) {
                        if (typeof object.task !== "object")
                            throw TypeError(".mesos.executor.Event.Launch.task: object expected");
                        message.task = $root.mesos.TaskInfo.fromObject(object.task);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Launch message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Launch
                 * @static
                 * @param {mesos.executor.Event.Launch} message Launch
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Launch.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.task = null;
                    if (message.task != null && message.hasOwnProperty("task"))
                        object.task = $root.mesos.TaskInfo.toObject(message.task, options);
                    return object;
                };

                /**
                 * Converts this Launch to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Launch
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Launch.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Launch;
            })();

            Event.LaunchGroup = (function() {

                /**
                 * Properties of a LaunchGroup.
                 * @memberof mesos.executor.Event
                 * @interface ILaunchGroup
                 * @property {mesos.ITaskGroupInfo} taskGroup LaunchGroup taskGroup
                 */

                /**
                 * Constructs a new LaunchGroup.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents a LaunchGroup.
                 * @constructor
                 * @param {mesos.executor.Event.ILaunchGroup=} [properties] Properties to set
                 */
                function LaunchGroup(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LaunchGroup taskGroup.
                 * @member {mesos.ITaskGroupInfo}taskGroup
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @instance
                 */
                LaunchGroup.prototype.taskGroup = null;

                /**
                 * Creates a new LaunchGroup instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {mesos.executor.Event.ILaunchGroup=} [properties] Properties to set
                 * @returns {mesos.executor.Event.LaunchGroup} LaunchGroup instance
                 */
                LaunchGroup.create = function create(properties) {
                    return new LaunchGroup(properties);
                };

                /**
                 * Encodes the specified LaunchGroup message. Does not implicitly {@link mesos.executor.Event.LaunchGroup.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {mesos.executor.Event.ILaunchGroup} message LaunchGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchGroup.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskGroupInfo.encode(message.taskGroup, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LaunchGroup message, length delimited. Does not implicitly {@link mesos.executor.Event.LaunchGroup.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {mesos.executor.Event.ILaunchGroup} message LaunchGroup message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LaunchGroup.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LaunchGroup message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.LaunchGroup} LaunchGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchGroup.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.LaunchGroup();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskGroup = $root.mesos.TaskGroupInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("taskGroup"))
                        throw $util.ProtocolError("missing required 'taskGroup'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a LaunchGroup message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.LaunchGroup} LaunchGroup
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LaunchGroup.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LaunchGroup message.
                 * @function verify
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LaunchGroup.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskGroupInfo.verify(message.taskGroup);
                    if (error)
                        return "taskGroup." + error;
                    return null;
                };

                /**
                 * Creates a LaunchGroup message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.LaunchGroup} LaunchGroup
                 */
                LaunchGroup.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.LaunchGroup)
                        return object;
                    let message = new $root.mesos.executor.Event.LaunchGroup();
                    if (object.taskGroup != null) {
                        if (typeof object.taskGroup !== "object")
                            throw TypeError(".mesos.executor.Event.LaunchGroup.taskGroup: object expected");
                        message.taskGroup = $root.mesos.TaskGroupInfo.fromObject(object.taskGroup);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LaunchGroup message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @static
                 * @param {mesos.executor.Event.LaunchGroup} message LaunchGroup
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LaunchGroup.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.taskGroup = null;
                    if (message.taskGroup != null && message.hasOwnProperty("taskGroup"))
                        object.taskGroup = $root.mesos.TaskGroupInfo.toObject(message.taskGroup, options);
                    return object;
                };

                /**
                 * Converts this LaunchGroup to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.LaunchGroup
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LaunchGroup.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LaunchGroup;
            })();

            Event.Kill = (function() {

                /**
                 * Properties of a Kill.
                 * @memberof mesos.executor.Event
                 * @interface IKill
                 * @property {mesos.ITaskID} taskId Kill taskId
                 * @property {mesos.IKillPolicy} [killPolicy] Kill killPolicy
                 */

                /**
                 * Constructs a new Kill.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents a Kill.
                 * @constructor
                 * @param {mesos.executor.Event.IKill=} [properties] Properties to set
                 */
                function Kill(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Kill taskId.
                 * @member {mesos.ITaskID}taskId
                 * @memberof mesos.executor.Event.Kill
                 * @instance
                 */
                Kill.prototype.taskId = null;

                /**
                 * Kill killPolicy.
                 * @member {(mesos.IKillPolicy|null|undefined)}killPolicy
                 * @memberof mesos.executor.Event.Kill
                 * @instance
                 */
                Kill.prototype.killPolicy = null;

                /**
                 * Creates a new Kill instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {mesos.executor.Event.IKill=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Kill} Kill instance
                 */
                Kill.create = function create(properties) {
                    return new Kill(properties);
                };

                /**
                 * Encodes the specified Kill message. Does not implicitly {@link mesos.executor.Event.Kill.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {mesos.executor.Event.IKill} message Kill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kill.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                        $root.mesos.KillPolicy.encode(message.killPolicy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Kill message, length delimited. Does not implicitly {@link mesos.executor.Event.Kill.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {mesos.executor.Event.IKill} message Kill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kill.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Kill message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Kill} Kill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kill.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Kill();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.killPolicy = $root.mesos.KillPolicy.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("taskId"))
                        throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Kill message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Kill} Kill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kill.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Kill message.
                 * @function verify
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Kill.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskID.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy")) {
                        error = $root.mesos.KillPolicy.verify(message.killPolicy);
                        if (error)
                            return "killPolicy." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Kill message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Kill} Kill
                 */
                Kill.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Kill)
                        return object;
                    let message = new $root.mesos.executor.Event.Kill();
                    if (object.taskId != null) {
                        if (typeof object.taskId !== "object")
                            throw TypeError(".mesos.executor.Event.Kill.taskId: object expected");
                        message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
                    }
                    if (object.killPolicy != null) {
                        if (typeof object.killPolicy !== "object")
                            throw TypeError(".mesos.executor.Event.Kill.killPolicy: object expected");
                        message.killPolicy = $root.mesos.KillPolicy.fromObject(object.killPolicy);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Kill message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Kill
                 * @static
                 * @param {mesos.executor.Event.Kill} message Kill
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Kill.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.taskId = null;
                        object.killPolicy = null;
                    }
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
                    if (message.killPolicy != null && message.hasOwnProperty("killPolicy"))
                        object.killPolicy = $root.mesos.KillPolicy.toObject(message.killPolicy, options);
                    return object;
                };

                /**
                 * Converts this Kill to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Kill
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Kill.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Kill;
            })();

            Event.Acknowledged = (function() {

                /**
                 * Properties of an Acknowledged.
                 * @memberof mesos.executor.Event
                 * @interface IAcknowledged
                 * @property {mesos.ITaskID} taskId Acknowledged taskId
                 * @property {Uint8Array} uuid Acknowledged uuid
                 */

                /**
                 * Constructs a new Acknowledged.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents an Acknowledged.
                 * @constructor
                 * @param {mesos.executor.Event.IAcknowledged=} [properties] Properties to set
                 */
                function Acknowledged(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Acknowledged taskId.
                 * @member {mesos.ITaskID}taskId
                 * @memberof mesos.executor.Event.Acknowledged
                 * @instance
                 */
                Acknowledged.prototype.taskId = null;

                /**
                 * Acknowledged uuid.
                 * @member {Uint8Array}uuid
                 * @memberof mesos.executor.Event.Acknowledged
                 * @instance
                 */
                Acknowledged.prototype.uuid = $util.newBuffer([]);

                /**
                 * Creates a new Acknowledged instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {mesos.executor.Event.IAcknowledged=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Acknowledged} Acknowledged instance
                 */
                Acknowledged.create = function create(properties) {
                    return new Acknowledged(properties);
                };

                /**
                 * Encodes the specified Acknowledged message. Does not implicitly {@link mesos.executor.Event.Acknowledged.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {mesos.executor.Event.IAcknowledged} message Acknowledged message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Acknowledged.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskID.encode(message.taskId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.uuid);
                    return writer;
                };

                /**
                 * Encodes the specified Acknowledged message, length delimited. Does not implicitly {@link mesos.executor.Event.Acknowledged.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {mesos.executor.Event.IAcknowledged} message Acknowledged message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Acknowledged.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Acknowledged message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Acknowledged} Acknowledged
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Acknowledged.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Acknowledged();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.taskId = $root.mesos.TaskID.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.uuid = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("taskId"))
                        throw $util.ProtocolError("missing required 'taskId'", { instance: message });
                    if (!message.hasOwnProperty("uuid"))
                        throw $util.ProtocolError("missing required 'uuid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Acknowledged message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Acknowledged} Acknowledged
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Acknowledged.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Acknowledged message.
                 * @function verify
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Acknowledged.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskID.verify(message.taskId);
                    if (error)
                        return "taskId." + error;
                    if (!(message.uuid && typeof message.uuid.length === "number" || $util.isString(message.uuid)))
                        return "uuid: buffer expected";
                    return null;
                };

                /**
                 * Creates an Acknowledged message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Acknowledged} Acknowledged
                 */
                Acknowledged.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Acknowledged)
                        return object;
                    let message = new $root.mesos.executor.Event.Acknowledged();
                    if (object.taskId != null) {
                        if (typeof object.taskId !== "object")
                            throw TypeError(".mesos.executor.Event.Acknowledged.taskId: object expected");
                        message.taskId = $root.mesos.TaskID.fromObject(object.taskId);
                    }
                    if (object.uuid != null)
                        if (typeof object.uuid === "string")
                            $util.base64.decode(object.uuid, message.uuid = $util.newBuffer($util.base64.length(object.uuid)), 0);
                        else if (object.uuid.length)
                            message.uuid = object.uuid;
                    return message;
                };

                /**
                 * Creates a plain object from an Acknowledged message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Acknowledged
                 * @static
                 * @param {mesos.executor.Event.Acknowledged} message Acknowledged
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Acknowledged.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.taskId = null;
                        object.uuid = options.bytes === String ? "" : [];
                    }
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        object.taskId = $root.mesos.TaskID.toObject(message.taskId, options);
                    if (message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = options.bytes === String ? $util.base64.encode(message.uuid, 0, message.uuid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uuid) : message.uuid;
                    return object;
                };

                /**
                 * Converts this Acknowledged to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Acknowledged
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Acknowledged.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Acknowledged;
            })();

            Event.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof mesos.executor.Event
                 * @interface IMessage
                 * @property {Uint8Array} data Message data
                 */

                /**
                 * Constructs a new Message.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents a Message.
                 * @constructor
                 * @param {mesos.executor.Event.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message data.
                 * @member {Uint8Array}data
                 * @memberof mesos.executor.Event.Message
                 * @instance
                 */
                Message.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {mesos.executor.Event.IMessage=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link mesos.executor.Event.Message.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {mesos.executor.Event.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link mesos.executor.Event.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {mesos.executor.Event.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("data"))
                        throw $util.ProtocolError("missing required 'data'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Message)
                        return object;
                    let message = new $root.mesos.executor.Event.Message();
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Message
                 * @static
                 * @param {mesos.executor.Event.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.data = options.bytes === String ? "" : [];
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            Event.Error = (function() {

                /**
                 * Properties of an Error.
                 * @memberof mesos.executor.Event
                 * @interface IError
                 * @property {string} message Error message
                 */

                /**
                 * Constructs a new Error.
                 * @memberof mesos.executor.Event
                 * @classdesc Represents an Error.
                 * @constructor
                 * @param {mesos.executor.Event.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Error message.
                 * @member {string}message
                 * @memberof mesos.executor.Event.Error
                 * @instance
                 */
                Error.prototype.message = "";

                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {mesos.executor.Event.IError=} [properties] Properties to set
                 * @returns {mesos.executor.Event.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };

                /**
                 * Encodes the specified Error message. Does not implicitly {@link mesos.executor.Event.Error.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {mesos.executor.Event.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified Error message, length delimited. Does not implicitly {@link mesos.executor.Event.Error.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {mesos.executor.Event.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Event.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Event.Error();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("message"))
                        throw $util.ProtocolError("missing required 'message'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Error message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Event.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.message))
                        return "message: string expected";
                    return null;
                };

                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Event.Error} Error
                 */
                Error.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Event.Error)
                        return object;
                    let message = new $root.mesos.executor.Event.Error();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Event.Error
                 * @static
                 * @param {mesos.executor.Event.Error} message Error
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Error.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.message = "";
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this Error to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Event.Error
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Error.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Error;
            })();

            return Event;
        })();

        executor.Call = (function() {

            /**
             * Properties of a Call.
             * @memberof mesos.executor
             * @interface ICall
             * @property {mesos.IExecutorID} executorId Call executorId
             * @property {mesos.IFrameworkID} frameworkId Call frameworkId
             * @property {mesos.executor.Call.Type} [type] Call type
             * @property {mesos.executor.Call.ISubscribe} [subscribe] Call subscribe
             * @property {mesos.executor.Call.IUpdate} [update] Call update
             * @property {mesos.executor.Call.IMessage} [message] Call message
             */

            /**
             * Constructs a new Call.
             * @memberof mesos.executor
             * @classdesc Executor call API.
             * 
             * Like Event, a Call is described using the standard protocol buffer
             * "union" trick (see above).
             * @constructor
             * @param {mesos.executor.ICall=} [properties] Properties to set
             */
            function Call(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Call executorId.
             * @member {mesos.IExecutorID}executorId
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.executorId = null;

            /**
             * Call frameworkId.
             * @member {mesos.IFrameworkID}frameworkId
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.frameworkId = null;

            /**
             * Call type.
             * @member {mesos.executor.Call.Type}type
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.type = 0;

            /**
             * Call subscribe.
             * @member {(mesos.executor.Call.ISubscribe|null|undefined)}subscribe
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.subscribe = null;

            /**
             * Call update.
             * @member {(mesos.executor.Call.IUpdate|null|undefined)}update
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.update = null;

            /**
             * Call message.
             * @member {(mesos.executor.Call.IMessage|null|undefined)}message
             * @memberof mesos.executor.Call
             * @instance
             */
            Call.prototype.message = null;

            /**
             * Creates a new Call instance using the specified properties.
             * @function create
             * @memberof mesos.executor.Call
             * @static
             * @param {mesos.executor.ICall=} [properties] Properties to set
             * @returns {mesos.executor.Call} Call instance
             */
            Call.create = function create(properties) {
                return new Call(properties);
            };

            /**
             * Encodes the specified Call message. Does not implicitly {@link mesos.executor.Call.verify|verify} messages.
             * @function encode
             * @memberof mesos.executor.Call
             * @static
             * @param {mesos.executor.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.mesos.ExecutorID.encode(message.executorId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                $root.mesos.FrameworkID.encode(message.frameworkId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.subscribe != null && message.hasOwnProperty("subscribe"))
                    $root.mesos.executor.Call.Subscribe.encode(message.subscribe, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.update != null && message.hasOwnProperty("update"))
                    $root.mesos.executor.Call.Update.encode(message.update, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.message != null && message.hasOwnProperty("message"))
                    $root.mesos.executor.Call.Message.encode(message.message, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Call message, length delimited. Does not implicitly {@link mesos.executor.Call.verify|verify} messages.
             * @function encodeDelimited
             * @memberof mesos.executor.Call
             * @static
             * @param {mesos.executor.ICall} message Call message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Call.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Call message from the specified reader or buffer.
             * @function decode
             * @memberof mesos.executor.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {mesos.executor.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Call();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.executorId = $root.mesos.ExecutorID.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.frameworkId = $root.mesos.FrameworkID.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.subscribe = $root.mesos.executor.Call.Subscribe.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.update = $root.mesos.executor.Call.Update.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.message = $root.mesos.executor.Call.Message.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("executorId"))
                    throw $util.ProtocolError("missing required 'executorId'", { instance: message });
                if (!message.hasOwnProperty("frameworkId"))
                    throw $util.ProtocolError("missing required 'frameworkId'", { instance: message });
                return message;
            };

            /**
             * Decodes a Call message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof mesos.executor.Call
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {mesos.executor.Call} Call
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Call.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Call message.
             * @function verify
             * @memberof mesos.executor.Call
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Call.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let error = $root.mesos.ExecutorID.verify(message.executorId);
                if (error)
                    return "executorId." + error;
                error = $root.mesos.FrameworkID.verify(message.frameworkId);
                if (error)
                    return "frameworkId." + error;
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.subscribe != null && message.hasOwnProperty("subscribe")) {
                    error = $root.mesos.executor.Call.Subscribe.verify(message.subscribe);
                    if (error)
                        return "subscribe." + error;
                }
                if (message.update != null && message.hasOwnProperty("update")) {
                    error = $root.mesos.executor.Call.Update.verify(message.update);
                    if (error)
                        return "update." + error;
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    error = $root.mesos.executor.Call.Message.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a Call message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof mesos.executor.Call
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {mesos.executor.Call} Call
             */
            Call.fromObject = function fromObject(object) {
                if (object instanceof $root.mesos.executor.Call)
                    return object;
                let message = new $root.mesos.executor.Call();
                if (object.executorId != null) {
                    if (typeof object.executorId !== "object")
                        throw TypeError(".mesos.executor.Call.executorId: object expected");
                    message.executorId = $root.mesos.ExecutorID.fromObject(object.executorId);
                }
                if (object.frameworkId != null) {
                    if (typeof object.frameworkId !== "object")
                        throw TypeError(".mesos.executor.Call.frameworkId: object expected");
                    message.frameworkId = $root.mesos.FrameworkID.fromObject(object.frameworkId);
                }
                switch (object.type) {
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "SUBSCRIBE":
                case 1:
                    message.type = 1;
                    break;
                case "UPDATE":
                case 2:
                    message.type = 2;
                    break;
                case "MESSAGE":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.subscribe != null) {
                    if (typeof object.subscribe !== "object")
                        throw TypeError(".mesos.executor.Call.subscribe: object expected");
                    message.subscribe = $root.mesos.executor.Call.Subscribe.fromObject(object.subscribe);
                }
                if (object.update != null) {
                    if (typeof object.update !== "object")
                        throw TypeError(".mesos.executor.Call.update: object expected");
                    message.update = $root.mesos.executor.Call.Update.fromObject(object.update);
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".mesos.executor.Call.message: object expected");
                    message.message = $root.mesos.executor.Call.Message.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a Call message. Also converts values to other types if specified.
             * @function toObject
             * @memberof mesos.executor.Call
             * @static
             * @param {mesos.executor.Call} message Call
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Call.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.executorId = null;
                    object.frameworkId = null;
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.subscribe = null;
                    object.update = null;
                    object.message = null;
                }
                if (message.executorId != null && message.hasOwnProperty("executorId"))
                    object.executorId = $root.mesos.ExecutorID.toObject(message.executorId, options);
                if (message.frameworkId != null && message.hasOwnProperty("frameworkId"))
                    object.frameworkId = $root.mesos.FrameworkID.toObject(message.frameworkId, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.mesos.executor.Call.Type[message.type] : message.type;
                if (message.subscribe != null && message.hasOwnProperty("subscribe"))
                    object.subscribe = $root.mesos.executor.Call.Subscribe.toObject(message.subscribe, options);
                if (message.update != null && message.hasOwnProperty("update"))
                    object.update = $root.mesos.executor.Call.Update.toObject(message.update, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.mesos.executor.Call.Message.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this Call to JSON.
             * @function toJSON
             * @memberof mesos.executor.Call
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Call.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUBSCRIBE=1 SUBSCRIBE value
             * @property {number} UPDATE=2 UPDATE value
             * @property {number} MESSAGE=3 MESSAGE value
             */
            Call.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUBSCRIBE"] = 1;
                values[valuesById[2] = "UPDATE"] = 2;
                values[valuesById[3] = "MESSAGE"] = 3;
                return values;
            })();

            Call.Subscribe = (function() {

                /**
                 * Properties of a Subscribe.
                 * @memberof mesos.executor.Call
                 * @interface ISubscribe
                 * @property {Array.<mesos.ITaskInfo>} [unacknowledgedTasks] Subscribe unacknowledgedTasks
                 * @property {Array.<mesos.executor.Call.IUpdate>} [unacknowledgedUpdates] Subscribe unacknowledgedUpdates
                 */

                /**
                 * Constructs a new Subscribe.
                 * @memberof mesos.executor.Call
                 * @classdesc Represents a Subscribe.
                 * @constructor
                 * @param {mesos.executor.Call.ISubscribe=} [properties] Properties to set
                 */
                function Subscribe(properties) {
                    this.unacknowledgedTasks = [];
                    this.unacknowledgedUpdates = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subscribe unacknowledgedTasks.
                 * @member {Array.<mesos.ITaskInfo>}unacknowledgedTasks
                 * @memberof mesos.executor.Call.Subscribe
                 * @instance
                 */
                Subscribe.prototype.unacknowledgedTasks = $util.emptyArray;

                /**
                 * Subscribe unacknowledgedUpdates.
                 * @member {Array.<mesos.executor.Call.IUpdate>}unacknowledgedUpdates
                 * @memberof mesos.executor.Call.Subscribe
                 * @instance
                 */
                Subscribe.prototype.unacknowledgedUpdates = $util.emptyArray;

                /**
                 * Creates a new Subscribe instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {mesos.executor.Call.ISubscribe=} [properties] Properties to set
                 * @returns {mesos.executor.Call.Subscribe} Subscribe instance
                 */
                Subscribe.create = function create(properties) {
                    return new Subscribe(properties);
                };

                /**
                 * Encodes the specified Subscribe message. Does not implicitly {@link mesos.executor.Call.Subscribe.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {mesos.executor.Call.ISubscribe} message Subscribe message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribe.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.unacknowledgedTasks != null && message.unacknowledgedTasks.length)
                        for (let i = 0; i < message.unacknowledgedTasks.length; ++i)
                            $root.mesos.TaskInfo.encode(message.unacknowledgedTasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.unacknowledgedUpdates != null && message.unacknowledgedUpdates.length)
                        for (let i = 0; i < message.unacknowledgedUpdates.length; ++i)
                            $root.mesos.executor.Call.Update.encode(message.unacknowledgedUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Subscribe message, length delimited. Does not implicitly {@link mesos.executor.Call.Subscribe.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {mesos.executor.Call.ISubscribe} message Subscribe message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subscribe.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subscribe message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Call.Subscribe} Subscribe
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribe.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Call.Subscribe();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.unacknowledgedTasks && message.unacknowledgedTasks.length))
                                message.unacknowledgedTasks = [];
                            message.unacknowledgedTasks.push($root.mesos.TaskInfo.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.unacknowledgedUpdates && message.unacknowledgedUpdates.length))
                                message.unacknowledgedUpdates = [];
                            message.unacknowledgedUpdates.push($root.mesos.executor.Call.Update.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Subscribe message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Call.Subscribe} Subscribe
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subscribe.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subscribe message.
                 * @function verify
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subscribe.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.unacknowledgedTasks != null && message.hasOwnProperty("unacknowledgedTasks")) {
                        if (!Array.isArray(message.unacknowledgedTasks))
                            return "unacknowledgedTasks: array expected";
                        for (let i = 0; i < message.unacknowledgedTasks.length; ++i) {
                            let error = $root.mesos.TaskInfo.verify(message.unacknowledgedTasks[i]);
                            if (error)
                                return "unacknowledgedTasks." + error;
                        }
                    }
                    if (message.unacknowledgedUpdates != null && message.hasOwnProperty("unacknowledgedUpdates")) {
                        if (!Array.isArray(message.unacknowledgedUpdates))
                            return "unacknowledgedUpdates: array expected";
                        for (let i = 0; i < message.unacknowledgedUpdates.length; ++i) {
                            error = $root.mesos.executor.Call.Update.verify(message.unacknowledgedUpdates[i]);
                            if (error)
                                return "unacknowledgedUpdates." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Subscribe message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Call.Subscribe} Subscribe
                 */
                Subscribe.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Call.Subscribe)
                        return object;
                    let message = new $root.mesos.executor.Call.Subscribe();
                    if (object.unacknowledgedTasks) {
                        if (!Array.isArray(object.unacknowledgedTasks))
                            throw TypeError(".mesos.executor.Call.Subscribe.unacknowledgedTasks: array expected");
                        message.unacknowledgedTasks = [];
                        for (let i = 0; i < object.unacknowledgedTasks.length; ++i) {
                            if (typeof object.unacknowledgedTasks[i] !== "object")
                                throw TypeError(".mesos.executor.Call.Subscribe.unacknowledgedTasks: object expected");
                            message.unacknowledgedTasks[i] = $root.mesos.TaskInfo.fromObject(object.unacknowledgedTasks[i]);
                        }
                    }
                    if (object.unacknowledgedUpdates) {
                        if (!Array.isArray(object.unacknowledgedUpdates))
                            throw TypeError(".mesos.executor.Call.Subscribe.unacknowledgedUpdates: array expected");
                        message.unacknowledgedUpdates = [];
                        for (let i = 0; i < object.unacknowledgedUpdates.length; ++i) {
                            if (typeof object.unacknowledgedUpdates[i] !== "object")
                                throw TypeError(".mesos.executor.Call.Subscribe.unacknowledgedUpdates: object expected");
                            message.unacknowledgedUpdates[i] = $root.mesos.executor.Call.Update.fromObject(object.unacknowledgedUpdates[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subscribe message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Call.Subscribe
                 * @static
                 * @param {mesos.executor.Call.Subscribe} message Subscribe
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subscribe.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.unacknowledgedTasks = [];
                        object.unacknowledgedUpdates = [];
                    }
                    if (message.unacknowledgedTasks && message.unacknowledgedTasks.length) {
                        object.unacknowledgedTasks = [];
                        for (let j = 0; j < message.unacknowledgedTasks.length; ++j)
                            object.unacknowledgedTasks[j] = $root.mesos.TaskInfo.toObject(message.unacknowledgedTasks[j], options);
                    }
                    if (message.unacknowledgedUpdates && message.unacknowledgedUpdates.length) {
                        object.unacknowledgedUpdates = [];
                        for (let j = 0; j < message.unacknowledgedUpdates.length; ++j)
                            object.unacknowledgedUpdates[j] = $root.mesos.executor.Call.Update.toObject(message.unacknowledgedUpdates[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Subscribe to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Call.Subscribe
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subscribe.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subscribe;
            })();

            Call.Update = (function() {

                /**
                 * Properties of an Update.
                 * @memberof mesos.executor.Call
                 * @interface IUpdate
                 * @property {mesos.ITaskStatus} status Update status
                 */

                /**
                 * Constructs a new Update.
                 * @memberof mesos.executor.Call
                 * @classdesc Represents an Update.
                 * @constructor
                 * @param {mesos.executor.Call.IUpdate=} [properties] Properties to set
                 */
                function Update(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Update status.
                 * @member {mesos.ITaskStatus}status
                 * @memberof mesos.executor.Call.Update
                 * @instance
                 */
                Update.prototype.status = null;

                /**
                 * Creates a new Update instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {mesos.executor.Call.IUpdate=} [properties] Properties to set
                 * @returns {mesos.executor.Call.Update} Update instance
                 */
                Update.create = function create(properties) {
                    return new Update(properties);
                };

                /**
                 * Encodes the specified Update message. Does not implicitly {@link mesos.executor.Call.Update.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {mesos.executor.Call.IUpdate} message Update message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Update.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.mesos.TaskStatus.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Update message, length delimited. Does not implicitly {@link mesos.executor.Call.Update.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {mesos.executor.Call.IUpdate} message Update message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Update.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Update message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Call.Update} Update
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Update.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Call.Update();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.status = $root.mesos.TaskStatus.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("status"))
                        throw $util.ProtocolError("missing required 'status'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Update message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Call.Update} Update
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Update.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Update message.
                 * @function verify
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Update.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let error = $root.mesos.TaskStatus.verify(message.status);
                    if (error)
                        return "status." + error;
                    return null;
                };

                /**
                 * Creates an Update message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Call.Update} Update
                 */
                Update.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Call.Update)
                        return object;
                    let message = new $root.mesos.executor.Call.Update();
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".mesos.executor.Call.Update.status: object expected");
                        message.status = $root.mesos.TaskStatus.fromObject(object.status);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Update message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Call.Update
                 * @static
                 * @param {mesos.executor.Call.Update} message Update
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Update.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.status = null;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.mesos.TaskStatus.toObject(message.status, options);
                    return object;
                };

                /**
                 * Converts this Update to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Call.Update
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Update.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Update;
            })();

            Call.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof mesos.executor.Call
                 * @interface IMessage
                 * @property {Uint8Array} data Message data
                 */

                /**
                 * Constructs a new Message.
                 * @memberof mesos.executor.Call
                 * @classdesc Represents a Message.
                 * @constructor
                 * @param {mesos.executor.Call.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message data.
                 * @member {Uint8Array}data
                 * @memberof mesos.executor.Call.Message
                 * @instance
                 */
                Message.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {mesos.executor.Call.IMessage=} [properties] Properties to set
                 * @returns {mesos.executor.Call.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link mesos.executor.Call.Message.verify|verify} messages.
                 * @function encode
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {mesos.executor.Call.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link mesos.executor.Call.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {mesos.executor.Call.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {mesos.executor.Call.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mesos.executor.Call.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("data"))
                        throw $util.ProtocolError("missing required 'data'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {mesos.executor.Call.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {mesos.executor.Call.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if (object instanceof $root.mesos.executor.Call.Message)
                        return object;
                    let message = new $root.mesos.executor.Call.Message();
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof mesos.executor.Call.Message
                 * @static
                 * @param {mesos.executor.Call.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.data = options.bytes === String ? "" : [];
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof mesos.executor.Call.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            return Call;
        })();

        return executor;
    })();

    return mesos;
})();

export { $root as default };
